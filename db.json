{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/melody/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":1,"renderable":1},{"_id":"themes/melody/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/melody/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/melody/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/melody/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/melody/source/js/copy.js","path":"js/copy.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/fireworks.js","path":"js/fireworks.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/head.js","path":"js/head.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/scroll.js","path":"js/scroll.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/sidebar.js","path":"js/sidebar.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/transition.js","path":"js/transition.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","path":"js/third-party/reveal/markdown.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","path":"js/third-party/reveal/marked.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","path":"js/third-party/reveal/math.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","path":"js/third-party/reveal/notes.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","path":"js/third-party/reveal/zoom.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","path":"js/third-party/reveal/reveal.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","path":"js/third-party/reveal/highlight.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"3c8904c974d7c04ec49f3abd1dc4b56b9b24ca44","modified":1528722098225},{"_id":"source/favicon.ico","hash":"822401324009c49021e6feea57b882278897942a","modified":1528722098235},{"_id":"themes/melody/.eslintrc","hash":"cfcd1b454efdd6cc1a0d43be7bc79027b84531f7","modified":1528730445041},{"_id":"themes/melody/.eslintignore","hash":"55f36fe3be2270ae2746eddbb2982e4e1472bc31","modified":1528730445040},{"_id":"themes/melody/.gitignore","hash":"7ed73f0edfb682b12a42070fd2730d5d712ec2fa","modified":1528730445042},{"_id":"themes/melody/.travis.demo.yml","hash":"4482d40a58a035ef96888dfc4ed96c861b8f78a5","modified":1528730445043},{"_id":"themes/melody/README.md","hash":"dd203ba6fd7b5719137cc5e9f8e18f5eaddc96ae","modified":1528730445045},{"_id":"themes/melody/LICENSE","hash":"c372b56b7553dafd2d8a8abf12d0dd71b4e2bfc0","modified":1528730445045},{"_id":"themes/melody/package.json","hash":"1a085e47cbce39f0fce09c4b27efb45bb2eb81da","modified":1528730445072},{"_id":"themes/melody/_config.yml","hash":"ab1fe10b3d3dafa20c012515eaf4d713beb0f343","modified":1528730445047},{"_id":"themes/melody/stylus_format.json","hash":"2fbe63b06901d202773457d7ce658ab6aa85d02b","modified":1528730445128},{"_id":"themes/melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528730445073},{"_id":"source/_data/melody.yml","hash":"8e61e301f7d247332c4de6e8f97e6e1cae5ffb6d","modified":1529216702298},{"_id":"source/_posts/debounce-and-throttle.md","hash":"fc0e9ff125597a83ca5ad8dab3a628e1ffa31b10","modified":1530200260486},{"_id":"source/_posts/flex.md","hash":"4861f93050c2b70fe1aa815b00a26a487f70c220","modified":1528871307855},{"_id":"source/_posts/abstract-syntax-tree.md","hash":"539b013c158066004e46e72836a4f5fc379154b7","modified":1529227654133},{"_id":"source/_posts/data-in-vue-component-is-function.md","hash":"15de21ed2a1cfea6676e36148d1c70a70a6eb840","modified":1529500666845},{"_id":"source/_posts/js-async.md","hash":"6a85fb1cbc156722a0062bed612163ca165d2186","modified":1528907028059},{"_id":"source/_posts/javascript-memory-management.md","hash":"20ba485ce39925b16a562d21e926640074b94a84","modified":1529657997557},{"_id":"source/_posts/module.md","hash":"ec8a7bdda55809302605a21dc477244786f5ef12","modified":1529216799339},{"_id":"source/_posts/scroll-bar.md","hash":"4787c473cde66f3af3f638b9bcf95117064f122e","modified":1529316788050},{"_id":"source/categories/index.md","hash":"2d64a02bd5c53c593d3852218cd47bf6645b41a7","modified":1528722098231},{"_id":"source/_posts/this.md","hash":"2ecbdb389ca5f1f20ec4b47c5b8e0739dd2e4e61","modified":1528906772006},{"_id":"themes/melody/.git/config","hash":"d7809cc4a5501b6ffc35ff5550336da4742592fe","modified":1527747826390},{"_id":"themes/melody/.git/HEAD","hash":"1c8a3861b6d2ee1af4d47959b7562a767f8480ae","modified":1527747826383},{"_id":"source/tags/index.md","hash":"fc4edd119f3d1c51d9f43ed055cb7afb986a0984","modified":1528722098236},{"_id":"themes/melody/.git/COMMIT_EDITMSG","hash":"95ce2598262caa9df85b1b7958a13a79b31b36c1","modified":1527748613271},{"_id":"themes/melody/.git/index","hash":"1581c4f852f06b2b65b744c782c536690cdb04a0","modified":1528730451617},{"_id":"themes/melody/.git/FETCH_HEAD","hash":"84651db39e11c708309b622dca732d0a38ebcb87","modified":1530200244607},{"_id":"themes/melody/.git/packed-refs","hash":"45ff5e9b4dc9dece633e81729606b17de19d4ffc","modified":1527747826377},{"_id":"themes/melody/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1527747820066},{"_id":"themes/melody/.vscode/launch.json","hash":"3098e8e395a33fa130747d2fd104a21278f266a6","modified":1528730445044},{"_id":"themes/melody/.git/sourcetreeconfig","hash":"8f91ae6cdb51997e284df340107141ce0e6cf5a2","modified":1528730402394},{"_id":"themes/melody/.github/ISSUE_TEMPLATE.md","hash":"c5f14119189d9930fd7afd6e8822592fcd314ecf","modified":1528730445042},{"_id":"themes/melody/.vscode/settings.json","hash":"2e4acade0812cbeaf1363971c696a1d52d4f05ba","modified":1528730445044},{"_id":"themes/melody/languages/default.yml","hash":"5859596db5ed9b2e7f86874c4df71409323ef9b8","modified":1528730445048},{"_id":"themes/melody/languages/zh-Hans.yml","hash":"a0b752f18dd31e56c3e4ae6860f87f92c2e1a95c","modified":1528730445049},{"_id":"themes/melody/layout/category.pug","hash":"ea5f82d69e586f293f428f3b237c17bf873b4f03","modified":1528730445050},{"_id":"themes/melody/languages/en.yml","hash":"5859596db5ed9b2e7f86874c4df71409323ef9b8","modified":1528730445048},{"_id":"themes/melody/layout/gallery.pug","hash":"c083a7bbf5f46305daed74632aef3403b7d94dc7","modified":1528730445050},{"_id":"themes/melody/layout/archive.pug","hash":"2133e9f369dac19b9f843fc956521f864ace7567","modified":1528730445049},{"_id":"themes/melody/layout/page.pug","hash":"6bb4336f74784679ac3f8691b0cce427f2282e02","modified":1528730445070},{"_id":"themes/melody/layout/index.pug","hash":"5e969c09fa5902829ad0b14c0af8d432bd4c7078","modified":1528730445069},{"_id":"themes/melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1528730445071},{"_id":"themes/melody/layout/post.pug","hash":"84268639485e56638f07805f65b965caf69c201a","modified":1528730445070},{"_id":"themes/melody/scripts/gallery-tag.js","hash":"74e2e95f8daec619578f4b7dd1ed77cd5907f37e","modified":1528730445073},{"_id":"themes/melody/layout/tag.pug","hash":"ca333911bc97bc9d3eba6e1bc05e96b209ecedfb","modified":1528730445071},{"_id":"themes/melody/scripts/replace-config.js","hash":"3439d79603f66830925a19e136e9ead54a85ed8b","modified":1528730445074},{"_id":"themes/melody/source/favicon.ico","hash":"822401324009c49021e6feea57b882278897942a","modified":1528730445093},{"_id":"themes/melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528730445098},{"_id":"themes/melody/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1527747820067},{"_id":"themes/melody/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1527747820068},{"_id":"themes/melody/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1527747820068},{"_id":"themes/melody/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1527747820067},{"_id":"themes/melody/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1527747820067},{"_id":"themes/melody/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1527747820067},{"_id":"themes/melody/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1527747820068},{"_id":"themes/melody/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1527747820066},{"_id":"themes/melody/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1527747820069},{"_id":"themes/melody/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1527747820069},{"_id":"themes/melody/.git/logs/HEAD","hash":"b9521ca9f69c39cd31f0fe9ad191bce12c254ac0","modified":1527748613390},{"_id":"themes/melody/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1527747820068},{"_id":"themes/melody/layout/includes/additional-js.pug","hash":"fd53e30c9c5bc497538753c8c6a2bc3294f03494","modified":1528730445051},{"_id":"themes/melody/layout/includes/header.pug","hash":"7efbfdb22ed0a76d707bbe83cca95a89b548c6ee","modified":1528730445055},{"_id":"themes/melody/layout/includes/config.pug","hash":"f11a6427cf7c06b357b336ba6ba60149c324c750","modified":1528730445053},{"_id":"themes/melody/layout/includes/layout.pug","hash":"56a6eca22e050faf4ace834294f9c07bfb07291a","modified":1528730445056},{"_id":"themes/melody/layout/includes/footer.pug","hash":"0e9f1778f021f1c205f0b1be83014fba576797af","modified":1528730445054},{"_id":"themes/melody/layout/includes/nav.pug","hash":"d9d341d690a03680ef66c4d84715cab1f5a39372","modified":1528730445057},{"_id":"themes/melody/layout/includes/recent-posts.pug","hash":"aefcb3462d1b9ed2fb8d16414a4f580fc4e7a4e7","modified":1528730445059},{"_id":"themes/melody/layout/includes/pagination.pug","hash":"556d055e2f0c30d41ec16ef7943bd3227afcdfd1","modified":1528730445058},{"_id":"themes/melody/layout/includes/sidebar.pug","hash":"4369f692f5069f3d510e35c00de2702cb90761b2","modified":1528730445066},{"_id":"themes/melody/layout/includes/head.pug","hash":"eb40f41ad1b1133c4a210009af7e9cc4b8b8eabd","modified":1528730445055},{"_id":"themes/melody/source/css/index.styl","hash":"111ec52cde3e5fae92cf61dc2a1bd8726b3aa8f9","modified":1528730445092},{"_id":"themes/melody/source/css/var.styl","hash":"bbb372afd00ecdeee767266692e9f0792ac6be2f","modified":1528730445093},{"_id":"themes/melody/source/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1528730445095},{"_id":"themes/melody/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1528730445094},{"_id":"themes/melody/source/js/copy.js","hash":"cfae08721664d19cf0059172b994c0a2e253d334","modified":1528730445096},{"_id":"themes/melody/source/js/fancybox.js","hash":"0c2c506559129a5108893cf054b9aa46fe878fc3","modified":1528730445096},{"_id":"themes/melody/source/js/fireworks.js","hash":"5e3da1344966d5d6328a410cad69e92297699f3b","modified":1528730445097},{"_id":"themes/melody/source/js/head.js","hash":"212a32f824cadea0167bf4204c9714df5b7e5f5d","modified":1528730445097},{"_id":"themes/melody/source/js/scroll.js","hash":"73d57e7cf9921ba5724ad48b8d0e8b25dbce059f","modified":1528730445099},{"_id":"themes/melody/source/js/sidebar.js","hash":"185790b0d811fd7eeb96f78b1b1195dd71df1da6","modified":1528730445101},{"_id":"themes/melody/source/js/transition.js","hash":"998c3bb6523a248d4dd4d747510c03a914a6378d","modified":1528730445126},{"_id":"themes/melody/source/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1528730445128},{"_id":"themes/melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528730445054},{"_id":"themes/melody/.git/objects/03/fecc945f3433e8b013c174a76680acdf423948","hash":"42f354de1e0991791218a5f7f040729147beb3f2","modified":1527748599354},{"_id":"themes/melody/.git/objects/19/5bf4906000fb01a3aafff445a228fc00886f4a","hash":"07afbf4b358aac2fb6f890f38a759f4b543f1a37","modified":1527748599353},{"_id":"themes/melody/.git/objects/0f/b7c8fe9a41200661c94772b4ed18563f897bf1","hash":"3e647252d92dbff6e944ced1f3de07132f76681b","modified":1528730410000},{"_id":"themes/melody/.git/objects/0a/180ecad0ef0c2597fa9d583ccca8a83e42a561","hash":"e7885aab4edf37cd711374f57bda31926e4cbb1b","modified":1528730410000},{"_id":"themes/melody/.git/objects/0e/e7bb7482026214a1d0c657edd078fdbac20aaf","hash":"84df4f63a3b00a412a53172f9c1fb4effb822c5f","modified":1528730410000},{"_id":"themes/melody/.git/objects/18/7384fea0ccea1d3ef1d029ef52e58786d11bcf","hash":"87dd9893c9e70a2d2a5388b13d9ece1c7eafb0ea","modified":1527748592848},{"_id":"themes/melody/.git/objects/19/aa8d7de969ceabf57e247867cebed3eaffd341","hash":"ece0efed0e4a9dcfaa4977172f3898084dbe6db4","modified":1528730410000},{"_id":"themes/melody/.git/objects/19/dd228efe7876400aad7111d090494fbd1ba8e4","hash":"0a1a480bd840a60037bf4ef4f61f04aa06e05c9d","modified":1528730410000},{"_id":"themes/melody/.git/objects/16/cc47b626408b11088ed4098f82f762aa9df781","hash":"59de9d0bb4c0ffd71dd3c2c88612eb946a4bb30e","modified":1528730410000},{"_id":"themes/melody/.git/objects/16/b013b5d3d3567ebd0d028755a51cdad7151b94","hash":"9848da796401977abdae374300452648b1ce37b6","modified":1528730410000},{"_id":"themes/melody/.git/objects/19/f8fb61df4b04a4ba56130453e195d319c7cfa5","hash":"0ef46a0ab4e3eecdb60c6e37203f0e6a22ce273b","modified":1528730410000},{"_id":"themes/melody/.git/objects/1b/e3073434fadefa99fbbe336a74329cdb1d35ae","hash":"71780bc05658396ed163cb3479866d8811342622","modified":1528730410000},{"_id":"themes/melody/.git/objects/00/ab2242c8133d35b8d9bef7e856fd38866c81be","hash":"c1699dccc6d4e942544cab4f72291920e7f5bfab","modified":1528730410000},{"_id":"themes/melody/.git/objects/26/80626f52accc2f2af8d0e6524267868d5ef864","hash":"d1cb42f733cfd60c04634b8b7248dae522da4ec3","modified":1527748599349},{"_id":"themes/melody/.git/objects/00/94296097c860ac8fe24a30e3ce09d2eac189ec","hash":"e99110be7f3889bf10932cd7ced01a2d8eead11c","modified":1528730410000},{"_id":"themes/melody/.git/objects/1d/42cae33b327d34e877fe5e9864e3a942081c80","hash":"388e25926c24f4f18c9d9e1114fe2139acc9da24","modified":1528730410000},{"_id":"themes/melody/.git/objects/26/e717814fe821fd8200235862fbc77018ffa57e","hash":"013077d47cdf7c6e47f152fe39f88fd0ce17ad75","modified":1528730410000},{"_id":"themes/melody/.git/objects/28/52b1e2d3337e6e755c4cdbb37affcf6781bb89","hash":"e09598e04195092fcccc563f3777a403fc1edb58","modified":1528730410000},{"_id":"themes/melody/.git/objects/1e/e277bd5cbbc392f6c7b4eee48358d111574b04","hash":"50c5d17856cab388809946c296496caa012d10bc","modified":1528730410000},{"_id":"themes/melody/.git/objects/26/f8e07ac578d68f11a8abcdea6fac8e5d979086","hash":"d59c6760b739c398363489a3cfb281484f9fd2bd","modified":1528730410000},{"_id":"themes/melody/.git/objects/31/a4a66b946b9fc9da86eaa1cc5de3c1b38f2eda","hash":"7b5b0785966455a49886440b48abbec3e7b38a2f","modified":1528730410000},{"_id":"themes/melody/.git/objects/22/91379a16396a9ae37004c4a35f11ecfdec2f9e","hash":"62b070161e13b1a529f336f7c8760a7fdfed8c5f","modified":1528730410000},{"_id":"themes/melody/.git/objects/2a/c27b2fe45c4c9b357d5772a7b25fbf97c1d5ce","hash":"f8dd80b939187869f28e3b24ebc8080170beb514","modified":1528730410000},{"_id":"themes/melody/.git/objects/39/df1bc29c65460f9784d9c60eedfd59ae6f9ac6","hash":"f2610577e2addf8f6a94ccd2bf295a8cf9794e33","modified":1528730410000},{"_id":"themes/melody/.git/objects/39/764da67bada3278773ee54b0b8f7868c318093","hash":"7c231704264f9ae7cf1080adfd8c2eaf6c1968f1","modified":1528730410000},{"_id":"themes/melody/.git/objects/42/7cfb37e63a0795ff7d76e6dede7a230e18419d","hash":"ef04ce2f6f0bcf9889d6bf4b6af5ccfe2b2519e6","modified":1528730410000},{"_id":"themes/melody/.git/objects/44/4087aade1f5368d8a61ac29ddffbe596e8140d","hash":"70a634bc2ca8223a7ebe17d3eaa5ebf20c79aaeb","modified":1528730410000},{"_id":"themes/melody/.git/objects/46/60bd1b7d6d98c2d2ae31dc9bda7a3a37eac36e","hash":"ada00b935e07b473b3e9a0816e3cd782b7509e58","modified":1528730410000},{"_id":"themes/melody/.git/objects/2c/97b807c80881ba2c7ab20f35f2318539657e46","hash":"43248f0b2906e3e8e56165f97cb7a77540b99c65","modified":1528730410000},{"_id":"themes/melody/.git/objects/33/4aab81e9f3a47e016a6c57ba92a0b7294fe4a5","hash":"b471479c41d2161c2fc4f71a41d04c2af23b2033","modified":1528730410000},{"_id":"themes/melody/.git/objects/49/f7b64d509de838f94e26dad1dac0ff650268d3","hash":"6c3ea5146e014d86a40d989735cea19f883ae6d4","modified":1528730410000},{"_id":"themes/melody/.git/objects/49/e79aac26e20500020f0fcc36e97a88a72e6048","hash":"d1f2a7ac9785c2ff0e6488bb4e377b50b431ed9c","modified":1528730410000},{"_id":"themes/melody/.git/objects/47/873d443b61021a4bb68fc2d99b84f0280c35e9","hash":"94e7622dd13738ea03cc9600eff321bc24f97e22","modified":1528730410000},{"_id":"themes/melody/.git/objects/4e/71988aca1c6e20a156461fefb18d70d7b8377f","hash":"878b3bcfb162144e13c40c06e9f6f7b1804d314c","modified":1528730410000},{"_id":"themes/melody/.git/objects/2c/45630f4e2576766563007fee936cef4947b056","hash":"626b933aa3573cda9246db2178ca03dc62f1c0ad","modified":1528730410000},{"_id":"themes/melody/.git/objects/59/5053267e60d0dceb7ecbd912c9b03256c5dc5b","hash":"d3b27c2faf0f38413423eba167a9b7df715959a2","modified":1527748613385},{"_id":"themes/melody/.git/objects/47/0242341d65c3217ba5989f87ca8161cd048c6a","hash":"48e87276771f9de95d9ec1f846a7cac06be1e3e9","modified":1528730410000},{"_id":"themes/melody/.git/objects/4b/6b40d8a7f8d57d1310e09add8b7af18ce2cda4","hash":"13b973cc2e8e1cf800f09abcba947f6793ba91b3","modified":1527748599355},{"_id":"themes/melody/.git/objects/3d/01edfb84ded3b17404bc30cedc6034722812b4","hash":"0ebc581641e351c86f1d58036f1ee423ec62f700","modified":1528730410000},{"_id":"themes/melody/.git/objects/54/169fd903dfd88c8281e45c9dd43f8565110bcb","hash":"2c8e48ad8a6e5e0db6f3982fcaf3cd79720047de","modified":1528730410000},{"_id":"themes/melody/.git/objects/55/5c1dc1d9da18154cb48388d5e494f3f16119f8","hash":"9ebe13c1052a12dd3ff04e2ccf6a102f68d2eea4","modified":1528730410000},{"_id":"themes/melody/.git/objects/5c/081e0f5d4499e60c3b8d5b94d2c0a646531ed6","hash":"3e0b50adb1319369909e293ca885f1db9197b514","modified":1528730410000},{"_id":"themes/melody/.git/objects/56/601233a0308a615f395ee8592eab594c8a4900","hash":"a6c53515f6d799d3c32ec7d973408694b249b5cd","modified":1528730410000},{"_id":"themes/melody/.git/objects/47/2ac2361b65136b393d652de25341e2ea44f299","hash":"74116cab2994fa70e5ae047cb511deac2c34f624","modified":1528730410000},{"_id":"themes/melody/.git/objects/65/2d1ff600dc0ea347c08497bf6e456bbdbfca39","hash":"a0d46f1cfba946cf01788fa1fa710893958f366c","modified":1528730410000},{"_id":"themes/melody/.git/objects/64/4d35e274fd64ddaf6d12af813e820c424176a9","hash":"989065111c61a95e4080799a003362a6f26478d1","modified":1528730410000},{"_id":"themes/melody/.git/objects/65/ab4aacc68569720ca34610d63a688b5b424343","hash":"d0232f9b5d102815eb76f939a24219aea6b301a5","modified":1528730410000},{"_id":"themes/melody/.git/objects/6b/8e5ad6a81c00445ae46034b2499fad8dec0df3","hash":"3f4e448b4c04fa5c6314f7d9407b3746e1b4bcfd","modified":1528730410000},{"_id":"themes/melody/.git/objects/67/1d3c5c0c9987df601313638cfc676121a2ea34","hash":"73074087e009f655a3cd8b59eb9cc5c71b8cb010","modified":1528730410000},{"_id":"themes/melody/.git/objects/4d/17a641df95e1b2e090eb2f8c51e300decc05bf","hash":"3b46ad268e3a23282f799aae32b4096f724145a0","modified":1528730410000},{"_id":"themes/melody/.git/objects/8d/de72159d4e8bcd8a0c7328eb79e7b203b15cc8","hash":"61112d87153dbf3cabbb4f9607b549c5c31689c3","modified":1527748599352},{"_id":"themes/melody/.git/objects/6b/8681599e04a250436d411682253c12ebffee61","hash":"324be301ddfc378c4e48b577abe88202c9b3bbd1","modified":1528730410000},{"_id":"themes/melody/.git/objects/6e/295cc5a4a6460acd6221d4d3120a8d7a4d4c99","hash":"f90eca17050f78e21d932345edc03456e7e49cbd","modified":1528730410000},{"_id":"themes/melody/.git/objects/69/1ef79c0246fe2d13fd0b071f6f26c27f333c17","hash":"92554b67a92fec7860b3d0e616744f1a434ebc68","modified":1528730410000},{"_id":"themes/melody/.git/objects/8b/0ec90ab8a9148b39b38794d57f164885ee4175","hash":"4c5c2872ec989384500a41902d1240f0944a924a","modified":1528730410000},{"_id":"themes/melody/.git/objects/8f/54670a6ebdedfbebab5cf54c64df06e10d0570","hash":"daf68e67f574e371428df27a52168e9c1e249ecc","modified":1528730410000},{"_id":"themes/melody/.git/objects/8e/8f7f6cdd67871b02eb2f1bdd82e998cb00559a","hash":"9659adc98c9956219aa731717121a8fda6d97346","modified":1528730410000},{"_id":"themes/melody/.git/objects/84/18be0adaf06d42331ce7ca7196d8300eaa7b56","hash":"1eb16eb63a0d6c1118ce4cd491207231deb65522","modified":1528730410000},{"_id":"themes/melody/.git/objects/94/f1d36999ea7e2787fe6bc63c1e27ff7854d730","hash":"07ba72a2066473735d8fbc9cef5169944bcde621","modified":1528730410000},{"_id":"themes/melody/.git/objects/aa/15ca30c1a31c31b7599c121c32ffefcf7c16be","hash":"62bbbb6061d60490c865ed66b02fc433caec8a4a","modified":1527748599350},{"_id":"themes/melody/.git/objects/98/145c7caba87a5f0a2690c524e9eb240e5d084c","hash":"5e8e5679422bc7584586dbab7642a7c3c7dba164","modified":1528730410000},{"_id":"themes/melody/.git/objects/a8/0e44af98924dedfbbc00d568302640d248f329","hash":"2d1b45b3bca7a7e2ef2f17ef28d40fb7c7a0f4cf","modified":1528730410000},{"_id":"themes/melody/.git/objects/9d/7f244e1db2f9666930fe2a621acdace49ec011","hash":"b707d29c80ee15ff9035b1e6dc41394a6ad153af","modified":1528730410000},{"_id":"themes/melody/.git/objects/92/3ccc78a6fe33873cf5010c859b059b320d1133","hash":"1d519ca9ad1f279721d7558aea6f9b089e7bdb6a","modified":1528730410000},{"_id":"themes/melody/.git/objects/ab/39c7a4b1d23a3722c52a29a9fb6a46036cbc38","hash":"e1af7a5abb364e9b979fb9c9bc96b897e7cae539","modified":1528730410000},{"_id":"themes/melody/.git/objects/93/7d65f3c26c597f871cf662b6c2292dac24f341","hash":"f85f0c6f4e635503bc29207f6d99dadb4c09087b","modified":1528730410000},{"_id":"themes/melody/.git/objects/ac/f906fa52da03048132b29f001607ce000018af","hash":"897d281c91c792b031c6f8fd2fac0d3a38def5a6","modified":1528730410000},{"_id":"themes/melody/.git/objects/ac/408dda2dc56ae63d74f2128d3f1d8f3463502c","hash":"329ace2340377456c54e13a275753b70a5284a38","modified":1528730410000},{"_id":"themes/melody/.git/objects/b0/4c842a3bbad519072502dd07eabc4bd1c2bcd4","hash":"6fe09f242d6c5763b10ff1f328eb0129bbf03c21","modified":1528730410000},{"_id":"themes/melody/.git/objects/b4/5fb6adfe64cf369f25844f2b0d8480fcfd6920","hash":"064ade2a3a8791f49b063c08bf7db98111e7e4d8","modified":1528730410000},{"_id":"themes/melody/.git/objects/b1/bb0949bbb9f40f8012c516bd7240020cf78a85","hash":"3bbee2981aa522edeae116e990d57340e97f0c37","modified":1528730410000},{"_id":"themes/melody/.git/objects/b8/39e132e507feb08bfed77ae4684a15a7dc0d19","hash":"c42907967b08e797ac3d5dcdcfd5392436f55346","modified":1528730410000},{"_id":"themes/melody/.git/objects/ba/e2e63b91b0c92b5dca393fcd34721ecb937e76","hash":"79f35a9e7991ce1f84410c051dc1c33af1700ce3","modified":1528730410000},{"_id":"themes/melody/.git/objects/bf/4e465b11ea157076179d2a62ea98ddf158dac2","hash":"377c772b078dff5320515e5670bbf6ef57b16f3c","modified":1528730410000},{"_id":"themes/melody/.git/objects/bf/fac26e645361cdb605a15085b1b358ac754a73","hash":"fcad6190c3c6f77d06b9d66730ca5b5ee61c3fbb","modified":1528730410000},{"_id":"themes/melody/.git/objects/c0/40f5bcb3ae1740bb816c9c6ec507b01b43e2d3","hash":"d3d86a0726e96aa344a949e99edce0dd7185c1a5","modified":1528730410000},{"_id":"themes/melody/.git/objects/c4/78b1f57c783526ecc36ef19b007695d7da6335","hash":"033c94fd4858c48db55bf50de6bb9ee5ce3e307b","modified":1528730410000},{"_id":"themes/melody/.git/objects/bf/79adddccf42c20ddd5f6c25725fcae5896d6f2","hash":"0c6268da77375e728fc0fdbfd5affed8df07df6d","modified":1528730410000},{"_id":"themes/melody/.git/objects/c6/e1447eaff554578e794bf6a9770a37b907d205","hash":"48553b1e8dbc465cf563b9e020d3a6d08dc8cfcb","modified":1528730410000},{"_id":"themes/melody/.git/objects/c8/129c9a4b83dd663397e62f5eefb0de0aa35ee1","hash":"37edb958a9564844379f199f1ddd677cfb003d7e","modified":1528730410000},{"_id":"themes/melody/.git/objects/cd/53413903193d76e6501ad8fef77941d671e40b","hash":"df9bd6257cb75f07f7add95cc5b28a76fd76673d","modified":1527748592849},{"_id":"themes/melody/.git/objects/c9/8348d6a28434045814197f50c25ecb0276a89a","hash":"fe976d83709c22216b5de75a6ccda96feab3ab1e","modified":1528730410000},{"_id":"themes/melody/.git/objects/ce/a05b4e208c440fc088209955048c08d45e7d4d","hash":"e00ffe83761412e0b85c11094ab9085a4e189763","modified":1528730410000},{"_id":"themes/melody/.git/objects/ce/d190922aa537c2b32ea2d5bb1531a91ba36229","hash":"0d61f954a58cc68593dba5f0261ab001d6736194","modified":1528730410000},{"_id":"themes/melody/.git/objects/c9/c4ffe819f3d3914b3847f7fd99c4a35d50d12d","hash":"9d0e64d8be95a79bc4eafd9ae5f2bdf75462c694","modified":1528730410000},{"_id":"themes/melody/.git/objects/d0/deae6e2e30b41ca285b2e197154f07afb87f5e","hash":"0c4ef0ddce74451943af178eec8b6340d224819f","modified":1528730410000},{"_id":"themes/melody/.git/objects/d3/4afcf5abca3f210a39999ddeb570599b0d41c7","hash":"aeb33dd5524b5c7cd5a861df84dbd8dc9f24524b","modified":1528730410000},{"_id":"themes/melody/.git/objects/d2/f7afe0eb26d7621868829801f828b749917e97","hash":"f9e1a59d4d6cc340a443c63f5bb30c8c42dca1c8","modified":1528730410000},{"_id":"themes/melody/.git/objects/d3/ee3d084f01e287f18acae4b66f9ab4fe5f5a67","hash":"18920de6a10a8a4f03610310d1a63e4c0d59df32","modified":1528730410000},{"_id":"themes/melody/.git/objects/d8/7e91425214c188797004b532fac58b2e0c2625","hash":"7a73153b1c99dfab534b2bf744643d266add9120","modified":1528730410000},{"_id":"themes/melody/.git/objects/d9/f87bac70d7d6bcca6f9785f3cf51f62372e8ad","hash":"367362c116aa748b4449da241826501025b1c095","modified":1528730410000},{"_id":"themes/melody/.git/objects/de/91adeaf2a180d97cc3614809d882185b632bd4","hash":"c0997135b24e01b0f0d71135156955aaefc0561c","modified":1528730410000},{"_id":"themes/melody/.git/objects/e3/b97799ae2556fcd8d2b1bfbe2a9317bf89be96","hash":"22e702ac6e10a7e901ce8e605b4f175d07d5ce52","modified":1528730410000},{"_id":"themes/melody/.git/objects/e3/589a6baa4f53579df5ac0a673ee78204e44c69","hash":"a30e24443df94299547b5c28bd3b80f059f865cb","modified":1528730410000},{"_id":"themes/melody/.git/objects/ec/f8d7468422d6896731aefa390a82bf9ce44e89","hash":"103965422a71584c290d3073263af3a9da95b4e8","modified":1527748599350},{"_id":"themes/melody/.git/objects/e5/e20f0ed4f1a68ff839885bbaac3e609deaf0e1","hash":"619f2eecfa4fc2a6a8d8a5cf058e8ff59eed46bf","modified":1528730410000},{"_id":"themes/melody/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391","hash":"c2baae88d6364d878fd67e778c6a5d8306ad4ab0","modified":1528730410000},{"_id":"themes/melody/.git/objects/e7/54ed474ed66bbe1db31c4ab3245e83b7d1f1c1","hash":"3f8bbafe9fd9488c4808885efc01e1d0f43f6447","modified":1527748592852},{"_id":"themes/melody/.git/objects/e7/6361d1707a60dbce701daf9a1208d8d49208be","hash":"e76790629752391d32e8def0bb945cf0b1828023","modified":1528730410000},{"_id":"themes/melody/.git/objects/e9/d946c8dcd97a4d7e87cff5f998f01c755014b6","hash":"1a732a386e64ccfcdf84e731940bbadad2fbcee3","modified":1528730410000},{"_id":"themes/melody/.git/objects/f0/6813108ce48c038c6e20fdc964f311790f6602","hash":"cbdcb0a77ebb77067bf059a154bb33a86dba4720","modified":1528730410000},{"_id":"themes/melody/.git/objects/f5/9adecec750884693600906fae734e7fda0ebc6","hash":"37dfb319797788e1d54f976f2cf7c4e3886195d9","modified":1528730410000},{"_id":"themes/melody/.git/objects/f0/7c9f678bb715c288e0951b4842864e464a287d","hash":"f7f17899ef1886b6c8b405e137be5f5bc903df9e","modified":1528730410000},{"_id":"themes/melody/.git/objects/f1/9332d7cb9f1558ad6c6cf812c7922eb838e431","hash":"4074092630c92ef0b3a84c10bc48716ad9f44683","modified":1528730410000},{"_id":"themes/melody/.git/refs/heads/moke","hash":"ea0566aa509718467e741a6396bf40e6d01ab513","modified":1527748613390},{"_id":"themes/melody/.git/objects/pack/pack-9057a617059a73ace91b451aac3acbe584571538.idx","hash":"f477fe265785385fde3b1ef197797d54795f0336","modified":1527747826357},{"_id":"themes/melody/.git/objects/f6/0a336be2db83e935911273f2f736ba6873370d","hash":"7bc087b4b6b5471c9f0a6ffe08c0273e6411fc01","modified":1528730410000},{"_id":"themes/melody/layout/includes/comments/disqus.pug","hash":"989de5ed05fb462e5a46601eb41ab3963b4d4e9d","modified":1528730445051},{"_id":"themes/melody/layout/includes/comments/gitalk.pug","hash":"86bdbc4a52024c3573bea27817394dd118b70a26","modified":1528730445051},{"_id":"themes/melody/layout/includes/comments/index.pug","hash":"6c16214e5945142e5f3b58e7694397e26f28849d","modified":1528730445052},{"_id":"themes/melody/layout/includes/comments/gitment.pug","hash":"4a9e172c2b7a9f6f1f8c313d0d45266de828f209","modified":1528730445052},{"_id":"themes/melody/layout/includes/comments/laibili.pug","hash":"97de1d1fb0459e7a2394ac2f5e449adf9b6986cb","modified":1528730445052},{"_id":"themes/melody/layout/includes/comments/valine.pug","hash":"e87eca6aed5a7e234a8acaa93e08ed674cb1531e","modified":1528730445053},{"_id":"themes/melody/layout/includes/count/busuanzi.pug","hash":"43fd52287adef41dc083738e25f24390d72b572c","modified":1528730445053},{"_id":"themes/melody/layout/includes/mixins/slide.pug","hash":"91975f700b20131ab4df4d2ea3e1acc8bf2d3eef","modified":1528730445057},{"_id":"themes/melody/layout/includes/mixins/article-sort.pug","hash":"da7572fcc4aac6b63a651a3320e5d853ea07b347","modified":1528730445056},{"_id":"themes/melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1528730445054},{"_id":"themes/melody/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1528730445059},{"_id":"themes/melody/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1528730445060},{"_id":"themes/melody/layout/includes/search/local-search.pug","hash":"85347ad18da0a81bfa7b0c0a8643886f4c0cacc1","modified":1528730445060},{"_id":"themes/melody/layout/includes/share/add-this.pug","hash":"17a11c1c36c9078639c2a82628ce5fc6584daffb","modified":1528730445061},{"_id":"themes/melody/layout/includes/share/index.pug","hash":"65ea837388ddf806f89c3b9082ceb31776dc6be5","modified":1528730445061},{"_id":"themes/melody/layout/includes/share/share-js.pug","hash":"f428b3bbc7a22d176098826c5e0aadf32b47f865","modified":1528730445062},{"_id":"themes/melody/layout/includes/slide/layout.pug","hash":"6b24f298d442e409c1149e4c1df38efce0453883","modified":1528730445067},{"_id":"themes/melody/layout/includes/slide/script.pug","hash":"c35c2af397f41bb858070032c702e8503371fd07","modified":1528730445068},{"_id":"themes/melody/layout/includes/third-party/mathjax.pug","hash":"035656871566bdcb8c45d3a0fe0b0835c524eb11","modified":1528730445069},{"_id":"themes/melody/source/css/_global/index.styl","hash":"c3418bbacedfe134f64f2ad5e7ae7a9b7292f84f","modified":1528730445074},{"_id":"themes/melody/source/css/_highlight/highlight.styl","hash":"a0c6043011caf916d734673403c6543559acf68f","modified":1528730445076},{"_id":"themes/melody/source/css/_highlight/diff.styl","hash":"b0079f6da761935b720d70dafd826ef62fad86d2","modified":1528730445075},{"_id":"themes/melody/source/css/_layout/comments.styl","hash":"e58602aad6792f1a5dbda0677ecb04d21ac10e97","modified":1528730445077},{"_id":"themes/melody/source/css/_layout/head.styl","hash":"049c5eddcb2ee80fdce91992087df2e7b80afd9c","modified":1528730445078},{"_id":"themes/melody/source/css/_layout/footer.styl","hash":"a72a6bb4477c18a14a2b779db183df22b4cba272","modified":1528730445078},{"_id":"themes/melody/source/css/_highlight/theme.styl","hash":"7d85860927afa1d93b4a39febff3d95a73de4c36","modified":1528730445076},{"_id":"themes/melody/source/css/_layout/pagination.styl","hash":"a3f52d1f7ff1eaead8df016b2a4def6f7b4e9559","modified":1528730445080},{"_id":"themes/melody/source/css/_layout/sidebar.styl","hash":"67b99a55f6fc9daa42de9c73c2adc61bd7513de6","modified":1528730445081},{"_id":"themes/melody/source/css/_layout/page.styl","hash":"79d551beaea2458abcedbf585618b9fa8d3d22e5","modified":1528730445079},{"_id":"themes/melody/source/css/_search/index.styl","hash":"031b1577e8a07f18c047b27e6b4723b14ae018b0","modified":1528730445083},{"_id":"themes/melody/source/css/_search/local-search.styl","hash":"e1b082bfb4e04ffe42efa149b02fdb66aad682a7","modified":1528730445086},{"_id":"themes/melody/source/css/_layout/post.styl","hash":"9bdd9b5c957c3c5494cdf0b40700fd1f08162ac5","modified":1528730445080},{"_id":"themes/melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1528730445091},{"_id":"themes/melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1528730445090},{"_id":"themes/melody/source/css/_search/algolia.styl","hash":"8129d254a30e3a66cdb7eb77253036221928f47b","modified":1528730445082},{"_id":"themes/melody/source/js/search/algolia.js","hash":"884ecf62fe22cb869bbb7968ee770c1a699f591d","modified":1528730445100},{"_id":"themes/melody/source/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1528730445102},{"_id":"themes/melody/source/js/search/local-search.js","hash":"951bbc3fe459a448d5a3e555ad84225272d91071","modified":1528730445100},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1528730445106},{"_id":"themes/melody/source/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1528730445125},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1528730445125},{"_id":"themes/melody/.git/logs/refs/heads/moke","hash":"b9521ca9f69c39cd31f0fe9ad191bce12c254ac0","modified":1527748613391},{"_id":"themes/melody/source/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1528730445108},{"_id":"themes/melody/.git/refs/remotes/origin/HEAD","hash":"2c142208129b78a4616cbb6798f96f4fb3580296","modified":1527747826383},{"_id":"themes/melody/.git/refs/remotes/origin/moke","hash":"ea0566aa509718467e741a6396bf40e6d01ab513","modified":1527748626171},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","hash":"8c9495c76d5aa00d3dfb88653c362fba9f10cbb2","modified":1528730445109},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1528730445119},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1528730445120},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1528730445121},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1528730445121},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1528730445124},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1528730445123},{"_id":"themes/melody/.git/objects/2c/ba9dccf28dddad1effeb8af0ba0726bf46df36","hash":"171d17baaeb9d84fd5e880b36c729da1c8784aa0","modified":1528730410000},{"_id":"themes/melody/.git/logs/refs/remotes/origin/moke","hash":"0e218c0dfd33772fcea44156ec5dada2a3e79e0c","modified":1527748626173},{"_id":"themes/melody/.git/logs/refs/remotes/origin/HEAD","hash":"06448caa5844a778e7a16fa88022943bbbce4c8e","modified":1527747826383},{"_id":"themes/melody/.git/objects/pack/pack-9057a617059a73ace91b451aac3acbe584571538.pack","hash":"b2a4dee01208e0e065bc108391d026320d0b74f6","modified":1527748599000},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1528730445119},{"_id":"public/categories/index.html","hash":"e92327947898a0e86d5828819b83cd469535b3c3","modified":1530200327362},{"_id":"public/tags/index.html","hash":"398fadb427f79f09c1758cb5f7e1003d57b69daa","modified":1530200327362},{"_id":"public/2018/06/20/data-in-vue-component-is-function/index.html","hash":"b5fb80900df9d7ad169758815e393be78a38e710","modified":1530200327363},{"_id":"public/2018/06/18/scroll-bar/index.html","hash":"ebb6532bd5639898982ebcdc56b8f92f12ea1c04","modified":1530200327363},{"_id":"public/2018/06/17/abstract-syntax-tree/index.html","hash":"a52fb20e15592561322d472141deb89d6d8c2381","modified":1530200327363},{"_id":"public/categories/CSS/index.html","hash":"fdfefc7f52f9df750657f3f7eff3458eb17d6032","modified":1530200327363},{"_id":"public/categories/优化/index.html","hash":"9f4b1f17f067b3b9a32a03fdc893fe6e0322784a","modified":1530200327363},{"_id":"public/archives/index.html","hash":"3118387c4c2f9393fe8afdc807824582c0d63d1e","modified":1530200327363},{"_id":"public/archives/2017/index.html","hash":"a2866e6064d14564654f90175a357976433f379c","modified":1530200327363},{"_id":"public/archives/2017/11/index.html","hash":"23420c0774e374d2f14eddf910a085eff5ed3d11","modified":1530200327363},{"_id":"public/archives/2018/index.html","hash":"f5ed58548d574ede1a633b02d69fb17d5b541f24","modified":1530200327363},{"_id":"public/archives/2018/06/index.html","hash":"4f25d6a224c90ff74e44d6080980eab798679d65","modified":1530200327363},{"_id":"public/tags/CSS/index.html","hash":"97991b34e3bf8a617200ee4be9ee1f980974928e","modified":1530200327364},{"_id":"public/tags/Vue/index.html","hash":"538d68af187ec5d7aa793ccae11a7303924f0fb2","modified":1530200327364},{"_id":"public/tags/优化/index.html","hash":"81aa430625516c0dbd14a7d6e403da256844ab9b","modified":1530200327364},{"_id":"public/2018/06/22/javascript-memory-management/index.html","hash":"d964b5703a80cc5d55f5eb5130d7943fa6227c8e","modified":1530200327364},{"_id":"public/2018/06/17/module/index.html","hash":"44ad443a6b23ee54edb8da608ba89d8d8a4f289d","modified":1530200327364},{"_id":"public/2018/06/13/js-async/index.html","hash":"b4aa72f78e6bb4b7ec1617d506d5c6ea08fc7eaa","modified":1530200327364},{"_id":"public/2018/06/11/this/index.html","hash":"ee9b82c34c3151e71448622890c34349fac32059","modified":1530200327364},{"_id":"public/2017/11/20/flex/index.html","hash":"fb8a81d78e89a231a162f7d2e0142663a0f2325a","modified":1530200327364},{"_id":"public/index.html","hash":"c56b8c85d44d1401aa8c1ef4dbebb92481ca58de","modified":1530200327364},{"_id":"public/tags/JavaScript/index.html","hash":"4a963d30c6221422b9401ff897f638d783f64efa","modified":1530200327377},{"_id":"public/categories/JavaScript/index.html","hash":"8ff877ff9665cb9a1228ee6403fbb029364e67c7","modified":1530200327377},{"_id":"public/2018/06/28/debounce-and-throttle/index.html","hash":"73972ff941563f2c33e457ea9cba3b4f69589919","modified":1530200327378},{"_id":"public/CNAME","hash":"3c8904c974d7c04ec49f3abd1dc4b56b9b24ca44","modified":1530200327378},{"_id":"public/favicon.ico","hash":"822401324009c49021e6feea57b882278897942a","modified":1530200327378},{"_id":"public/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1530200327379},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1530200327379},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530200328943},{"_id":"public/js/copy.js","hash":"cfae08721664d19cf0059172b994c0a2e253d334","modified":1530200328944},{"_id":"public/js/fancybox.js","hash":"0c2c506559129a5108893cf054b9aa46fe878fc3","modified":1530200328949},{"_id":"public/js/fireworks.js","hash":"5e3da1344966d5d6328a410cad69e92297699f3b","modified":1530200328950},{"_id":"public/js/head.js","hash":"212a32f824cadea0167bf4204c9714df5b7e5f5d","modified":1530200328950},{"_id":"public/js/scroll.js","hash":"73d57e7cf9921ba5724ad48b8d0e8b25dbce059f","modified":1530200328950},{"_id":"public/js/sidebar.js","hash":"185790b0d811fd7eeb96f78b1b1195dd71df1da6","modified":1530200328950},{"_id":"public/js/transition.js","hash":"998c3bb6523a248d4dd4d747510c03a914a6378d","modified":1530200328950},{"_id":"public/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1530200328950},{"_id":"public/js/search/algolia.js","hash":"884ecf62fe22cb869bbb7968ee770c1a699f591d","modified":1530200328950},{"_id":"public/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1530200328950},{"_id":"public/js/search/local-search.js","hash":"951bbc3fe459a448d5a3e555ad84225272d91071","modified":1530200328950},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530200328950},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1530200328950},{"_id":"public/js/third-party/reveal/head.min.js","hash":"95c9de30444117adbbb3218070fda00af187a76a","modified":1530200328951},{"_id":"public/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1530200328951},{"_id":"public/css/index.css","hash":"8c74bcf0c68f8a431878fdea07806cf7f1b8fd94","modified":1530200328951},{"_id":"public/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1530200328951},{"_id":"public/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1530200328951},{"_id":"public/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1530200328957},{"_id":"public/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1530200328957},{"_id":"public/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1530200328958},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1530200328959},{"_id":"public/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1530200328959},{"_id":"public/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1530200328959},{"_id":"public/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1530200328959}],"Category":[{"name":"JavaScript","_id":"cjiyprk0d0004evfydauhy2sg"},{"name":"CSS","_id":"cjiyprk0m0009evfy6ofu163t"},{"name":"优化","_id":"cjiyprk14000pevfyf9r6rq6n"}],"Data":[{"_id":"melody","data":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}],"Page":[{"title":"分类","date":"2017-09-11T02:53:14.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-09-11 10:53:14\ntype: \"categories\"\n---\n","updated":"2018-06-11T13:01:38.231Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjiyprk020001evfylhv8vk59","content":"","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":""},{"title":"标签","date":"2017-09-11T02:51:01.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-09-11 10:51:01\ntype: \"tags\"\n---\n","updated":"2018-06-11T13:01:38.236Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjiyprk090003evfy7cl31vuw","content":"","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":""}],"Post":[{"title":"debounce and throttle","date":"2018-06-28T15:19:56.000Z","_content":"\ndebounce，在项目中其实使用的频率挺高的，但是一直没有彻底理解应用场景和原理，这次就做一次简单的总结。\n\n函数防抖与节流是很相似的概念，但是他们的应用场景不太一样。\n\n我们先从概念上深刻理解它们。\n\n## 先说函数防抖，debounce。\n\n其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。\n\n单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成 JS 就是，事件内的N个动作会变忽略，只有事件后`由程序触发`的动作只是有效。\n\n实现思路如下，将目标方法（动作）包装在 setTimeout 里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个 clearTimeout，这样 setTimeout 里的方法就不会执行！ 为什么要 clearTimeout 呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么 setTimeout 就自然会执行这个方法。\n\n那么这个方法用在什么地方呢，就是用于 input 输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔 170ms 才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔 350ms。\n\n> 简单实现\n\n```js\nfunction debounce(func, delay) {\n    let timeout\n    return function(e) {\n        console.log(\"清除\",timeout,e.target.value)\n        clearTimeout(timeout)\n        let context = this,\n          args = arguments\n        console.log(\"新的\", timeout, e.target.value)\n        timeout = setTimeout(function(){\n          console.log(\"----\")\n          func.apply(context, args)\n        }, delay)\n    };\n};\n\nlet validate = debounce(function(e) {\n    console.log(\"change\", e.target.value, new Date-0)\n}, 380)\n\n// 绑定监听\ndocument.querySelector(\"input\").addEventListener('input', validate)\n```\n\n这个保证了正常的用户每输入1，2个字符就能触发一次。如果用户是输入法狂魔，也可以狠制他每输入3～6个字符触发一次。\n\n这个方法的重点是，它在用户不触发事件的时，才触发动作，并且抑制了本来在事件中要执行的动作。\n\n其他应用场合：提交按钮的点击事件。\n\n## 再看节流，throttle。\n\n节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是debounce了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。\n\n```js\nfunction throttle(fn, threshhold) {\n let timeout\n let start = new Date;\n let threshhold = threshhold || 160\n return function () {\n let context = this,\n  args = arguments,\n  curr = new Date() - 0\n\n clearTimeout(timeout)  //总是干掉事件回调\n if (curr - start >= threshhold) {\n     console.log(\"now\", curr, curr - start) //注意这里相减的结果，都差不多是160左右\n     fn.apply(context, args) //只执行一部分方法，这些方法是在某个时间段内执行一次\n     start = curr\n } else {\n // 让方法在脱离事件后也能执行一次\n     timeout = setTimeout(function(){\n        fn.apply(context, args)\n     }, threshhold)\n    }\n  }\n}\nlet mousemove = throttle(function(e) {\n console.log(e.pageX, e.pageY)\n})\n\n// 绑定监听\ndocument.querySelector(\"#panel\").addEventListener('mousemove', mousemove)\n```\n\n函数节流会用在比 input, keyup 更频繁触发的事件中，如resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。\n\n> \b函数抖动和节流视图\n\n![debounce-and-throttle-2018628233717](https://static.skynian.cn/debounce-and-throttle-2018628233717.png)\n","source":"_posts/debounce-and-throttle.md","raw":"---\ntitle: debounce and throttle\ndate: 2018-06-28 23:19:56\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\ndebounce，在项目中其实使用的频率挺高的，但是一直没有彻底理解应用场景和原理，这次就做一次简单的总结。\n\n函数防抖与节流是很相似的概念，但是他们的应用场景不太一样。\n\n我们先从概念上深刻理解它们。\n\n## 先说函数防抖，debounce。\n\n其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。\n\n单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成 JS 就是，事件内的N个动作会变忽略，只有事件后`由程序触发`的动作只是有效。\n\n实现思路如下，将目标方法（动作）包装在 setTimeout 里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个 clearTimeout，这样 setTimeout 里的方法就不会执行！ 为什么要 clearTimeout 呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么 setTimeout 就自然会执行这个方法。\n\n那么这个方法用在什么地方呢，就是用于 input 输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔 170ms 才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔 350ms。\n\n> 简单实现\n\n```js\nfunction debounce(func, delay) {\n    let timeout\n    return function(e) {\n        console.log(\"清除\",timeout,e.target.value)\n        clearTimeout(timeout)\n        let context = this,\n          args = arguments\n        console.log(\"新的\", timeout, e.target.value)\n        timeout = setTimeout(function(){\n          console.log(\"----\")\n          func.apply(context, args)\n        }, delay)\n    };\n};\n\nlet validate = debounce(function(e) {\n    console.log(\"change\", e.target.value, new Date-0)\n}, 380)\n\n// 绑定监听\ndocument.querySelector(\"input\").addEventListener('input', validate)\n```\n\n这个保证了正常的用户每输入1，2个字符就能触发一次。如果用户是输入法狂魔，也可以狠制他每输入3～6个字符触发一次。\n\n这个方法的重点是，它在用户不触发事件的时，才触发动作，并且抑制了本来在事件中要执行的动作。\n\n其他应用场合：提交按钮的点击事件。\n\n## 再看节流，throttle。\n\n节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是debounce了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。\n\n```js\nfunction throttle(fn, threshhold) {\n let timeout\n let start = new Date;\n let threshhold = threshhold || 160\n return function () {\n let context = this,\n  args = arguments,\n  curr = new Date() - 0\n\n clearTimeout(timeout)  //总是干掉事件回调\n if (curr - start >= threshhold) {\n     console.log(\"now\", curr, curr - start) //注意这里相减的结果，都差不多是160左右\n     fn.apply(context, args) //只执行一部分方法，这些方法是在某个时间段内执行一次\n     start = curr\n } else {\n // 让方法在脱离事件后也能执行一次\n     timeout = setTimeout(function(){\n        fn.apply(context, args)\n     }, threshhold)\n    }\n  }\n}\nlet mousemove = throttle(function(e) {\n console.log(e.pageX, e.pageY)\n})\n\n// 绑定监听\ndocument.querySelector(\"#panel\").addEventListener('mousemove', mousemove)\n```\n\n函数节流会用在比 input, keyup 更频繁触发的事件中，如resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。\n\n> \b函数抖动和节流视图\n\n![debounce-and-throttle-2018628233717](https://static.skynian.cn/debounce-and-throttle-2018628233717.png)\n","slug":"debounce-and-throttle","published":1,"updated":"2018-06-28T15:37:40.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprjzy0000evfyxa1tg10s","content":"<p>debounce，在项目中其实使用的频率挺高的，但是一直没有彻底理解应用场景和原理，这次就做一次简单的总结。</p>\n<p>函数防抖与节流是很相似的概念，但是他们的应用场景不太一样。</p>\n<p>我们先从概念上深刻理解它们。</p>\n<h2 id=\"先说函数防抖，debounce。\"><a href=\"#先说函数防抖，debounce。\" class=\"headerlink\" title=\"先说函数防抖，debounce。\"></a>先说函数防抖，debounce。</h2><p>其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。</p>\n<p>单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成 JS 就是，事件内的N个动作会变忽略，只有事件后<code>由程序触发</code>的动作只是有效。</p>\n<p>实现思路如下，将目标方法（动作）包装在 setTimeout 里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个 clearTimeout，这样 setTimeout 里的方法就不会执行！ 为什么要 clearTimeout 呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么 setTimeout 就自然会执行这个方法。</p>\n<p>那么这个方法用在什么地方呢，就是用于 input 输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔 170ms 才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔 350ms。</p>\n<blockquote>\n<p>简单实现</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeout</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"清除\"</span>,timeout,e.target.value)</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">          args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"新的\"</span>, timeout, e.target.value)</span><br><span class=\"line\">        timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"----\"</span>)</span><br><span class=\"line\">          func.apply(context, args)</span><br><span class=\"line\">        &#125;, delay)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> validate = debounce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"change\"</span>, e.target.value, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span><span class=\"number\">-0</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">380</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"input\"</span>).addEventListener(<span class=\"string\">'input'</span>, validate)</span><br></pre></td></tr></table></figure>\n<p>这个保证了正常的用户每输入1，2个字符就能触发一次。如果用户是输入法狂魔，也可以狠制他每输入3～6个字符触发一次。</p>\n<p>这个方法的重点是，它在用户不触发事件的时，才触发动作，并且抑制了本来在事件中要执行的动作。</p>\n<p>其他应用场合：提交按钮的点击事件。</p>\n<h2 id=\"再看节流，throttle。\"><a href=\"#再看节流，throttle。\" class=\"headerlink\" title=\"再看节流，throttle。\"></a>再看节流，throttle。</h2><p>节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是debounce了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, threshhold</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> timeout</span><br><span class=\"line\"> <span class=\"keyword\">let</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> threshhold = threshhold || <span class=\"number\">160</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">  args = <span class=\"built_in\">arguments</span>,</span><br><span class=\"line\">  curr = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> clearTimeout(timeout)  <span class=\"comment\">//总是干掉事件回调</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (curr - start &gt;= threshhold) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">\"now\"</span>, curr, curr - start) <span class=\"comment\">//注意这里相减的结果，都差不多是160左右</span></span><br><span class=\"line\">     fn.apply(context, args) <span class=\"comment\">//只执行一部分方法，这些方法是在某个时间段内执行一次</span></span><br><span class=\"line\">     start = curr</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 让方法在脱离事件后也能执行一次</span></span><br><span class=\"line\">     timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        fn.apply(context, args)</span><br><span class=\"line\">     &#125;, threshhold)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mousemove = throttle(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(e.pageX, e.pageY)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#panel\"</span>).addEventListener(<span class=\"string\">'mousemove'</span>, mousemove)</span><br></pre></td></tr></table></figure>\n<p>函数节流会用在比 input, keyup 更频繁触发的事件中，如resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。</p>\n<blockquote>\n<p>\b函数抖动和节流视图</p>\n</blockquote>\n<p><img src=\"https://static.skynian.cn/debounce-and-throttle-2018628233717.png\" alt=\"debounce-and-throttle-2018628233717\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>debounce，在项目中其实使用的频率挺高的，但是一直没有彻底理解应用场景和原理，这次就做一次简单的总结。</p>\n<p>函数防抖与节流是很相似的概念，但是他们的应用场景不太一样。</p>\n<p>我们先从概念上深刻理解它们。</p>\n<h2 id=\"先说函数防抖，debounce。\"><a href=\"#先说函数防抖，debounce。\" class=\"headerlink\" title=\"先说函数防抖，debounce。\"></a>先说函数防抖，debounce。</h2><p>其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。</p>\n<p>单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成 JS 就是，事件内的N个动作会变忽略，只有事件后<code>由程序触发</code>的动作只是有效。</p>\n<p>实现思路如下，将目标方法（动作）包装在 setTimeout 里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个 clearTimeout，这样 setTimeout 里的方法就不会执行！ 为什么要 clearTimeout 呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么 setTimeout 就自然会执行这个方法。</p>\n<p>那么这个方法用在什么地方呢，就是用于 input 输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔 170ms 才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔 350ms。</p>\n<blockquote>\n<p>简单实现</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeout</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"清除\"</span>,timeout,e.target.value)</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">          args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"新的\"</span>, timeout, e.target.value)</span><br><span class=\"line\">        timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"----\"</span>)</span><br><span class=\"line\">          func.apply(context, args)</span><br><span class=\"line\">        &#125;, delay)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> validate = debounce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"change\"</span>, e.target.value, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span><span class=\"number\">-0</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">380</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"input\"</span>).addEventListener(<span class=\"string\">'input'</span>, validate)</span><br></pre></td></tr></table></figure>\n<p>这个保证了正常的用户每输入1，2个字符就能触发一次。如果用户是输入法狂魔，也可以狠制他每输入3～6个字符触发一次。</p>\n<p>这个方法的重点是，它在用户不触发事件的时，才触发动作，并且抑制了本来在事件中要执行的动作。</p>\n<p>其他应用场合：提交按钮的点击事件。</p>\n<h2 id=\"再看节流，throttle。\"><a href=\"#再看节流，throttle。\" class=\"headerlink\" title=\"再看节流，throttle。\"></a>再看节流，throttle。</h2><p>节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是debounce了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, threshhold</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> timeout</span><br><span class=\"line\"> <span class=\"keyword\">let</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> threshhold = threshhold || <span class=\"number\">160</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">  args = <span class=\"built_in\">arguments</span>,</span><br><span class=\"line\">  curr = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> clearTimeout(timeout)  <span class=\"comment\">//总是干掉事件回调</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (curr - start &gt;= threshhold) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">\"now\"</span>, curr, curr - start) <span class=\"comment\">//注意这里相减的结果，都差不多是160左右</span></span><br><span class=\"line\">     fn.apply(context, args) <span class=\"comment\">//只执行一部分方法，这些方法是在某个时间段内执行一次</span></span><br><span class=\"line\">     start = curr</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 让方法在脱离事件后也能执行一次</span></span><br><span class=\"line\">     timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        fn.apply(context, args)</span><br><span class=\"line\">     &#125;, threshhold)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mousemove = throttle(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(e.pageX, e.pageY)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#panel\"</span>).addEventListener(<span class=\"string\">'mousemove'</span>, mousemove)</span><br></pre></td></tr></table></figure>\n<p>函数节流会用在比 input, keyup 更频繁触发的事件中，如resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。</p>\n<blockquote>\n<p>\b函数抖动和节流视图</p>\n</blockquote>\n<p><img src=\"https://static.skynian.cn/debounce-and-throttle-2018628233717.png\" alt=\"debounce-and-throttle-2018628233717\"></p>\n"},{"title":"浅谈Flex布局","date":"2017-11-20T07:24:44.000Z","_content":"\n![](https://static.skynian.cn/flex-2018613142131.png)\n\n布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n\n2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n\n<!--more-->\n\n这次笔者简单谈谈 flexbox 中的 5 个常见的属性\n\n## 属性 1：Display:Flex\n\n以下是实例页面：\n\n![](https://static.skynian.cn/flex-2018531202637.gif)\n\n\n我们可以看到，在灰色的容器中，包含了4种不同颜色与大小的 div 元素，每个元素都默认 display:block ，因此每个立方体都占据了一行的整个宽度。\n\n为了开始使用 Flexbox 布局，需要把容器变成 Flex 容器\n\n```css\n#container {\n  display: flex;\n  display: -webkit-flex; // 兼容性写法\n}\n```\n\n![](https://static.skynian.cn/flex-2018531204333.gif)\n\n## 属性 2：Flex Direction\n\nFlexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：\n\n![](https://static.skynian.cn/flex-2018531204418.gif)\n\n**项目默认是由主轴（从左到右）排列的**，这就是你使用 display:flex 后，四方体以水平线排列的原因\n\n而 Flex-direction 决定了主轴的方向\n\n```css\n#container {\n  display: flex;\n  flex-direction: column;\n}\n```\n\n![](https://static.skynian.cn/flex-2018531204454.gif)\n\n**这里有一个重要的区别：** flex-direction:column\n\n**所指的是四方体将沿主轴的垂直方向对齐，它使主轴自身从水平到垂直**\n\n而 flex-direction 还有一些其他的值供你选择，例如：row-reverse 与 column-reverse\n\n![](https://static.skynian.cn/flex-2018531204544.gif)\n\n## 属性 3：Justify Content\n\njustify-content 属性定义了项目在主轴上的对齐方式。\n\n在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到 flex-direction:row 值上\n\n```css\n#container {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n}\n```\n\njustify-content 属性包含了 5 个值供你使用\n\n```\nFlex-start\n\nFlex-end\n\nCenter\n\nSpace-between\n\nSpace-around\n```\n\n![](https://static.skynian.cn/flex-2018531204619.gif)\n\nSpace-around 与 Space-between 是两个不容易直观理解的值。Space-between 实现了两端对齐，而四方体之间的间隔都是相等的。\nSpace-around 使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）\n\n最后一点：请记住 justify-content 沿主轴对齐，而 flex-direction 决定了主轴的方向。它将决定你移动的方向。\n\n## 属性 4：Align Items\n\n当你理解了 justify-content 属性，理解 Align Items 属性就变得轻而易举了。\n\njustify-content 定义了项目在主轴的对齐方式，而 align-items 属性则定义了项目在交叉轴上是如何对齐的。\n\n![](https://static.skynian.cn/flex-2018531204650.gif)\n\n当我们将 flex-direction 属性值重置为 row 后，我们的轴看上去就与上图一致。那么，让我们深入的了解下 Align Items 属性有哪些值：\n\n```\nflex-start\n\nflex-end\n\ncenter\n\nstretch\n\nbaseline\n```\n\n前三个值与 justify-content 属性中的值完全一致，没有太多需要解释的地方。\n\n但是，接下来两个值却有些不同。\n\nStretch 指的是如果项目未设置高度或设为 auto，项目将占满整个容器。而 baseline 是指项目将与段落标签的底部对齐。\n\n![](https://static.skynian.cn/flex-2018531204725.gif)\n\n（请注意，对于 align-items：stretch，我不得不将四方体的高度设置为 auto，否则 height 属性将覆盖该 stretch）\n\n对于 baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：\n\n![](https://static.skynian.cn/flex-2018531204754.gif)\n\n为了更好地演示主轴和交叉轴的表现，在基于 justify-content 属性和 align-items 属性的值为 center 的情况下，让我们看看赋予 flex-direction 属性两个不同值后，它的表现如何：\n\n我们可以看到，对于 row 值，四方体沿着与主轴水平方向排列，而对于 column 值，它们则沿着与主轴垂直的方向排列。\n\n![](https://static.skynian.cn/flex-2018531204835.gif)\n\n## 属性 5：Align Self\n\nalign-self 属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖 align-items 属性。虽然它的默认值为 auto，但它继承了父元素 align-items 的属性。除了 auto 外，其他都与 align-items 属性完全一致。\n\n```css\n#container {\n  align-items: flex-start;\n}\n.square#one {\n  align-self: center;\n}\n```\n\n我们将在四个四方体上应用 align-self 属性，而其余的四方体则应用 align-items:center 与 flex-direction:row，让我们看看会发生什么\n\n![](https://static.skynian.cn/flex-2018531204920.gif)\n\n## 结论\n\n虽然我们只是仅仅了解了 Flexbox 的一些浅层的用法，但是已足够入门\n","source":"_posts/flex.md","raw":"---\ntitle: 浅谈Flex布局\ndate: 2017-11-20 15:24:44\ntags:\n\t- CSS\ncategories: CSS\n---\n\n![](https://static.skynian.cn/flex-2018613142131.png)\n\n布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n\n2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n\n<!--more-->\n\n这次笔者简单谈谈 flexbox 中的 5 个常见的属性\n\n## 属性 1：Display:Flex\n\n以下是实例页面：\n\n![](https://static.skynian.cn/flex-2018531202637.gif)\n\n\n我们可以看到，在灰色的容器中，包含了4种不同颜色与大小的 div 元素，每个元素都默认 display:block ，因此每个立方体都占据了一行的整个宽度。\n\n为了开始使用 Flexbox 布局，需要把容器变成 Flex 容器\n\n```css\n#container {\n  display: flex;\n  display: -webkit-flex; // 兼容性写法\n}\n```\n\n![](https://static.skynian.cn/flex-2018531204333.gif)\n\n## 属性 2：Flex Direction\n\nFlexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：\n\n![](https://static.skynian.cn/flex-2018531204418.gif)\n\n**项目默认是由主轴（从左到右）排列的**，这就是你使用 display:flex 后，四方体以水平线排列的原因\n\n而 Flex-direction 决定了主轴的方向\n\n```css\n#container {\n  display: flex;\n  flex-direction: column;\n}\n```\n\n![](https://static.skynian.cn/flex-2018531204454.gif)\n\n**这里有一个重要的区别：** flex-direction:column\n\n**所指的是四方体将沿主轴的垂直方向对齐，它使主轴自身从水平到垂直**\n\n而 flex-direction 还有一些其他的值供你选择，例如：row-reverse 与 column-reverse\n\n![](https://static.skynian.cn/flex-2018531204544.gif)\n\n## 属性 3：Justify Content\n\njustify-content 属性定义了项目在主轴上的对齐方式。\n\n在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到 flex-direction:row 值上\n\n```css\n#container {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n}\n```\n\njustify-content 属性包含了 5 个值供你使用\n\n```\nFlex-start\n\nFlex-end\n\nCenter\n\nSpace-between\n\nSpace-around\n```\n\n![](https://static.skynian.cn/flex-2018531204619.gif)\n\nSpace-around 与 Space-between 是两个不容易直观理解的值。Space-between 实现了两端对齐，而四方体之间的间隔都是相等的。\nSpace-around 使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）\n\n最后一点：请记住 justify-content 沿主轴对齐，而 flex-direction 决定了主轴的方向。它将决定你移动的方向。\n\n## 属性 4：Align Items\n\n当你理解了 justify-content 属性，理解 Align Items 属性就变得轻而易举了。\n\njustify-content 定义了项目在主轴的对齐方式，而 align-items 属性则定义了项目在交叉轴上是如何对齐的。\n\n![](https://static.skynian.cn/flex-2018531204650.gif)\n\n当我们将 flex-direction 属性值重置为 row 后，我们的轴看上去就与上图一致。那么，让我们深入的了解下 Align Items 属性有哪些值：\n\n```\nflex-start\n\nflex-end\n\ncenter\n\nstretch\n\nbaseline\n```\n\n前三个值与 justify-content 属性中的值完全一致，没有太多需要解释的地方。\n\n但是，接下来两个值却有些不同。\n\nStretch 指的是如果项目未设置高度或设为 auto，项目将占满整个容器。而 baseline 是指项目将与段落标签的底部对齐。\n\n![](https://static.skynian.cn/flex-2018531204725.gif)\n\n（请注意，对于 align-items：stretch，我不得不将四方体的高度设置为 auto，否则 height 属性将覆盖该 stretch）\n\n对于 baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：\n\n![](https://static.skynian.cn/flex-2018531204754.gif)\n\n为了更好地演示主轴和交叉轴的表现，在基于 justify-content 属性和 align-items 属性的值为 center 的情况下，让我们看看赋予 flex-direction 属性两个不同值后，它的表现如何：\n\n我们可以看到，对于 row 值，四方体沿着与主轴水平方向排列，而对于 column 值，它们则沿着与主轴垂直的方向排列。\n\n![](https://static.skynian.cn/flex-2018531204835.gif)\n\n## 属性 5：Align Self\n\nalign-self 属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖 align-items 属性。虽然它的默认值为 auto，但它继承了父元素 align-items 的属性。除了 auto 外，其他都与 align-items 属性完全一致。\n\n```css\n#container {\n  align-items: flex-start;\n}\n.square#one {\n  align-self: center;\n}\n```\n\n我们将在四个四方体上应用 align-self 属性，而其余的四方体则应用 align-items:center 与 flex-direction:row，让我们看看会发生什么\n\n![](https://static.skynian.cn/flex-2018531204920.gif)\n\n## 结论\n\n虽然我们只是仅仅了解了 Flexbox 的一些浅层的用法，但是已足够入门\n","slug":"flex","published":1,"updated":"2018-06-13T06:28:27.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprk040002evfytdq0sh41","content":"<p><img src=\"https://static.skynian.cn/flex-2018613142131.png\" alt=\"\"></p>\n<p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>\n<a id=\"more\"></a>\n<p>这次笔者简单谈谈 flexbox 中的 5 个常见的属性</p>\n<h2 id=\"属性-1：Display-Flex\"><a href=\"#属性-1：Display-Flex\" class=\"headerlink\" title=\"属性 1：Display:Flex\"></a>属性 1：Display:Flex</h2><p>以下是实例页面：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531202637.gif\" alt=\"\"></p>\n<p>我们可以看到，在灰色的容器中，包含了4种不同颜色与大小的 div 元素，每个元素都默认 display:block ，因此每个立方体都占据了一行的整个宽度。</p>\n<p>为了开始使用 Flexbox 布局，需要把容器变成 Flex 容器</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  display: -webkit-flex; // 兼容性写法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204333.gif\" alt=\"\"></p>\n<h2 id=\"属性-2：Flex-Direction\"><a href=\"#属性-2：Flex-Direction\" class=\"headerlink\" title=\"属性 2：Flex Direction\"></a>属性 2：Flex Direction</h2><p>Flexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204418.gif\" alt=\"\"></p>\n<p><strong>项目默认是由主轴（从左到右）排列的</strong>，这就是你使用 display:flex 后，四方体以水平线排列的原因</p>\n<p>而 Flex-direction 决定了主轴的方向</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: column;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204454.gif\" alt=\"\"></p>\n<p><strong>这里有一个重要的区别：</strong> flex-direction:column</p>\n<p><strong>所指的是四方体将沿主轴的垂直方向对齐，它使主轴自身从水平到垂直</strong></p>\n<p>而 flex-direction 还有一些其他的值供你选择，例如：row-reverse 与 column-reverse</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204544.gif\" alt=\"\"></p>\n<h2 id=\"属性-3：Justify-Content\"><a href=\"#属性-3：Justify-Content\" class=\"headerlink\" title=\"属性 3：Justify Content\"></a>属性 3：Justify Content</h2><p>justify-content 属性定义了项目在主轴上的对齐方式。</p>\n<p>在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到 flex-direction:row 值上</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>justify-content 属性包含了 5 个值供你使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flex-start</span><br><span class=\"line\"></span><br><span class=\"line\">Flex-end</span><br><span class=\"line\"></span><br><span class=\"line\">Center</span><br><span class=\"line\"></span><br><span class=\"line\">Space-between</span><br><span class=\"line\"></span><br><span class=\"line\">Space-around</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204619.gif\" alt=\"\"></p>\n<p>Space-around 与 Space-between 是两个不容易直观理解的值。Space-between 实现了两端对齐，而四方体之间的间隔都是相等的。<br>Space-around 使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）</p>\n<p>最后一点：请记住 justify-content 沿主轴对齐，而 flex-direction 决定了主轴的方向。它将决定你移动的方向。</p>\n<h2 id=\"属性-4：Align-Items\"><a href=\"#属性-4：Align-Items\" class=\"headerlink\" title=\"属性 4：Align Items\"></a>属性 4：Align Items</h2><p>当你理解了 justify-content 属性，理解 Align Items 属性就变得轻而易举了。</p>\n<p>justify-content 定义了项目在主轴的对齐方式，而 align-items 属性则定义了项目在交叉轴上是如何对齐的。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204650.gif\" alt=\"\"></p>\n<p>当我们将 flex-direction 属性值重置为 row 后，我们的轴看上去就与上图一致。那么，让我们深入的了解下 Align Items 属性有哪些值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start</span><br><span class=\"line\"></span><br><span class=\"line\">flex-end</span><br><span class=\"line\"></span><br><span class=\"line\">center</span><br><span class=\"line\"></span><br><span class=\"line\">stretch</span><br><span class=\"line\"></span><br><span class=\"line\">baseline</span><br></pre></td></tr></table></figure>\n<p>前三个值与 justify-content 属性中的值完全一致，没有太多需要解释的地方。</p>\n<p>但是，接下来两个值却有些不同。</p>\n<p>Stretch 指的是如果项目未设置高度或设为 auto，项目将占满整个容器。而 baseline 是指项目将与段落标签的底部对齐。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204725.gif\" alt=\"\"></p>\n<p>（请注意，对于 align-items：stretch，我不得不将四方体的高度设置为 auto，否则 height 属性将覆盖该 stretch）</p>\n<p>对于 baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204754.gif\" alt=\"\"></p>\n<p>为了更好地演示主轴和交叉轴的表现，在基于 justify-content 属性和 align-items 属性的值为 center 的情况下，让我们看看赋予 flex-direction 属性两个不同值后，它的表现如何：</p>\n<p>我们可以看到，对于 row 值，四方体沿着与主轴水平方向排列，而对于 column 值，它们则沿着与主轴垂直的方向排列。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204835.gif\" alt=\"\"></p>\n<h2 id=\"属性-5：Align-Self\"><a href=\"#属性-5：Align-Self\" class=\"headerlink\" title=\"属性 5：Align Self\"></a>属性 5：Align Self</h2><p>align-self 属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖 align-items 属性。虽然它的默认值为 auto，但它继承了父元素 align-items 的属性。除了 auto 外，其他都与 align-items 属性完全一致。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.square</span><span class=\"selector-id\">#one</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-self</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将在四个四方体上应用 align-self 属性，而其余的四方体则应用 align-items:center 与 flex-direction:row，让我们看看会发生什么</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204920.gif\" alt=\"\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>虽然我们只是仅仅了解了 Flexbox 的一些浅层的用法，但是已足够入门</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p><img src=\"https://static.skynian.cn/flex-2018613142131.png\" alt=\"\"></p>\n<p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>","more":"<p>这次笔者简单谈谈 flexbox 中的 5 个常见的属性</p>\n<h2 id=\"属性-1：Display-Flex\"><a href=\"#属性-1：Display-Flex\" class=\"headerlink\" title=\"属性 1：Display:Flex\"></a>属性 1：Display:Flex</h2><p>以下是实例页面：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531202637.gif\" alt=\"\"></p>\n<p>我们可以看到，在灰色的容器中，包含了4种不同颜色与大小的 div 元素，每个元素都默认 display:block ，因此每个立方体都占据了一行的整个宽度。</p>\n<p>为了开始使用 Flexbox 布局，需要把容器变成 Flex 容器</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  display: -webkit-flex; // 兼容性写法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204333.gif\" alt=\"\"></p>\n<h2 id=\"属性-2：Flex-Direction\"><a href=\"#属性-2：Flex-Direction\" class=\"headerlink\" title=\"属性 2：Flex Direction\"></a>属性 2：Flex Direction</h2><p>Flexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204418.gif\" alt=\"\"></p>\n<p><strong>项目默认是由主轴（从左到右）排列的</strong>，这就是你使用 display:flex 后，四方体以水平线排列的原因</p>\n<p>而 Flex-direction 决定了主轴的方向</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: column;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204454.gif\" alt=\"\"></p>\n<p><strong>这里有一个重要的区别：</strong> flex-direction:column</p>\n<p><strong>所指的是四方体将沿主轴的垂直方向对齐，它使主轴自身从水平到垂直</strong></p>\n<p>而 flex-direction 还有一些其他的值供你选择，例如：row-reverse 与 column-reverse</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204544.gif\" alt=\"\"></p>\n<h2 id=\"属性-3：Justify-Content\"><a href=\"#属性-3：Justify-Content\" class=\"headerlink\" title=\"属性 3：Justify Content\"></a>属性 3：Justify Content</h2><p>justify-content 属性定义了项目在主轴上的对齐方式。</p>\n<p>在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到 flex-direction:row 值上</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>justify-content 属性包含了 5 个值供你使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flex-start</span><br><span class=\"line\"></span><br><span class=\"line\">Flex-end</span><br><span class=\"line\"></span><br><span class=\"line\">Center</span><br><span class=\"line\"></span><br><span class=\"line\">Space-between</span><br><span class=\"line\"></span><br><span class=\"line\">Space-around</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204619.gif\" alt=\"\"></p>\n<p>Space-around 与 Space-between 是两个不容易直观理解的值。Space-between 实现了两端对齐，而四方体之间的间隔都是相等的。<br>Space-around 使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）</p>\n<p>最后一点：请记住 justify-content 沿主轴对齐，而 flex-direction 决定了主轴的方向。它将决定你移动的方向。</p>\n<h2 id=\"属性-4：Align-Items\"><a href=\"#属性-4：Align-Items\" class=\"headerlink\" title=\"属性 4：Align Items\"></a>属性 4：Align Items</h2><p>当你理解了 justify-content 属性，理解 Align Items 属性就变得轻而易举了。</p>\n<p>justify-content 定义了项目在主轴的对齐方式，而 align-items 属性则定义了项目在交叉轴上是如何对齐的。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204650.gif\" alt=\"\"></p>\n<p>当我们将 flex-direction 属性值重置为 row 后，我们的轴看上去就与上图一致。那么，让我们深入的了解下 Align Items 属性有哪些值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start</span><br><span class=\"line\"></span><br><span class=\"line\">flex-end</span><br><span class=\"line\"></span><br><span class=\"line\">center</span><br><span class=\"line\"></span><br><span class=\"line\">stretch</span><br><span class=\"line\"></span><br><span class=\"line\">baseline</span><br></pre></td></tr></table></figure>\n<p>前三个值与 justify-content 属性中的值完全一致，没有太多需要解释的地方。</p>\n<p>但是，接下来两个值却有些不同。</p>\n<p>Stretch 指的是如果项目未设置高度或设为 auto，项目将占满整个容器。而 baseline 是指项目将与段落标签的底部对齐。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204725.gif\" alt=\"\"></p>\n<p>（请注意，对于 align-items：stretch，我不得不将四方体的高度设置为 auto，否则 height 属性将覆盖该 stretch）</p>\n<p>对于 baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204754.gif\" alt=\"\"></p>\n<p>为了更好地演示主轴和交叉轴的表现，在基于 justify-content 属性和 align-items 属性的值为 center 的情况下，让我们看看赋予 flex-direction 属性两个不同值后，它的表现如何：</p>\n<p>我们可以看到，对于 row 值，四方体沿着与主轴水平方向排列，而对于 column 值，它们则沿着与主轴垂直的方向排列。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204835.gif\" alt=\"\"></p>\n<h2 id=\"属性-5：Align-Self\"><a href=\"#属性-5：Align-Self\" class=\"headerlink\" title=\"属性 5：Align Self\"></a>属性 5：Align Self</h2><p>align-self 属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖 align-items 属性。虽然它的默认值为 auto，但它继承了父元素 align-items 的属性。除了 auto 外，其他都与 align-items 属性完全一致。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.square</span><span class=\"selector-id\">#one</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-self</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将在四个四方体上应用 align-self 属性，而其余的四方体则应用 align-items:center 与 flex-direction:row，让我们看看会发生什么</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204920.gif\" alt=\"\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>虽然我们只是仅仅了解了 Flexbox 的一些浅层的用法，但是已足够入门</p>"},{"title":"抽象语法树 Abstract syntax tree","date":"2018-06-17T08:59:17.000Z","_content":"\n因为最近在了解 Webpack、 gulp 等打包工具的相关知识，并且一个核心的概念是抽象语法树。所以就收集相关资料，当做一个简单的记录。\n\n## 什么是抽象语法树\n\n在计算机科学中，抽象语法和抽象语法树其实就是源代码的抽象语法结构的树状表现形式。\n\n我们可以通过在线的抽象语法转换器了解大概，[在线转换器](https://astexplorer.net)\n\n<!--more-->\n\n如图：\n\n![](https://static.skynian.cn/Abstract-syntax-tree-2018617171212.jpg)\n\n如上图中的变量声明语句，转化成 AST 之后就是有图的样子\n\n\b先来\b简单分析左图\n\n```\nvar 是一个关键字\n\nAST 是一个定义者\n\n= 是 Equal \b等号的叫法有很多种形式，在后面我们还会看到\n\n\"is tree\" 是一个字符串\n\n; 就是 semicoion\n```\n\n再来对应下右图，里面包含了所有的对于该语句的描述信息\n\n## 抽象语法树有哪些用途？\n\n代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码错误提示，代码自动补全等等......\n\n如：\n\nJSLint、JSHint等代码风格的检查器\n\n## 通过什么工具或者库来实现源码转化成抽象语法树？\n\n简单的来说就是， JavaScript Parset 解析器\n\n浏览器会把 JS 源码通过解析器转化成抽象语法树，再进一步转化成字节码或者直接生成机器码\n\n## 后记\n\n因为只是简单记录一些概念，所以这里篇幅比较小。\n\n后续的一些，实际应用场景，先占位，后面有时间再填......\n\n","source":"_posts/abstract-syntax-tree.md","raw":"---\ntitle: 抽象语法树 Abstract syntax tree\ndate: 2018-06-17 16:59:17\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\n因为最近在了解 Webpack、 gulp 等打包工具的相关知识，并且一个核心的概念是抽象语法树。所以就收集相关资料，当做一个简单的记录。\n\n## 什么是抽象语法树\n\n在计算机科学中，抽象语法和抽象语法树其实就是源代码的抽象语法结构的树状表现形式。\n\n我们可以通过在线的抽象语法转换器了解大概，[在线转换器](https://astexplorer.net)\n\n<!--more-->\n\n如图：\n\n![](https://static.skynian.cn/Abstract-syntax-tree-2018617171212.jpg)\n\n如上图中的变量声明语句，转化成 AST 之后就是有图的样子\n\n\b先来\b简单分析左图\n\n```\nvar 是一个关键字\n\nAST 是一个定义者\n\n= 是 Equal \b等号的叫法有很多种形式，在后面我们还会看到\n\n\"is tree\" 是一个字符串\n\n; 就是 semicoion\n```\n\n再来对应下右图，里面包含了所有的对于该语句的描述信息\n\n## 抽象语法树有哪些用途？\n\n代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码错误提示，代码自动补全等等......\n\n如：\n\nJSLint、JSHint等代码风格的检查器\n\n## 通过什么工具或者库来实现源码转化成抽象语法树？\n\n简单的来说就是， JavaScript Parset 解析器\n\n浏览器会把 JS 源码通过解析器转化成抽象语法树，再进一步转化成字节码或者直接生成机器码\n\n## 后记\n\n因为只是简单记录一些概念，所以这里篇幅比较小。\n\n后续的一些，实际应用场景，先占位，后面有时间再填......\n\n","slug":"abstract-syntax-tree","published":1,"updated":"2018-06-17T09:27:34.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprk0h0006evfygb2iaowl","content":"<p>因为最近在了解 Webpack、 gulp 等打包工具的相关知识，并且一个核心的概念是抽象语法树。所以就收集相关资料，当做一个简单的记录。</p>\n<h2 id=\"什么是抽象语法树\"><a href=\"#什么是抽象语法树\" class=\"headerlink\" title=\"什么是抽象语法树\"></a>什么是抽象语法树</h2><p>在计算机科学中，抽象语法和抽象语法树其实就是源代码的抽象语法结构的树状表现形式。</p>\n<p>我们可以通过在线的抽象语法转换器了解大概，<a href=\"https://astexplorer.net\" target=\"_blank\" rel=\"noopener\">在线转换器</a></p>\n<a id=\"more\"></a>\n<p>如图：</p>\n<p><img src=\"https://static.skynian.cn/Abstract-syntax-tree-2018617171212.jpg\" alt=\"\"></p>\n<p>如上图中的变量声明语句，转化成 AST 之后就是有图的样子</p>\n<p>\b先来\b简单分析左图</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 是一个关键字</span><br><span class=\"line\"></span><br><span class=\"line\">AST 是一个定义者</span><br><span class=\"line\"></span><br><span class=\"line\">= 是 Equal \b等号的叫法有很多种形式，在后面我们还会看到</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;is tree&quot; 是一个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">; 就是 semicoion</span><br></pre></td></tr></table></figure>\n<p>再来对应下右图，里面包含了所有的对于该语句的描述信息</p>\n<h2 id=\"抽象语法树有哪些用途？\"><a href=\"#抽象语法树有哪些用途？\" class=\"headerlink\" title=\"抽象语法树有哪些用途？\"></a>抽象语法树有哪些用途？</h2><p>代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码错误提示，代码自动补全等等……</p>\n<p>如：</p>\n<p>JSLint、JSHint等代码风格的检查器</p>\n<h2 id=\"通过什么工具或者库来实现源码转化成抽象语法树？\"><a href=\"#通过什么工具或者库来实现源码转化成抽象语法树？\" class=\"headerlink\" title=\"通过什么工具或者库来实现源码转化成抽象语法树？\"></a>通过什么工具或者库来实现源码转化成抽象语法树？</h2><p>简单的来说就是， JavaScript Parset 解析器</p>\n<p>浏览器会把 JS 源码通过解析器转化成抽象语法树，再进一步转化成字节码或者直接生成机器码</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>因为只是简单记录一些概念，所以这里篇幅比较小。</p>\n<p>后续的一些，实际应用场景，先占位，后面有时间再填……</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>因为最近在了解 Webpack、 gulp 等打包工具的相关知识，并且一个核心的概念是抽象语法树。所以就收集相关资料，当做一个简单的记录。</p>\n<h2 id=\"什么是抽象语法树\"><a href=\"#什么是抽象语法树\" class=\"headerlink\" title=\"什么是抽象语法树\"></a>什么是抽象语法树</h2><p>在计算机科学中，抽象语法和抽象语法树其实就是源代码的抽象语法结构的树状表现形式。</p>\n<p>我们可以通过在线的抽象语法转换器了解大概，<a href=\"https://astexplorer.net\" target=\"_blank\" rel=\"noopener\">在线转换器</a></p>","more":"<p>如图：</p>\n<p><img src=\"https://static.skynian.cn/Abstract-syntax-tree-2018617171212.jpg\" alt=\"\"></p>\n<p>如上图中的变量声明语句，转化成 AST 之后就是有图的样子</p>\n<p>\b先来\b简单分析左图</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 是一个关键字</span><br><span class=\"line\"></span><br><span class=\"line\">AST 是一个定义者</span><br><span class=\"line\"></span><br><span class=\"line\">= 是 Equal \b等号的叫法有很多种形式，在后面我们还会看到</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;is tree&quot; 是一个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">; 就是 semicoion</span><br></pre></td></tr></table></figure>\n<p>再来对应下右图，里面包含了所有的对于该语句的描述信息</p>\n<h2 id=\"抽象语法树有哪些用途？\"><a href=\"#抽象语法树有哪些用途？\" class=\"headerlink\" title=\"抽象语法树有哪些用途？\"></a>抽象语法树有哪些用途？</h2><p>代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码错误提示，代码自动补全等等……</p>\n<p>如：</p>\n<p>JSLint、JSHint等代码风格的检查器</p>\n<h2 id=\"通过什么工具或者库来实现源码转化成抽象语法树？\"><a href=\"#通过什么工具或者库来实现源码转化成抽象语法树？\" class=\"headerlink\" title=\"通过什么工具或者库来实现源码转化成抽象语法树？\"></a>通过什么工具或者库来实现源码转化成抽象语法树？</h2><p>简单的来说就是， JavaScript Parset 解析器</p>\n<p>浏览器会把 JS 源码通过解析器转化成抽象语法树，再进一步转化成字节码或者直接生成机器码</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>因为只是简单记录一些概念，所以这里篇幅比较小。</p>\n<p>后续的一些，实际应用场景，先占位，后面有时间再填……</p>"},{"title":"为什么 Vue 组件中的 data 必须是函数","date":"2018-06-20T12:52:58.000Z","_content":"\nVue 组件化使用，能够提高开发效率，方便重复使用。\n\n组件写法还是有一点区别的，最明显的是\n\n```\n// 直接实例化\ndata: {\n  count: 0,\n},\n\n// 组价形式\ndata: function() {\n  return {\n    count: 0,\n  }\n},\n```\n\n也就是，**一个组件的 data 选项必须是一个函数**\n\nvue 官方解释：\n\n通过函数返回，因此每一个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，点击一个按钮就可能会影响到其他实例\n\n## 从原型链分析\n\n首先，Object 是引用类型，如果不用 Function 返回，每个组件的 data 都是内存的同一个地址，因此彼此之间改变会有影响\n\neg：\n\n```js\nconst MyComponent = function() {}\n\nMyComponent.prototype.data = {\n  a: 1,\n  b: 2,\n}\n\nconst component1 = new MyComponent()\nconst component2 = new MyComponent()\n\ncomponent1.data.a === component2.data.a // true\n\ncomponent1.data.b = 5\ncomponent2.data.b // 5\n```\n\n因此两个实例都应该拥有一个自己的域\n\n```js\nconst MyComponent = function() {\n  this.data = this.data()\n}\n\nMyComponent.prototype.data = function() {\n  return {\n    a: 1,\n    b: 2,\n  }\n}\n```\n\n\b我们从以上代码，可以很清晰度明白其中的原因。\n\n其实，data()，可以命名为 setData() ，这样子\b更容易让\b人理解。\n\n## 参考\n\n- [为什么在vue的组件中，data要用function返回对象呢？](https://blog.csdn.net/shaleilei/article/details/78084171)\n- [vue官网-data必须是函数](https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0)\n","source":"_posts/data-in-vue-component-is-function.md","raw":"---\ntitle: 为什么 Vue 组件中的 data 必须是函数\ndate: 2018-06-20 20:52:58\ntags:\n  - Vue\ncategories: JavaScript\n---\n\nVue 组件化使用，能够提高开发效率，方便重复使用。\n\n组件写法还是有一点区别的，最明显的是\n\n```\n// 直接实例化\ndata: {\n  count: 0,\n},\n\n// 组价形式\ndata: function() {\n  return {\n    count: 0,\n  }\n},\n```\n\n也就是，**一个组件的 data 选项必须是一个函数**\n\nvue 官方解释：\n\n通过函数返回，因此每一个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，点击一个按钮就可能会影响到其他实例\n\n## 从原型链分析\n\n首先，Object 是引用类型，如果不用 Function 返回，每个组件的 data 都是内存的同一个地址，因此彼此之间改变会有影响\n\neg：\n\n```js\nconst MyComponent = function() {}\n\nMyComponent.prototype.data = {\n  a: 1,\n  b: 2,\n}\n\nconst component1 = new MyComponent()\nconst component2 = new MyComponent()\n\ncomponent1.data.a === component2.data.a // true\n\ncomponent1.data.b = 5\ncomponent2.data.b // 5\n```\n\n因此两个实例都应该拥有一个自己的域\n\n```js\nconst MyComponent = function() {\n  this.data = this.data()\n}\n\nMyComponent.prototype.data = function() {\n  return {\n    a: 1,\n    b: 2,\n  }\n}\n```\n\n\b我们从以上代码，可以很清晰度明白其中的原因。\n\n其实，data()，可以命名为 setData() ，这样子\b更容易让\b人理解。\n\n## 参考\n\n- [为什么在vue的组件中，data要用function返回对象呢？](https://blog.csdn.net/shaleilei/article/details/78084171)\n- [vue官网-data必须是函数](https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0)\n","slug":"data-in-vue-component-is-function","published":1,"updated":"2018-06-20T13:17:46.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprk0k0007evfya6o875jo","content":"<p>Vue 组件化使用，能够提高开发效率，方便重复使用。</p>\n<p>组件写法还是有一点区别的，最明显的是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 直接实例化</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">  count: 0,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 组价形式</span><br><span class=\"line\">data: function() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    count: 0,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>也就是，<strong>一个组件的 data 选项必须是一个函数</strong></p>\n<p>vue 官方解释：</p>\n<p>通过函数返回，因此每一个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，点击一个按钮就可能会影响到其他实例</p>\n<h2 id=\"从原型链分析\"><a href=\"#从原型链分析\" class=\"headerlink\" title=\"从原型链分析\"></a>从原型链分析</h2><p>首先，Object 是引用类型，如果不用 Function 返回，每个组件的 data 都是内存的同一个地址，因此彼此之间改变会有影响</p>\n<p>eg：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.prototype.data = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> component1 = <span class=\"keyword\">new</span> MyComponent()</span><br><span class=\"line\"><span class=\"keyword\">const</span> component2 = <span class=\"keyword\">new</span> MyComponent()</span><br><span class=\"line\"></span><br><span class=\"line\">component1.data.a === component2.data.a <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">component1.data.b = <span class=\"number\">5</span></span><br><span class=\"line\">component2.data.b <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>因此两个实例都应该拥有一个自己的域</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data = <span class=\"keyword\">this</span>.data()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.prototype.data = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: <span class=\"number\">2</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>\b我们从以上代码，可以很清晰度明白其中的原因。</p>\n<p>其实，data()，可以命名为 setData() ，这样子\b更容易让\b人理解。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/shaleilei/article/details/78084171\" target=\"_blank\" rel=\"noopener\">为什么在vue的组件中，data要用function返回对象呢？</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\">vue官网-data必须是函数</a></li>\n</ul>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>Vue 组件化使用，能够提高开发效率，方便重复使用。</p>\n<p>组件写法还是有一点区别的，最明显的是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 直接实例化</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">  count: 0,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 组价形式</span><br><span class=\"line\">data: function() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    count: 0,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>也就是，<strong>一个组件的 data 选项必须是一个函数</strong></p>\n<p>vue 官方解释：</p>\n<p>通过函数返回，因此每一个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，点击一个按钮就可能会影响到其他实例</p>\n<h2 id=\"从原型链分析\"><a href=\"#从原型链分析\" class=\"headerlink\" title=\"从原型链分析\"></a>从原型链分析</h2><p>首先，Object 是引用类型，如果不用 Function 返回，每个组件的 data 都是内存的同一个地址，因此彼此之间改变会有影响</p>\n<p>eg：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.prototype.data = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> component1 = <span class=\"keyword\">new</span> MyComponent()</span><br><span class=\"line\"><span class=\"keyword\">const</span> component2 = <span class=\"keyword\">new</span> MyComponent()</span><br><span class=\"line\"></span><br><span class=\"line\">component1.data.a === component2.data.a <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">component1.data.b = <span class=\"number\">5</span></span><br><span class=\"line\">component2.data.b <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>因此两个实例都应该拥有一个自己的域</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data = <span class=\"keyword\">this</span>.data()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.prototype.data = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: <span class=\"number\">2</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>\b我们从以上代码，可以很清晰度明白其中的原因。</p>\n<p>其实，data()，可以命名为 setData() ，这样子\b更容易让\b人理解。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/shaleilei/article/details/78084171\" target=\"_blank\" rel=\"noopener\">为什么在vue的组件中，data要用function返回对象呢？</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\">vue官网-data必须是函数</a></li>\n</ul>\n"},{"title":"浅谈JavaScript异步","date":"2018-06-13T15:38:17.000Z","_content":"\n## JavaScript是单线程？\n\n- JS 引擎中负责解释和执行 JS 代码的线程只有一个（主）\n- AJAX 、处理 DOM 、定时器、读写......（工作线程）\n- 对于耗时或者时间不确定的操作，使用异步\n- HTML5 Web Worker 多线程\n\n<!--more-->\n\n## 异步执行机制\n\n1. 所有同步任务都在主线程执行，形成执行栈\n2. “任务队列”，异步任务的结果存放\n3. 同步任务执行完毕，读取“任务队列”\n4. 主线程不断重复第三步\n5. 主线程阻塞，任务队列依旧能够被推入任务\n\n## Event Loop\n\n主线程从“任务队列”中读取事件，不断循环\n\n![](https://static.skynian.cn/js-async-201861401039.jpg)\n\n## Macrotask 和 Microtask\n\n**macro-tasks：** script (整体代码)，setTimeout，setInterval，setImmediate，I/O，UI\n\n**micro-tasks：** process.nextTick，Promises，Object.observe，MutationObserver（HTML5新特性）\n\n在一个事件循环里，\n\n这两个队列会分两步执行，\n\n第一步会固定地执行一个（且仅一个）Macrotask 任务，\n\n第二步会执行整个 Microtask 队列中的所有任务。\n\n![](https://static.skynian.cn/js-async-2018614020.png)\n\n> 接下来，我们用代码来感受\n\n```js\nsetTimeout(function() {\n  console.log('timeout1')\n})\n\nnew Promise((resolve) => {\n  console.log('promise1')\n\n  for(let i = 0; i < 1000; i++) {\n    i === 99 && resolve()\n  }\n\n  console.log('promise2')\n}).then(() => {\n  console.log('then1')\n})\n\nconsole.log('glogal1')\n```\n\n答案:\n\n```cmd\npromise1\npromise2\nglobal1\nthen1\ntimeout1\n```\n\n## 在线演示\n\n[地址](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n)\n\n![](https://static.skynian.cn/js-async-20186140952.png)\n\n## 作用\n\n**Macrotasks:** 代表一些离散的独立的工作，task结束后，浏览器继续其他工作如页面重渲染和垃圾回收等\n\n**Microtasks:** 更新完成应用程序状态的较小任务，在UI重渲染之前执行某些任务，避免不必要的UI渲染\n\n## Vue 中 MutationObserver\n\n[\bhttps://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95](https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95)\n\n```js\nlet counter = 1\nlet observer = new MutationObserver(nextTickHandler)\nlet textNode = document.createTextNode(String(counter))\nobserver.observe(textNode, {\n    characterData: true\n})\ntimerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n}\n```\n\n## JS异步发展\n\n- Callback\n- Promise\n- Generator\n- Async function\n- rxjs ??\n- ......\n\n## Callback\n\n- 给匿名函数命名\n- 模块化\n- ...\n\n```js\ngetData(function(a){\n    getMoreData(a, function(b){\n        getMoreData(b, function(c){\n            getMoreData(c, function(d){\n                getMoreData(d, function(e){\n                    ...\n                })\n            })\n        })\n    })\n})\n```\n\n## Promise\n\n- 解决了异步回调函数层层嵌套\n- 错误处理以及链式回调\n\n```js\n// 没有 promise\na(getResultFromA, (aResult, err) => {\n  if (!err) {\n    b(getResultFromB, (bResult, err) => {\n      if (!err) {\n        c(getResultFromC, (cResult, err) => {\n          if (!err) {\n            // do something\n          } else {\n            throw err\n          }\n        })\n      } else {\n        throw err\n      }\n    })\n  } else {\n    throw err\n  }\n})\n\n// 用了 promise 后\nnew promise((resolve, reject) => {\n  a(getResultFromA, (aResult, err) => {\n    if (!err) resolve(aResult) else reject(err)\n  })\n})\n.then(data => {\n  return new Promise((resolve, reject) => {\n    b(getResultFromB, (bResult, err) => {\n      if (!err) resolve(bResult) else reject(err)\n    })\n  }\n})\n.then(data => {\n  return new Promise((resolve, reject) => {\n    c(getResultFromC, (cResult, err) => {\n      if (!err) resolve(cResult) else reject(err)\n    })\n  }\n})\n.then(data => {\n  // do something\n})\n.catch(err => {\n  throw err\n})\n```\n\n## Generator\n\n- \"协程\"（coroutine），意思是多个线程互相协作，完成异步任务\n- 流程管理却不方便\n\n```js\n// 定义\nvar fetch = require('node-fetch')\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github'\n  var result = yield fetch(url)\n  console.log(result.bio)\n}\n\n// 使用\nvar g = gen()\nvar result = g.next()\n\nresult.value.then(function(data){\n  return data.json()\n}).then(function(data){\n  g.next(data)\n})\n```\n\n## Async\n\n- 内置执行器\n- 更好的语义\n- 更广的适用性\n- 返回值是Promise\n\n## Rxjs(流Stream)\n\nReactive Extensions for JavaScript\n\n观察者 + 迭代器模式\n\nObservables 与 Observer\n\n**订阅：** Observer 通过 Observable 提供的 subscribe() 方法订阅Observable\n**发布：** Observable 通过回调 next 方法向 Observer 发布事件\n\n[构建流式应用—RxJS详解(AlloyTeam)](http://www.alloyteam.com/2016/12/learn-rxjs/)","source":"_posts/js-async.md","raw":"---\ntitle: 浅谈JavaScript异步\ndate: 2018-06-13 23:38:17\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\n## JavaScript是单线程？\n\n- JS 引擎中负责解释和执行 JS 代码的线程只有一个（主）\n- AJAX 、处理 DOM 、定时器、读写......（工作线程）\n- 对于耗时或者时间不确定的操作，使用异步\n- HTML5 Web Worker 多线程\n\n<!--more-->\n\n## 异步执行机制\n\n1. 所有同步任务都在主线程执行，形成执行栈\n2. “任务队列”，异步任务的结果存放\n3. 同步任务执行完毕，读取“任务队列”\n4. 主线程不断重复第三步\n5. 主线程阻塞，任务队列依旧能够被推入任务\n\n## Event Loop\n\n主线程从“任务队列”中读取事件，不断循环\n\n![](https://static.skynian.cn/js-async-201861401039.jpg)\n\n## Macrotask 和 Microtask\n\n**macro-tasks：** script (整体代码)，setTimeout，setInterval，setImmediate，I/O，UI\n\n**micro-tasks：** process.nextTick，Promises，Object.observe，MutationObserver（HTML5新特性）\n\n在一个事件循环里，\n\n这两个队列会分两步执行，\n\n第一步会固定地执行一个（且仅一个）Macrotask 任务，\n\n第二步会执行整个 Microtask 队列中的所有任务。\n\n![](https://static.skynian.cn/js-async-2018614020.png)\n\n> 接下来，我们用代码来感受\n\n```js\nsetTimeout(function() {\n  console.log('timeout1')\n})\n\nnew Promise((resolve) => {\n  console.log('promise1')\n\n  for(let i = 0; i < 1000; i++) {\n    i === 99 && resolve()\n  }\n\n  console.log('promise2')\n}).then(() => {\n  console.log('then1')\n})\n\nconsole.log('glogal1')\n```\n\n答案:\n\n```cmd\npromise1\npromise2\nglobal1\nthen1\ntimeout1\n```\n\n## 在线演示\n\n[地址](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n)\n\n![](https://static.skynian.cn/js-async-20186140952.png)\n\n## 作用\n\n**Macrotasks:** 代表一些离散的独立的工作，task结束后，浏览器继续其他工作如页面重渲染和垃圾回收等\n\n**Microtasks:** 更新完成应用程序状态的较小任务，在UI重渲染之前执行某些任务，避免不必要的UI渲染\n\n## Vue 中 MutationObserver\n\n[\bhttps://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95](https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95)\n\n```js\nlet counter = 1\nlet observer = new MutationObserver(nextTickHandler)\nlet textNode = document.createTextNode(String(counter))\nobserver.observe(textNode, {\n    characterData: true\n})\ntimerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n}\n```\n\n## JS异步发展\n\n- Callback\n- Promise\n- Generator\n- Async function\n- rxjs ??\n- ......\n\n## Callback\n\n- 给匿名函数命名\n- 模块化\n- ...\n\n```js\ngetData(function(a){\n    getMoreData(a, function(b){\n        getMoreData(b, function(c){\n            getMoreData(c, function(d){\n                getMoreData(d, function(e){\n                    ...\n                })\n            })\n        })\n    })\n})\n```\n\n## Promise\n\n- 解决了异步回调函数层层嵌套\n- 错误处理以及链式回调\n\n```js\n// 没有 promise\na(getResultFromA, (aResult, err) => {\n  if (!err) {\n    b(getResultFromB, (bResult, err) => {\n      if (!err) {\n        c(getResultFromC, (cResult, err) => {\n          if (!err) {\n            // do something\n          } else {\n            throw err\n          }\n        })\n      } else {\n        throw err\n      }\n    })\n  } else {\n    throw err\n  }\n})\n\n// 用了 promise 后\nnew promise((resolve, reject) => {\n  a(getResultFromA, (aResult, err) => {\n    if (!err) resolve(aResult) else reject(err)\n  })\n})\n.then(data => {\n  return new Promise((resolve, reject) => {\n    b(getResultFromB, (bResult, err) => {\n      if (!err) resolve(bResult) else reject(err)\n    })\n  }\n})\n.then(data => {\n  return new Promise((resolve, reject) => {\n    c(getResultFromC, (cResult, err) => {\n      if (!err) resolve(cResult) else reject(err)\n    })\n  }\n})\n.then(data => {\n  // do something\n})\n.catch(err => {\n  throw err\n})\n```\n\n## Generator\n\n- \"协程\"（coroutine），意思是多个线程互相协作，完成异步任务\n- 流程管理却不方便\n\n```js\n// 定义\nvar fetch = require('node-fetch')\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github'\n  var result = yield fetch(url)\n  console.log(result.bio)\n}\n\n// 使用\nvar g = gen()\nvar result = g.next()\n\nresult.value.then(function(data){\n  return data.json()\n}).then(function(data){\n  g.next(data)\n})\n```\n\n## Async\n\n- 内置执行器\n- 更好的语义\n- 更广的适用性\n- 返回值是Promise\n\n## Rxjs(流Stream)\n\nReactive Extensions for JavaScript\n\n观察者 + 迭代器模式\n\nObservables 与 Observer\n\n**订阅：** Observer 通过 Observable 提供的 subscribe() 方法订阅Observable\n**发布：** Observable 通过回调 next 方法向 Observer 发布事件\n\n[构建流式应用—RxJS详解(AlloyTeam)](http://www.alloyteam.com/2016/12/learn-rxjs/)","slug":"js-async","published":1,"updated":"2018-06-13T16:23:48.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprk0l0008evfyfyrauy41","content":"<h2 id=\"JavaScript是单线程？\"><a href=\"#JavaScript是单线程？\" class=\"headerlink\" title=\"JavaScript是单线程？\"></a>JavaScript是单线程？</h2><ul>\n<li>JS 引擎中负责解释和执行 JS 代码的线程只有一个（主）</li>\n<li>AJAX 、处理 DOM 、定时器、读写……（工作线程）</li>\n<li>对于耗时或者时间不确定的操作，使用异步</li>\n<li>HTML5 Web Worker 多线程</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"异步执行机制\"><a href=\"#异步执行机制\" class=\"headerlink\" title=\"异步执行机制\"></a>异步执行机制</h2><ol>\n<li>所有同步任务都在主线程执行，形成执行栈</li>\n<li>“任务队列”，异步任务的结果存放</li>\n<li>同步任务执行完毕，读取“任务队列”</li>\n<li>主线程不断重复第三步</li>\n<li>主线程阻塞，任务队列依旧能够被推入任务</li>\n</ol>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>主线程从“任务队列”中读取事件，不断循环</p>\n<p><img src=\"https://static.skynian.cn/js-async-201861401039.jpg\" alt=\"\"></p>\n<h2 id=\"Macrotask-和-Microtask\"><a href=\"#Macrotask-和-Microtask\" class=\"headerlink\" title=\"Macrotask 和 Microtask\"></a>Macrotask 和 Microtask</h2><p><strong>macro-tasks：</strong> script (整体代码)，setTimeout，setInterval，setImmediate，I/O，UI</p>\n<p><strong>micro-tasks：</strong> process.nextTick，Promises，Object.observe，MutationObserver（HTML5新特性）</p>\n<p>在一个事件循环里，</p>\n<p>这两个队列会分两步执行，</p>\n<p>第一步会固定地执行一个（且仅一个）Macrotask 任务，</p>\n<p>第二步会执行整个 Microtask 队列中的所有任务。</p>\n<p><img src=\"https://static.skynian.cn/js-async-2018614020.png\" alt=\"\"></p>\n<blockquote>\n<p>接下来，我们用代码来感受</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout1'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    i === <span class=\"number\">99</span> &amp;&amp; resolve()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'then1'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'glogal1'</span>)</span><br></pre></td></tr></table></figure>\n<p>答案:</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">global1</span><br><span class=\"line\">then1</span><br><span class=\"line\">timeout1</span><br></pre></td></tr></table></figure>\n<h2 id=\"在线演示\"><a href=\"#在线演示\" class=\"headerlink\" title=\"在线演示\"></a>在线演示</h2><p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n<p><img src=\"https://static.skynian.cn/js-async-20186140952.png\" alt=\"\"></p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p><strong>Macrotasks:</strong> 代表一些离散的独立的工作，task结束后，浏览器继续其他工作如页面重渲染和垃圾回收等</p>\n<p><strong>Microtasks:</strong> 更新完成应用程序状态的较小任务，在UI重渲染之前执行某些任务，避免不必要的UI渲染</p>\n<h2 id=\"Vue-中-MutationObserver\"><a href=\"#Vue-中-MutationObserver\" class=\"headerlink\" title=\"Vue 中 MutationObserver\"></a>Vue 中 MutationObserver</h2><p><a href=\"https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95\" target=\"_blank\" rel=\"noopener\">\bhttps://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> counter = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observer = <span class=\"keyword\">new</span> MutationObserver(nextTickHandler)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textNode = <span class=\"built_in\">document</span>.createTextNode(<span class=\"built_in\">String</span>(counter))</span><br><span class=\"line\">observer.observe(textNode, &#123;</span><br><span class=\"line\">    characterData: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">timerFunc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    counter = (counter + <span class=\"number\">1</span>) % <span class=\"number\">2</span></span><br><span class=\"line\">    textNode.data = <span class=\"built_in\">String</span>(counter)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS异步发展\"><a href=\"#JS异步发展\" class=\"headerlink\" title=\"JS异步发展\"></a>JS异步发展</h2><ul>\n<li>Callback</li>\n<li>Promise</li>\n<li>Generator</li>\n<li>Async function</li>\n<li>rxjs ??</li>\n<li>……</li>\n</ul>\n<h2 id=\"Callback\"><a href=\"#Callback\" class=\"headerlink\" title=\"Callback\"></a>Callback</h2><ul>\n<li>给匿名函数命名</li>\n<li>模块化</li>\n<li>…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getData(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    getMoreData(a, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">        getMoreData(b, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">            getMoreData(c, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123;</span><br><span class=\"line\">                getMoreData(d, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><ul>\n<li>解决了异步回调函数层层嵌套</li>\n<li>错误处理以及链式回调</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有 promise</span></span><br><span class=\"line\">a(getResultFromA, (aResult, err) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">    b(getResultFromB, (bResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">        c(getResultFromC, (cResult, err) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用了 promise 后</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  a(getResultFromA, (aResult, err) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err) resolve(aResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    b(getResultFromB, (bResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) resolve(bResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    c(getResultFromC, (cResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) resolve(cResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><ul>\n<li>“协程”（coroutine），意思是多个线程互相协作，完成异步任务</li>\n<li>流程管理却不方便</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">'node-fetch'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"string\">'https://api.github.com/users/github'</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> fetch(url)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result.bio)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen()</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = g.next()</span><br><span class=\"line\"></span><br><span class=\"line\">result.value.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data.json()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  g.next(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><ul>\n<li>内置执行器</li>\n<li>更好的语义</li>\n<li>更广的适用性</li>\n<li>返回值是Promise</li>\n</ul>\n<h2 id=\"Rxjs-流Stream\"><a href=\"#Rxjs-流Stream\" class=\"headerlink\" title=\"Rxjs(流Stream)\"></a>Rxjs(流Stream)</h2><p>Reactive Extensions for JavaScript</p>\n<p>观察者 + 迭代器模式</p>\n<p>Observables 与 Observer</p>\n<p><strong>订阅：</strong> Observer 通过 Observable 提供的 subscribe() 方法订阅Observable<br><strong>发布：</strong> Observable 通过回调 next 方法向 Observer 发布事件</p>\n<p><a href=\"http://www.alloyteam.com/2016/12/learn-rxjs/\" target=\"_blank\" rel=\"noopener\">构建流式应用—RxJS详解(AlloyTeam)</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<h2 id=\"JavaScript是单线程？\"><a href=\"#JavaScript是单线程？\" class=\"headerlink\" title=\"JavaScript是单线程？\"></a>JavaScript是单线程？</h2><ul>\n<li>JS 引擎中负责解释和执行 JS 代码的线程只有一个（主）</li>\n<li>AJAX 、处理 DOM 、定时器、读写……（工作线程）</li>\n<li>对于耗时或者时间不确定的操作，使用异步</li>\n<li>HTML5 Web Worker 多线程</li>\n</ul>","more":"<h2 id=\"异步执行机制\"><a href=\"#异步执行机制\" class=\"headerlink\" title=\"异步执行机制\"></a>异步执行机制</h2><ol>\n<li>所有同步任务都在主线程执行，形成执行栈</li>\n<li>“任务队列”，异步任务的结果存放</li>\n<li>同步任务执行完毕，读取“任务队列”</li>\n<li>主线程不断重复第三步</li>\n<li>主线程阻塞，任务队列依旧能够被推入任务</li>\n</ol>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>主线程从“任务队列”中读取事件，不断循环</p>\n<p><img src=\"https://static.skynian.cn/js-async-201861401039.jpg\" alt=\"\"></p>\n<h2 id=\"Macrotask-和-Microtask\"><a href=\"#Macrotask-和-Microtask\" class=\"headerlink\" title=\"Macrotask 和 Microtask\"></a>Macrotask 和 Microtask</h2><p><strong>macro-tasks：</strong> script (整体代码)，setTimeout，setInterval，setImmediate，I/O，UI</p>\n<p><strong>micro-tasks：</strong> process.nextTick，Promises，Object.observe，MutationObserver（HTML5新特性）</p>\n<p>在一个事件循环里，</p>\n<p>这两个队列会分两步执行，</p>\n<p>第一步会固定地执行一个（且仅一个）Macrotask 任务，</p>\n<p>第二步会执行整个 Microtask 队列中的所有任务。</p>\n<p><img src=\"https://static.skynian.cn/js-async-2018614020.png\" alt=\"\"></p>\n<blockquote>\n<p>接下来，我们用代码来感受</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout1'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    i === <span class=\"number\">99</span> &amp;&amp; resolve()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'then1'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'glogal1'</span>)</span><br></pre></td></tr></table></figure>\n<p>答案:</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">global1</span><br><span class=\"line\">then1</span><br><span class=\"line\">timeout1</span><br></pre></td></tr></table></figure>\n<h2 id=\"在线演示\"><a href=\"#在线演示\" class=\"headerlink\" title=\"在线演示\"></a>在线演示</h2><p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n<p><img src=\"https://static.skynian.cn/js-async-20186140952.png\" alt=\"\"></p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p><strong>Macrotasks:</strong> 代表一些离散的独立的工作，task结束后，浏览器继续其他工作如页面重渲染和垃圾回收等</p>\n<p><strong>Microtasks:</strong> 更新完成应用程序状态的较小任务，在UI重渲染之前执行某些任务，避免不必要的UI渲染</p>\n<h2 id=\"Vue-中-MutationObserver\"><a href=\"#Vue-中-MutationObserver\" class=\"headerlink\" title=\"Vue 中 MutationObserver\"></a>Vue 中 MutationObserver</h2><p><a href=\"https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95\" target=\"_blank\" rel=\"noopener\">\bhttps://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> counter = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observer = <span class=\"keyword\">new</span> MutationObserver(nextTickHandler)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textNode = <span class=\"built_in\">document</span>.createTextNode(<span class=\"built_in\">String</span>(counter))</span><br><span class=\"line\">observer.observe(textNode, &#123;</span><br><span class=\"line\">    characterData: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">timerFunc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    counter = (counter + <span class=\"number\">1</span>) % <span class=\"number\">2</span></span><br><span class=\"line\">    textNode.data = <span class=\"built_in\">String</span>(counter)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS异步发展\"><a href=\"#JS异步发展\" class=\"headerlink\" title=\"JS异步发展\"></a>JS异步发展</h2><ul>\n<li>Callback</li>\n<li>Promise</li>\n<li>Generator</li>\n<li>Async function</li>\n<li>rxjs ??</li>\n<li>……</li>\n</ul>\n<h2 id=\"Callback\"><a href=\"#Callback\" class=\"headerlink\" title=\"Callback\"></a>Callback</h2><ul>\n<li>给匿名函数命名</li>\n<li>模块化</li>\n<li>…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getData(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    getMoreData(a, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">        getMoreData(b, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">            getMoreData(c, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123;</span><br><span class=\"line\">                getMoreData(d, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><ul>\n<li>解决了异步回调函数层层嵌套</li>\n<li>错误处理以及链式回调</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有 promise</span></span><br><span class=\"line\">a(getResultFromA, (aResult, err) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">    b(getResultFromB, (bResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">        c(getResultFromC, (cResult, err) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用了 promise 后</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  a(getResultFromA, (aResult, err) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err) resolve(aResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    b(getResultFromB, (bResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) resolve(bResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    c(getResultFromC, (cResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) resolve(cResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><ul>\n<li>“协程”（coroutine），意思是多个线程互相协作，完成异步任务</li>\n<li>流程管理却不方便</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">'node-fetch'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"string\">'https://api.github.com/users/github'</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> fetch(url)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result.bio)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen()</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = g.next()</span><br><span class=\"line\"></span><br><span class=\"line\">result.value.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data.json()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  g.next(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><ul>\n<li>内置执行器</li>\n<li>更好的语义</li>\n<li>更广的适用性</li>\n<li>返回值是Promise</li>\n</ul>\n<h2 id=\"Rxjs-流Stream\"><a href=\"#Rxjs-流Stream\" class=\"headerlink\" title=\"Rxjs(流Stream)\"></a>Rxjs(流Stream)</h2><p>Reactive Extensions for JavaScript</p>\n<p>观察者 + 迭代器模式</p>\n<p>Observables 与 Observer</p>\n<p><strong>订阅：</strong> Observer 通过 Observable 提供的 subscribe() 方法订阅Observable<br><strong>发布：</strong> Observable 通过回调 next 方法向 Observer 发布事件</p>\n<p><a href=\"http://www.alloyteam.com/2016/12/learn-rxjs/\" target=\"_blank\" rel=\"noopener\">构建流式应用—RxJS详解(AlloyTeam)</a></p>"},{"title":"JavaScript 内存管理浅谈","date":"2018-06-22T03:24:57.000Z","_content":"\n最近一直在回溯自己的的前端知识体系，发现，工作一段时间后，再去回顾之前的知识，体会真的不一样。\n\n这次就简单了解一下 JavaScript 中的内存管理，涉及到了闭包，内存泄漏等前端常见问题。\n\n## 写在前面\n\nJavaScript 中的内存管理，给我的感觉可能一种偏科。我们平时可能不太重视，但是一旦出了问题，又会很棘手。其次，项目优化的时候也避免不了要踩坑。\n\n可以通过多了解一些内存管理问题，写代码的时候通过一些习惯，避免内存泄漏的问题。在项目 pr 流程中，也可以根据此给同事提供一些意见。\n\n## 内存生命周期\n\n![内存生命周期](https://static.skynian.cn/javascript-memory-management-201862211342.jpg)\n\n上图的流程是：\n\n1. 分配所需的内存\n2. 使用分配到的内存（读、写）\n3. 不需要时候释放/归还\n\n在 C 语言中，有专门的内存管理接口，像 malloc() 和 free()，而在 JS 中有着一个自动的垃圾回收机制。\n\n## JavaScript 中的内存回收 (GC:Garbage Collecation)\n\n### \b引用计数垃圾收集\n\n引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 。相反，如果包含\b对这个值的变量又取得了另外一个值，则这个值的引用册数就减 1 。\n\n当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。\n\n但是这个是存在问题的：\n\neg：\n```js\nfunction problem() {\n  let objA = new Object()\n  let objB = new Object()\n\n  objA.someOtherObject = objB\n  objb.anotherObject = objA\n}\n```\n\n在这个例子中，objA 和objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。\n\n我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以COM（Component Object\nModel，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使 IE 的 Javascript 引擎使用标记清除的策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数的策略的。说白了，只要 IE 中涉及 COM 对象，就会存在循环引用的问题。看看下面的这个简单的例子：\n\n```js\nlet element = document.getElementById(\"some_element\")\nlet myObj =new Object()\n\nmyObj.element = element\nelement.someObject = myObj\n```\n\n上面这个例子中，在一个 DOM 元素 (element) 与一个原生 JavaScript 对象(myObj)之间建立了循环引用。其中，变量 myObj 有一个名为 element 的属性指向 element ；而变量 element 有一个名为 someObject 的属性回指到 myObj。由于循环引用，即使将例子中的 DOM 从页面中移除，内存也永远不会回收。\n\n不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。\n\n```js\nmyObj.element = null\nelement.someObject =null\n```\n\n IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收. 该方式常常造成对象被循环引用时内存发生泄漏. 现代浏览器通过使用标记-清除内存回收算法, 来解决这一问题。\n\n ### 标记-清除算法\n\n这个算法把\"对象是否不再需要\"简化定义为\"对象是否可以获得\"。这个算法假定设置一个叫做根 root 的对象（在Javascript里，根是全局对象。定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。\n\n从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进。\n\n到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。\n\n![标记-清除算法](https://static.skynian.cn/javascript-memory-management-20186221499.jpg)\n\n## 自动 GC 的问题\n\n尽管自动 GC 很方便, 但是我们不知道GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收。\n\n## 常见的内存泄露案例\n\n### 全局变量\n\n```js\nfunction foo(arg) {\n    bar = \"some text\";\n}\n```\n\n在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar , 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.\n\n所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕. 另外一种意外创建全局变量的情况。\n\n```js\nfunction foo() {\n  this.var1 = \"potential accidental global\"\n}\n\n// Foo 被调用时, this 指向全局变量(window)\nfoo()\n```\n\n在这种情况下调用 foo,  this被指向了全局变量 window, 意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量.\n\n如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.\n\n### 未销毁的定时器和回调函数\n\n在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval的例子.\n\n```js\nlet serverData = loadData()\n\nsetInterval(function() {\n  let renderer = document.getElementById('renderer')\n  if(renderer) {\n      renderer.innerHTML = JSON.stringify(serverData)\n  }\n}, 5000) // 每 5 秒调用一次\n```\n\n如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.\n\n## 闭包\n\n在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.\n\n```js\nlet theThing = null\nlet replaceThing = function () {\n  let originalThing = theThing\n  let unused = function () {\n    if (originalThing) // 对于 'originalThing'的引用\n      console.log(\"hi\")\n  };\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log(\"message\")\n    }\n  };\n}\n\nsetInterval(replaceThing, 1000)\n```\n\n这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象.  同时 unused 是一个引用了 originalThing 的闭包.\n\n这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长. 该问题的更多描述可见[Meteor团队的这篇文章](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=a92ddcd69bbf)\b。\n\n### DOM 引用\n\n很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.\n\n```js\nlet elements = {\n  image: document.getElementById('image')\n};\nfunction doStuff() {\n  elements.image.src = 'http://example.com/image_name.png'\n}\nfunction removeImage() {\n  document.body.removeChild(document.getElementById('image'))\n  // 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.\n}\n```\n\n上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.\n\n另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.\n\n### ES6\n\nES6中引入 WeakSet  和 WeakMap 两个新的概念, 来解决引用造成的内存回收问题.  WeakSet 和 WeakMap 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.\n\n## 总结\n\n　在 Javascript 中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。\n\n　　但是，为了减少内存垃圾，我们还是可以对 Javascript 代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。\n\n　　我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的 Javascript 应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。\n\n## 参考\n\n[Barret Lee JavaScript 垃圾回收机制](http://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html)\n\n[阮一峰 JavaScript 内存泄漏教程](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)\n","source":"_posts/javascript-memory-management.md","raw":"---\ntitle: JavaScript 内存管理浅谈\ndate: 2018-06-22 11:24:57\ntags:\n  - JavaScript\n  - 优化\ncategories: JavaScript\n---\n\n最近一直在回溯自己的的前端知识体系，发现，工作一段时间后，再去回顾之前的知识，体会真的不一样。\n\n这次就简单了解一下 JavaScript 中的内存管理，涉及到了闭包，内存泄漏等前端常见问题。\n\n## 写在前面\n\nJavaScript 中的内存管理，给我的感觉可能一种偏科。我们平时可能不太重视，但是一旦出了问题，又会很棘手。其次，项目优化的时候也避免不了要踩坑。\n\n可以通过多了解一些内存管理问题，写代码的时候通过一些习惯，避免内存泄漏的问题。在项目 pr 流程中，也可以根据此给同事提供一些意见。\n\n## 内存生命周期\n\n![内存生命周期](https://static.skynian.cn/javascript-memory-management-201862211342.jpg)\n\n上图的流程是：\n\n1. 分配所需的内存\n2. 使用分配到的内存（读、写）\n3. 不需要时候释放/归还\n\n在 C 语言中，有专门的内存管理接口，像 malloc() 和 free()，而在 JS 中有着一个自动的垃圾回收机制。\n\n## JavaScript 中的内存回收 (GC:Garbage Collecation)\n\n### \b引用计数垃圾收集\n\n引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 。相反，如果包含\b对这个值的变量又取得了另外一个值，则这个值的引用册数就减 1 。\n\n当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。\n\n但是这个是存在问题的：\n\neg：\n```js\nfunction problem() {\n  let objA = new Object()\n  let objB = new Object()\n\n  objA.someOtherObject = objB\n  objb.anotherObject = objA\n}\n```\n\n在这个例子中，objA 和objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。\n\n我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以COM（Component Object\nModel，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使 IE 的 Javascript 引擎使用标记清除的策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数的策略的。说白了，只要 IE 中涉及 COM 对象，就会存在循环引用的问题。看看下面的这个简单的例子：\n\n```js\nlet element = document.getElementById(\"some_element\")\nlet myObj =new Object()\n\nmyObj.element = element\nelement.someObject = myObj\n```\n\n上面这个例子中，在一个 DOM 元素 (element) 与一个原生 JavaScript 对象(myObj)之间建立了循环引用。其中，变量 myObj 有一个名为 element 的属性指向 element ；而变量 element 有一个名为 someObject 的属性回指到 myObj。由于循环引用，即使将例子中的 DOM 从页面中移除，内存也永远不会回收。\n\n不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。\n\n```js\nmyObj.element = null\nelement.someObject =null\n```\n\n IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收. 该方式常常造成对象被循环引用时内存发生泄漏. 现代浏览器通过使用标记-清除内存回收算法, 来解决这一问题。\n\n ### 标记-清除算法\n\n这个算法把\"对象是否不再需要\"简化定义为\"对象是否可以获得\"。这个算法假定设置一个叫做根 root 的对象（在Javascript里，根是全局对象。定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。\n\n从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进。\n\n到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。\n\n![标记-清除算法](https://static.skynian.cn/javascript-memory-management-20186221499.jpg)\n\n## 自动 GC 的问题\n\n尽管自动 GC 很方便, 但是我们不知道GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收。\n\n## 常见的内存泄露案例\n\n### 全局变量\n\n```js\nfunction foo(arg) {\n    bar = \"some text\";\n}\n```\n\n在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar , 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.\n\n所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕. 另外一种意外创建全局变量的情况。\n\n```js\nfunction foo() {\n  this.var1 = \"potential accidental global\"\n}\n\n// Foo 被调用时, this 指向全局变量(window)\nfoo()\n```\n\n在这种情况下调用 foo,  this被指向了全局变量 window, 意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量.\n\n如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.\n\n### 未销毁的定时器和回调函数\n\n在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval的例子.\n\n```js\nlet serverData = loadData()\n\nsetInterval(function() {\n  let renderer = document.getElementById('renderer')\n  if(renderer) {\n      renderer.innerHTML = JSON.stringify(serverData)\n  }\n}, 5000) // 每 5 秒调用一次\n```\n\n如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.\n\n## 闭包\n\n在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.\n\n```js\nlet theThing = null\nlet replaceThing = function () {\n  let originalThing = theThing\n  let unused = function () {\n    if (originalThing) // 对于 'originalThing'的引用\n      console.log(\"hi\")\n  };\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log(\"message\")\n    }\n  };\n}\n\nsetInterval(replaceThing, 1000)\n```\n\n这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象.  同时 unused 是一个引用了 originalThing 的闭包.\n\n这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长. 该问题的更多描述可见[Meteor团队的这篇文章](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=a92ddcd69bbf)\b。\n\n### DOM 引用\n\n很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.\n\n```js\nlet elements = {\n  image: document.getElementById('image')\n};\nfunction doStuff() {\n  elements.image.src = 'http://example.com/image_name.png'\n}\nfunction removeImage() {\n  document.body.removeChild(document.getElementById('image'))\n  // 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.\n}\n```\n\n上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.\n\n另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.\n\n### ES6\n\nES6中引入 WeakSet  和 WeakMap 两个新的概念, 来解决引用造成的内存回收问题.  WeakSet 和 WeakMap 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.\n\n## 总结\n\n　在 Javascript 中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。\n\n　　但是，为了减少内存垃圾，我们还是可以对 Javascript 代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。\n\n　　我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的 Javascript 应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。\n\n## 参考\n\n[Barret Lee JavaScript 垃圾回收机制](http://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html)\n\n[阮一峰 JavaScript 内存泄漏教程](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)\n","slug":"javascript-memory-management","published":1,"updated":"2018-06-22T08:59:57.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprk0o000cevfymrxtxxit","content":"<p>最近一直在回溯自己的的前端知识体系，发现，工作一段时间后，再去回顾之前的知识，体会真的不一样。</p>\n<p>这次就简单了解一下 JavaScript 中的内存管理，涉及到了闭包，内存泄漏等前端常见问题。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>JavaScript 中的内存管理，给我的感觉可能一种偏科。我们平时可能不太重视，但是一旦出了问题，又会很棘手。其次，项目优化的时候也避免不了要踩坑。</p>\n<p>可以通过多了解一些内存管理问题，写代码的时候通过一些习惯，避免内存泄漏的问题。在项目 pr 流程中，也可以根据此给同事提供一些意见。</p>\n<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h2><p><img src=\"https://static.skynian.cn/javascript-memory-management-201862211342.jpg\" alt=\"内存生命周期\"></p>\n<p>上图的流程是：</p>\n<ol>\n<li>分配所需的内存</li>\n<li>使用分配到的内存（读、写）</li>\n<li>不需要时候释放/归还</li>\n</ol>\n<p>在 C 语言中，有专门的内存管理接口，像 malloc() 和 free()，而在 JS 中有着一个自动的垃圾回收机制。</p>\n<h2 id=\"JavaScript-中的内存回收-GC-Garbage-Collecation\"><a href=\"#JavaScript-中的内存回收-GC-Garbage-Collecation\" class=\"headerlink\" title=\"JavaScript 中的内存回收 (GC:Garbage Collecation)\"></a>JavaScript 中的内存回收 (GC:Garbage Collecation)</h2><h3 id=\"引用计数垃圾收集\"><a href=\"#引用计数垃圾收集\" class=\"headerlink\" title=\"\b引用计数垃圾收集\"></a>\b引用计数垃圾收集</h3><p>引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 。相反，如果包含\b对这个值的变量又取得了另外一个值，则这个值的引用册数就减 1 。</p>\n<p>当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。</p>\n<p>但是这个是存在问题的：</p>\n<p>eg：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">problem</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objA = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objB = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">  objA.someOtherObject = objB</span><br><span class=\"line\">  objb.anotherObject = objA</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，objA 和objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p>\n<p>我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以COM（Component Object<br>Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使 IE 的 Javascript 引擎使用标记清除的策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数的策略的。说白了，只要 IE 中涉及 COM 对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"some_element\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj =<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.element = element</span><br><span class=\"line\">element.someObject = myObj</span><br></pre></td></tr></table></figure>\n<p>上面这个例子中，在一个 DOM 元素 (element) 与一个原生 JavaScript 对象(myObj)之间建立了循环引用。其中，变量 myObj 有一个名为 element 的属性指向 element ；而变量 element 有一个名为 someObject 的属性回指到 myObj。由于循环引用，即使将例子中的 DOM 从页面中移除，内存也永远不会回收。</p>\n<p>不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObj.element = <span class=\"literal\">null</span></span><br><span class=\"line\">element.someObject =<span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p> IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收. 该方式常常造成对象被循环引用时内存发生泄漏. 现代浏览器通过使用标记-清除内存回收算法, 来解决这一问题。</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>这个算法把”对象是否不再需要”简化定义为”对象是否可以获得”。这个算法假定设置一个叫做根 root 的对象（在Javascript里，根是全局对象。定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>\n<p>从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进。</p>\n<p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>\n<p><img src=\"https://static.skynian.cn/javascript-memory-management-20186221499.jpg\" alt=\"标记-清除算法\"></p>\n<h2 id=\"自动-GC-的问题\"><a href=\"#自动-GC-的问题\" class=\"headerlink\" title=\"自动 GC 的问题\"></a>自动 GC 的问题</h2><p>尽管自动 GC 很方便, 但是我们不知道GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收。</p>\n<h2 id=\"常见的内存泄露案例\"><a href=\"#常见的内存泄露案例\" class=\"headerlink\" title=\"常见的内存泄露案例\"></a>常见的内存泄露案例</h2><h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    bar = <span class=\"string\">\"some text\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar , 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.</p>\n<p>所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕. 另外一种意外创建全局变量的情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.var1 = <span class=\"string\">\"potential accidental global\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foo 被调用时, this 指向全局变量(window)</span></span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>在这种情况下调用 foo,  this被指向了全局变量 window, 意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量.</p>\n<p>如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.</p>\n<h3 id=\"未销毁的定时器和回调函数\"><a href=\"#未销毁的定时器和回调函数\" class=\"headerlink\" title=\"未销毁的定时器和回调函数\"></a>未销毁的定时器和回调函数</h3><p>在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval的例子.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> serverData = loadData()</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> renderer = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'renderer'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(renderer) &#123;</span><br><span class=\"line\">      renderer.innerHTML = <span class=\"built_in\">JSON</span>.stringify(serverData)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>) <span class=\"comment\">// 每 5 秒调用一次</span></span><br></pre></td></tr></table></figure>\n<p>如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> theThing = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> replaceThing = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> originalThing = theThing</span><br><span class=\"line\">  <span class=\"keyword\">let</span> unused = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (originalThing) <span class=\"comment\">// 对于 'originalThing'的引用</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>).join(<span class=\"string\">'*'</span>),</span><br><span class=\"line\">    someMethod: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"message\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象.  同时 unused 是一个引用了 originalThing 的闭包.</p>\n<p>这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长. 该问题的更多描述可见<a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=a92ddcd69bbf\" target=\"_blank\" rel=\"noopener\">Meteor团队的这篇文章</a>\b。</p>\n<h3 id=\"DOM-引用\"><a href=\"#DOM-引用\" class=\"headerlink\" title=\"DOM 引用\"></a>DOM 引用</h3><p>很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> elements = &#123;</span><br><span class=\"line\">  image: <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'image'</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doStuff</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  elements.image.src = <span class=\"string\">'http://example.com/image_name.png'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeImage</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.removeChild(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'image'</span>))</span><br><span class=\"line\">  <span class=\"comment\">// 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.</p>\n<p>另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.</p>\n<h3 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h3><p>ES6中引入 WeakSet  和 WeakMap 两个新的概念, 来解决引用造成的内存回收问题.  WeakSet 和 WeakMap 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　在 Javascript 中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。</p>\n<p>　　但是，为了减少内存垃圾，我们还是可以对 Javascript 代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。</p>\n<p>　　我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的 Javascript 应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html\" target=\"_blank\" rel=\"noopener\">Barret Lee JavaScript 垃圾回收机制</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\" target=\"_blank\" rel=\"noopener\">阮一峰 JavaScript 内存泄漏教程</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>最近一直在回溯自己的的前端知识体系，发现，工作一段时间后，再去回顾之前的知识，体会真的不一样。</p>\n<p>这次就简单了解一下 JavaScript 中的内存管理，涉及到了闭包，内存泄漏等前端常见问题。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>JavaScript 中的内存管理，给我的感觉可能一种偏科。我们平时可能不太重视，但是一旦出了问题，又会很棘手。其次，项目优化的时候也避免不了要踩坑。</p>\n<p>可以通过多了解一些内存管理问题，写代码的时候通过一些习惯，避免内存泄漏的问题。在项目 pr 流程中，也可以根据此给同事提供一些意见。</p>\n<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h2><p><img src=\"https://static.skynian.cn/javascript-memory-management-201862211342.jpg\" alt=\"内存生命周期\"></p>\n<p>上图的流程是：</p>\n<ol>\n<li>分配所需的内存</li>\n<li>使用分配到的内存（读、写）</li>\n<li>不需要时候释放/归还</li>\n</ol>\n<p>在 C 语言中，有专门的内存管理接口，像 malloc() 和 free()，而在 JS 中有着一个自动的垃圾回收机制。</p>\n<h2 id=\"JavaScript-中的内存回收-GC-Garbage-Collecation\"><a href=\"#JavaScript-中的内存回收-GC-Garbage-Collecation\" class=\"headerlink\" title=\"JavaScript 中的内存回收 (GC:Garbage Collecation)\"></a>JavaScript 中的内存回收 (GC:Garbage Collecation)</h2><h3 id=\"引用计数垃圾收集\"><a href=\"#引用计数垃圾收集\" class=\"headerlink\" title=\"\b引用计数垃圾收集\"></a>\b引用计数垃圾收集</h3><p>引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 。相反，如果包含\b对这个值的变量又取得了另外一个值，则这个值的引用册数就减 1 。</p>\n<p>当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。</p>\n<p>但是这个是存在问题的：</p>\n<p>eg：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">problem</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objA = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objB = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">  objA.someOtherObject = objB</span><br><span class=\"line\">  objb.anotherObject = objA</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，objA 和objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p>\n<p>我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以COM（Component Object<br>Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使 IE 的 Javascript 引擎使用标记清除的策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数的策略的。说白了，只要 IE 中涉及 COM 对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"some_element\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj =<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.element = element</span><br><span class=\"line\">element.someObject = myObj</span><br></pre></td></tr></table></figure>\n<p>上面这个例子中，在一个 DOM 元素 (element) 与一个原生 JavaScript 对象(myObj)之间建立了循环引用。其中，变量 myObj 有一个名为 element 的属性指向 element ；而变量 element 有一个名为 someObject 的属性回指到 myObj。由于循环引用，即使将例子中的 DOM 从页面中移除，内存也永远不会回收。</p>\n<p>不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObj.element = <span class=\"literal\">null</span></span><br><span class=\"line\">element.someObject =<span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p> IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收. 该方式常常造成对象被循环引用时内存发生泄漏. 现代浏览器通过使用标记-清除内存回收算法, 来解决这一问题。</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>这个算法把”对象是否不再需要”简化定义为”对象是否可以获得”。这个算法假定设置一个叫做根 root 的对象（在Javascript里，根是全局对象。定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>\n<p>从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进。</p>\n<p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>\n<p><img src=\"https://static.skynian.cn/javascript-memory-management-20186221499.jpg\" alt=\"标记-清除算法\"></p>\n<h2 id=\"自动-GC-的问题\"><a href=\"#自动-GC-的问题\" class=\"headerlink\" title=\"自动 GC 的问题\"></a>自动 GC 的问题</h2><p>尽管自动 GC 很方便, 但是我们不知道GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收。</p>\n<h2 id=\"常见的内存泄露案例\"><a href=\"#常见的内存泄露案例\" class=\"headerlink\" title=\"常见的内存泄露案例\"></a>常见的内存泄露案例</h2><h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    bar = <span class=\"string\">\"some text\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar , 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.</p>\n<p>所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕. 另外一种意外创建全局变量的情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.var1 = <span class=\"string\">\"potential accidental global\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foo 被调用时, this 指向全局变量(window)</span></span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>在这种情况下调用 foo,  this被指向了全局变量 window, 意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量.</p>\n<p>如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.</p>\n<h3 id=\"未销毁的定时器和回调函数\"><a href=\"#未销毁的定时器和回调函数\" class=\"headerlink\" title=\"未销毁的定时器和回调函数\"></a>未销毁的定时器和回调函数</h3><p>在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval的例子.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> serverData = loadData()</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> renderer = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'renderer'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(renderer) &#123;</span><br><span class=\"line\">      renderer.innerHTML = <span class=\"built_in\">JSON</span>.stringify(serverData)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>) <span class=\"comment\">// 每 5 秒调用一次</span></span><br></pre></td></tr></table></figure>\n<p>如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> theThing = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> replaceThing = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> originalThing = theThing</span><br><span class=\"line\">  <span class=\"keyword\">let</span> unused = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (originalThing) <span class=\"comment\">// 对于 'originalThing'的引用</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>).join(<span class=\"string\">'*'</span>),</span><br><span class=\"line\">    someMethod: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"message\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象.  同时 unused 是一个引用了 originalThing 的闭包.</p>\n<p>这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长. 该问题的更多描述可见<a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=a92ddcd69bbf\" target=\"_blank\" rel=\"noopener\">Meteor团队的这篇文章</a>\b。</p>\n<h3 id=\"DOM-引用\"><a href=\"#DOM-引用\" class=\"headerlink\" title=\"DOM 引用\"></a>DOM 引用</h3><p>很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> elements = &#123;</span><br><span class=\"line\">  image: <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'image'</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doStuff</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  elements.image.src = <span class=\"string\">'http://example.com/image_name.png'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeImage</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.removeChild(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'image'</span>))</span><br><span class=\"line\">  <span class=\"comment\">// 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.</p>\n<p>另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.</p>\n<h3 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h3><p>ES6中引入 WeakSet  和 WeakMap 两个新的概念, 来解决引用造成的内存回收问题.  WeakSet 和 WeakMap 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　在 Javascript 中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。</p>\n<p>　　但是，为了减少内存垃圾，我们还是可以对 Javascript 代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。</p>\n<p>　　我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的 Javascript 应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html\" target=\"_blank\" rel=\"noopener\">Barret Lee JavaScript 垃圾回收机制</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\" target=\"_blank\" rel=\"noopener\">阮一峰 JavaScript 内存泄漏教程</a></p>\n"},{"title":"前端模块化","date":"2018-06-17T04:25:39.000Z","_content":"\n模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 [module-loader](https://note.youdao.com/)。\n\n<!--more-->\n\n## \b一、CommonJS\n\nNode.js 是 commonJS 规范的主要时间者，它有四个重要的环境变量为模块化的实现提供支持：\n**module**、\b**exports**、**require**、**global**。\n\n实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用exports），用 require 加载模块\n\n```js\n// 定义模块 math.js\n\nlet basicNum = 0\n\nfunction add(a, b) {\n  return a + b\n}\n\n// 在这里写需要向外暴露的函数、变量\nmodule.exports = {\n  add,\n  basicNum: basicNum,\n}\n\n// 引用自定义的模块，参数包含路径，可省略 .js\nlet math = require('./math')\nmath.add(2, 5)\n\n// 引用核心模块时，不需要带路径\nlet http = require('http')\nhttp.createService(...).listen(3000)\n```\n\ncommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\n\n## 二、AMD 和 require.js\n\nAMD: 提前执行（异步加载：依赖先执行 + 延迟执行）\n\nAMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。\n\n由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS，实际上  AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。\n\n\bAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行。\n\n这里介绍用 require.js 实现 AMD 规范的模块化：\n\n用 **require.config()** 指定引用路径，用 **define()** 定义模块，用 require() 加载模块\n\n首先我们需要引入 require.js 文件和一个入口文件 main.js。 main.js 中配置 require.config() 并规定项目中用到的基础模块。\n\n```js\n// 网页中引入 require.js 及 main.js\n<script src=\"js/require.js\" data-main=\"js/main\"></script>\n\n// main.js 入口文件/主模块\n// 首先用 config() 指定各模块\b路径和引用名\nrequire.config({\n  baseUrl: 'js/lib',\n  paths: {\n    jquery: 'jquery.min',\n    underscore: 'underscore.min',\n  },\n})\n\n// 执行基本操作\nrequire(['jqery', 'underscore'], function($, _) {\n  // some code here\n})\n```\n\n引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。\n\n```js\n// 定义math.js模块\ndefine(function () {\n    let basicNum = 0\n    let add = function(x, y) {\n        return x + y\n    }\n    return {\n        add,\n        basicNum :basicNum,\n    }\n});\n// 定义一个依赖underscore.js的模块\ndefine(['underscore'], function(_) {\n  let classify = function(list){\n    _.countBy(list,function(num){\n      return num > 30 ? 'old' : 'young'\n    })\n  }\n  return {\n    classify,\n  }\n})\n\n// 引用模块，将模块放在[]内\nrequire(['jquery', 'math'],function($, math) {\n  var sum = math.add(10,20)\n  $(\"#sum\").html(sum)\n})\n```\n\n## 三、CMD 和 sea.js\n\nCMD: 延迟执行（运行到需加载，根据顺序执行）\n\nCMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n\nrequire.js 在申明依赖的模块时会在第一时间加载并执行模块内的代码：\n\n```js\n// AMD 写法\ndefine(['a', 'b', 'c'], function(a, b, c) {\n  // 等于在最前面声明并初始化了要用到的所有模块\n  if (false) {\n    // 即便没用到某个模块，但 b 还是提前执行了\n      b.foo()\n  }\n})\n\n// CMD 写法\ndefine(function(require, exports, module) {\n  let a = require('./a') //在需要时申明\n\n  a.doSomething()\n\n  if (false) {\n      var b = require('./b')\n      b.doSomething()\n  }\n})\n\n// sea.js\n// 定义模块 math.js\ndefine(function(require, exports, module) {\n  let $ = require('jquery.js')\n  var add = function(a, b) {\n      return a + b\n  }\n  exports.add = add\n})\n// 加载模块\nseajs.use(['math.js'], function(math) {\n  let sum = math.add(1 + 2)\n})\n```\n\n四、ES6 Module\n\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。\n\n```js\n// 定义模块 math.js\nlet basicNum = 0\nlet add = function (a, b) {\n    return a + b\n}\n\nexport { basicNum, add }\n\n// 引用模块\nimport { basicNum, add } from './math'\n\nfunction test(ele) {\n    ele.textContent = add(99 + basicNum)\n}\n```\n\n如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号。这也更趋近于ADM的引用写法。\n\n```js\n// export default\n// 定义输出\nexport default { basicNum, add }\n// 引入\nimport math from './math'\n\nfunction test(ele) {\n    ele.textContent = math.add(99 + math.basicNum)\n}\n```\n\nES6 的模块不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\n## 五、ES6 模块与 CommonJS 模块的差异\n\n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n  - CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n  - ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n  - 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n  - 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。\n\nCommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n","source":"_posts/module.md","raw":"---\ntitle: 前端模块化\ndate: 2018-06-17 12:25:39\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\n模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 [module-loader](https://note.youdao.com/)。\n\n<!--more-->\n\n## \b一、CommonJS\n\nNode.js 是 commonJS 规范的主要时间者，它有四个重要的环境变量为模块化的实现提供支持：\n**module**、\b**exports**、**require**、**global**。\n\n实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用exports），用 require 加载模块\n\n```js\n// 定义模块 math.js\n\nlet basicNum = 0\n\nfunction add(a, b) {\n  return a + b\n}\n\n// 在这里写需要向外暴露的函数、变量\nmodule.exports = {\n  add,\n  basicNum: basicNum,\n}\n\n// 引用自定义的模块，参数包含路径，可省略 .js\nlet math = require('./math')\nmath.add(2, 5)\n\n// 引用核心模块时，不需要带路径\nlet http = require('http')\nhttp.createService(...).listen(3000)\n```\n\ncommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\n\n## 二、AMD 和 require.js\n\nAMD: 提前执行（异步加载：依赖先执行 + 延迟执行）\n\nAMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。\n\n由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS，实际上  AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。\n\n\bAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行。\n\n这里介绍用 require.js 实现 AMD 规范的模块化：\n\n用 **require.config()** 指定引用路径，用 **define()** 定义模块，用 require() 加载模块\n\n首先我们需要引入 require.js 文件和一个入口文件 main.js。 main.js 中配置 require.config() 并规定项目中用到的基础模块。\n\n```js\n// 网页中引入 require.js 及 main.js\n<script src=\"js/require.js\" data-main=\"js/main\"></script>\n\n// main.js 入口文件/主模块\n// 首先用 config() 指定各模块\b路径和引用名\nrequire.config({\n  baseUrl: 'js/lib',\n  paths: {\n    jquery: 'jquery.min',\n    underscore: 'underscore.min',\n  },\n})\n\n// 执行基本操作\nrequire(['jqery', 'underscore'], function($, _) {\n  // some code here\n})\n```\n\n引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。\n\n```js\n// 定义math.js模块\ndefine(function () {\n    let basicNum = 0\n    let add = function(x, y) {\n        return x + y\n    }\n    return {\n        add,\n        basicNum :basicNum,\n    }\n});\n// 定义一个依赖underscore.js的模块\ndefine(['underscore'], function(_) {\n  let classify = function(list){\n    _.countBy(list,function(num){\n      return num > 30 ? 'old' : 'young'\n    })\n  }\n  return {\n    classify,\n  }\n})\n\n// 引用模块，将模块放在[]内\nrequire(['jquery', 'math'],function($, math) {\n  var sum = math.add(10,20)\n  $(\"#sum\").html(sum)\n})\n```\n\n## 三、CMD 和 sea.js\n\nCMD: 延迟执行（运行到需加载，根据顺序执行）\n\nCMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n\nrequire.js 在申明依赖的模块时会在第一时间加载并执行模块内的代码：\n\n```js\n// AMD 写法\ndefine(['a', 'b', 'c'], function(a, b, c) {\n  // 等于在最前面声明并初始化了要用到的所有模块\n  if (false) {\n    // 即便没用到某个模块，但 b 还是提前执行了\n      b.foo()\n  }\n})\n\n// CMD 写法\ndefine(function(require, exports, module) {\n  let a = require('./a') //在需要时申明\n\n  a.doSomething()\n\n  if (false) {\n      var b = require('./b')\n      b.doSomething()\n  }\n})\n\n// sea.js\n// 定义模块 math.js\ndefine(function(require, exports, module) {\n  let $ = require('jquery.js')\n  var add = function(a, b) {\n      return a + b\n  }\n  exports.add = add\n})\n// 加载模块\nseajs.use(['math.js'], function(math) {\n  let sum = math.add(1 + 2)\n})\n```\n\n四、ES6 Module\n\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。\n\n```js\n// 定义模块 math.js\nlet basicNum = 0\nlet add = function (a, b) {\n    return a + b\n}\n\nexport { basicNum, add }\n\n// 引用模块\nimport { basicNum, add } from './math'\n\nfunction test(ele) {\n    ele.textContent = add(99 + basicNum)\n}\n```\n\n如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号。这也更趋近于ADM的引用写法。\n\n```js\n// export default\n// 定义输出\nexport default { basicNum, add }\n// 引入\nimport math from './math'\n\nfunction test(ele) {\n    ele.textContent = math.add(99 + math.basicNum)\n}\n```\n\nES6 的模块不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\n## 五、ES6 模块与 CommonJS 模块的差异\n\n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n  - CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n  - ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n  - 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n  - 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。\n\nCommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n","slug":"module","published":1,"updated":"2018-06-17T06:26:39.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprk0q000eevfyc32ktjnw","content":"<p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 <a href=\"https://note.youdao.com/\" target=\"_blank\" rel=\"noopener\">module-loader</a>。</p>\n<a id=\"more\"></a>\n<h2 id=\"一、CommonJS\"><a href=\"#一、CommonJS\" class=\"headerlink\" title=\"\b一、CommonJS\"></a>\b一、CommonJS</h2><p>Node.js 是 commonJS 规范的主要时间者，它有四个重要的环境变量为模块化的实现提供支持：<br><strong>module</strong>、\b<strong>exports</strong>、<strong>require</strong>、<strong>global</strong>。</p>\n<p>实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用exports），用 require 加载模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在这里写需要向外暴露的函数、变量</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  add,</span><br><span class=\"line\">  basicNum: basicNum,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用自定义的模块，参数包含路径，可省略 .js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'./math'</span>)</span><br><span class=\"line\">math.add(<span class=\"number\">2</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用核心模块时，不需要带路径</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</span><br><span class=\"line\">http.createService(...).listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>commonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>\n<h2 id=\"二、AMD-和-require-js\"><a href=\"#二、AMD-和-require-js\" class=\"headerlink\" title=\"二、AMD 和 require.js\"></a>二、AMD 和 require.js</h2><p>AMD: 提前执行（异步加载：依赖先执行 + 延迟执行）</p>\n<p>AMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。</p>\n<p>由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS，实际上  AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。</p>\n<p>\bAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行。</p>\n<p>这里介绍用 require.js 实现 AMD 规范的模块化：</p>\n<p>用 <strong>require.config()</strong> 指定引用路径，用 <strong>define()</strong> 定义模块，用 require() 加载模块</p>\n<p>首先我们需要引入 require.js 文件和一个入口文件 main.js。 main.js 中配置 require.config() 并规定项目中用到的基础模块。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 网页中引入 require.js 及 main.js</span></span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"js/require.js\"</span> data-main=<span class=\"string\">\"js/main\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js 入口文件/主模块</span></span><br><span class=\"line\"><span class=\"comment\">// 首先用 config() 指定各模块\b路径和引用名</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">  baseUrl: <span class=\"string\">'js/lib'</span>,</span><br><span class=\"line\">  paths: &#123;</span><br><span class=\"line\">    jquery: <span class=\"string\">'jquery.min'</span>,</span><br><span class=\"line\">    underscore: <span class=\"string\">'underscore.min'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行基本操作</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'jqery'</span>, <span class=\"string\">'underscore'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, _</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code here</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义math.js模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        add,</span><br><span class=\"line\">        basicNum :basicNum,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 定义一个依赖underscore.js的模块</span></span><br><span class=\"line\">define([<span class=\"string\">'underscore'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> classify = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>)</span>&#123;</span><br><span class=\"line\">    _.countBy(list,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> num &gt; <span class=\"number\">30</span> ? <span class=\"string\">'old'</span> : <span class=\"string\">'young'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    classify,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用模块，将模块放在[]内</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'jquery'</span>, <span class=\"string\">'math'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, math</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = math.add(<span class=\"number\">10</span>,<span class=\"number\">20</span>)</span><br><span class=\"line\">  $(<span class=\"string\">\"#sum\"</span>).html(sum)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、CMD-和-sea-js\"><a href=\"#三、CMD-和-sea-js\" class=\"headerlink\" title=\"三、CMD 和 sea.js\"></a>三、CMD 和 sea.js</h2><p>CMD: 延迟执行（运行到需加载，根据顺序执行）</p>\n<p>CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>\n<p>require.js 在申明依赖的模块时会在第一时间加载并执行模块内的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AMD 写法</span></span><br><span class=\"line\">define([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 即便没用到某个模块，但 b 还是提前执行了</span></span><br><span class=\"line\">      b.foo()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CMD 写法</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>) <span class=\"comment\">//在需要时申明</span></span><br><span class=\"line\"></span><br><span class=\"line\">  a.doSomething()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>)</span><br><span class=\"line\">      b.doSomething()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sea.js</span></span><br><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery.js'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  exports.add = add</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 加载模块</span></span><br><span class=\"line\">seajs.use([<span class=\"string\">'math.js'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = math.add(<span class=\"number\">1</span> + <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>四、ES6 Module</p>\n<p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; basicNum, add &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; basicNum, add &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./math'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">    ele.textContent = add(<span class=\"number\">99</span> + basicNum)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号。这也更趋近于ADM的引用写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export default</span></span><br><span class=\"line\"><span class=\"comment\">// 定义输出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123; basicNum, add &#125;</span><br><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> math <span class=\"keyword\">from</span> <span class=\"string\">'./math'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">    ele.textContent = math.add(<span class=\"number\">99</span> + math.basicNum)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6 的模块不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>\n<h2 id=\"五、ES6-模块与-CommonJS-模块的差异\"><a href=\"#五、ES6-模块与-CommonJS-模块的差异\" class=\"headerlink\" title=\"五、ES6 模块与 CommonJS 模块的差异\"></a>五、ES6 模块与 CommonJS 模块的差异</h2><ol>\n<li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>\n<ul>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n</li>\n<li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>\n<ul>\n<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n</li>\n</ol>\n<p>CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 <a href=\"https://note.youdao.com/\" target=\"_blank\" rel=\"noopener\">module-loader</a>。</p>","more":"<h2 id=\"一、CommonJS\"><a href=\"#一、CommonJS\" class=\"headerlink\" title=\"\b一、CommonJS\"></a>\b一、CommonJS</h2><p>Node.js 是 commonJS 规范的主要时间者，它有四个重要的环境变量为模块化的实现提供支持：<br><strong>module</strong>、\b<strong>exports</strong>、<strong>require</strong>、<strong>global</strong>。</p>\n<p>实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用exports），用 require 加载模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在这里写需要向外暴露的函数、变量</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  add,</span><br><span class=\"line\">  basicNum: basicNum,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用自定义的模块，参数包含路径，可省略 .js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'./math'</span>)</span><br><span class=\"line\">math.add(<span class=\"number\">2</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用核心模块时，不需要带路径</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</span><br><span class=\"line\">http.createService(...).listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>commonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>\n<h2 id=\"二、AMD-和-require-js\"><a href=\"#二、AMD-和-require-js\" class=\"headerlink\" title=\"二、AMD 和 require.js\"></a>二、AMD 和 require.js</h2><p>AMD: 提前执行（异步加载：依赖先执行 + 延迟执行）</p>\n<p>AMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。</p>\n<p>由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS，实际上  AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。</p>\n<p>\bAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行。</p>\n<p>这里介绍用 require.js 实现 AMD 规范的模块化：</p>\n<p>用 <strong>require.config()</strong> 指定引用路径，用 <strong>define()</strong> 定义模块，用 require() 加载模块</p>\n<p>首先我们需要引入 require.js 文件和一个入口文件 main.js。 main.js 中配置 require.config() 并规定项目中用到的基础模块。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 网页中引入 require.js 及 main.js</span></span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"js/require.js\"</span> data-main=<span class=\"string\">\"js/main\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js 入口文件/主模块</span></span><br><span class=\"line\"><span class=\"comment\">// 首先用 config() 指定各模块\b路径和引用名</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">  baseUrl: <span class=\"string\">'js/lib'</span>,</span><br><span class=\"line\">  paths: &#123;</span><br><span class=\"line\">    jquery: <span class=\"string\">'jquery.min'</span>,</span><br><span class=\"line\">    underscore: <span class=\"string\">'underscore.min'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行基本操作</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'jqery'</span>, <span class=\"string\">'underscore'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, _</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code here</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义math.js模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        add,</span><br><span class=\"line\">        basicNum :basicNum,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 定义一个依赖underscore.js的模块</span></span><br><span class=\"line\">define([<span class=\"string\">'underscore'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> classify = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>)</span>&#123;</span><br><span class=\"line\">    _.countBy(list,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> num &gt; <span class=\"number\">30</span> ? <span class=\"string\">'old'</span> : <span class=\"string\">'young'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    classify,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用模块，将模块放在[]内</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'jquery'</span>, <span class=\"string\">'math'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, math</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = math.add(<span class=\"number\">10</span>,<span class=\"number\">20</span>)</span><br><span class=\"line\">  $(<span class=\"string\">\"#sum\"</span>).html(sum)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、CMD-和-sea-js\"><a href=\"#三、CMD-和-sea-js\" class=\"headerlink\" title=\"三、CMD 和 sea.js\"></a>三、CMD 和 sea.js</h2><p>CMD: 延迟执行（运行到需加载，根据顺序执行）</p>\n<p>CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>\n<p>require.js 在申明依赖的模块时会在第一时间加载并执行模块内的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AMD 写法</span></span><br><span class=\"line\">define([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 即便没用到某个模块，但 b 还是提前执行了</span></span><br><span class=\"line\">      b.foo()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CMD 写法</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>) <span class=\"comment\">//在需要时申明</span></span><br><span class=\"line\"></span><br><span class=\"line\">  a.doSomething()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>)</span><br><span class=\"line\">      b.doSomething()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sea.js</span></span><br><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery.js'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  exports.add = add</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 加载模块</span></span><br><span class=\"line\">seajs.use([<span class=\"string\">'math.js'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = math.add(<span class=\"number\">1</span> + <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>四、ES6 Module</p>\n<p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; basicNum, add &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; basicNum, add &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./math'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">    ele.textContent = add(<span class=\"number\">99</span> + basicNum)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号。这也更趋近于ADM的引用写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export default</span></span><br><span class=\"line\"><span class=\"comment\">// 定义输出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123; basicNum, add &#125;</span><br><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> math <span class=\"keyword\">from</span> <span class=\"string\">'./math'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">    ele.textContent = math.add(<span class=\"number\">99</span> + math.basicNum)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6 的模块不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>\n<h2 id=\"五、ES6-模块与-CommonJS-模块的差异\"><a href=\"#五、ES6-模块与-CommonJS-模块的差异\" class=\"headerlink\" title=\"五、ES6 模块与 CommonJS 模块的差异\"></a>五、ES6 模块与 CommonJS 模块的差异</h2><ol>\n<li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>\n<ul>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n</li>\n<li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>\n<ul>\n<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n</li>\n</ol>\n<p>CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>"},{"title":"现代 JavaScript 与 CSS 滚动实现简析","date":"2018-06-18T09:20:13.000Z","_content":"\n## 页面滚动条引发的抖动出发\n\n为了实现简单的水平居中布局，我们没少使用 margin: 0 auto； 来实现。\n\n然而，这种布局一直存在一个影响用户体验的隐患。我们都知道，现代浏览器滚动条默认是 overflow: auto 类型的，也就是如果尺寸不足一屏，没有滚动条；超出，出现滚动条...\n\n那么，问题来了 -_- !\n\n首先是简单的信息流页面，是从上往下 push 渲染的，如果信息没有超出一屏，都很好说，但是如果超出，那么滚动条就会出现，自然\n margin: 0 auto; 主体元素就会做偏移，用户就会很明显感受到屏幕的抖动\n\n 其他场景，比如，点击加载更多，或者 Tab 切换到有滚动条的区块，都会感觉到抖动。\n\n 公司的 Web 产品一直存在这个问题，我个人觉得这个很影响体验，所以找了不少资料，也找了不少方案，在这里做一次总结。\n\n- 高度确认的，可以用 CSS 把页面尺寸布局骨架搭好，再往里面渲染数据。这样子的话，要么没有滚动条，要么数据直接出现，不会出现跳动，但是这样方式还是存在局限性\n- 还有一种简单粗暴的方式，直接设置 overflow: scroll，这就意味着，即使是在高度较小的时候，也会出现一个滚动条，而且貌似也不好看，存在的意义不明。\n\n经过查找，有一种方式，算是比较匹配我的需求\n\n使用 CSS3 计算 calc 和 vw 单位巧妙实现\n\n可以简单为容器设置样式：\n\n```css\n.wrap-outer {\n  margin-left: calc(100vw - 100%);\n}\n\n// 或者\n\n.wrap-outer {\n  padding-left: calc(100vw - 100%);\n}\n```\n\n100vw 相对于\b浏览器的 window.innerWidth ，是浏览器的内部宽度，这里包括了滚动条的宽度，而我们所使用的 100% 是不包含滚动条宽度的\n\n于是我们就可以愉快的实现不抖动的需求了\n\n兼容性方面的话，支持 IE9+ 以及其他现代浏览器\n\n## 消逝的滚动条\n\n既然讲到了滚动条，后面自己也查阅的不少资料，\b可以\b了解一些相关历史。\n\n![](https://static.skynian.cn/scroll-bar-2018618175358.png)\n\n（windows 上面的滚动条变化历程）\n\n![](https://static.skynian.cn/scroll-bar-2018618175513.png)\n\n（Mac 上面的滚动条）\n\n在这里大赞 Mac，从2011年开始，所有的滚动条均从 Mac 电脑消失，不再占据任何页面空间，只有用户触发滚动时才会重新出现，当然用户可以设置默认显示。\n\n对于开发者和设计师来说，这真的是一个好消息，毕竟计算滚动条的宽度总是不够优雅。\n\n可是！\b划重点！\n\n我们平时可能要使用各种各样的操作系统和浏览器，并且对滚动条的实现方式又各不同，所以我们还是不能避免这个问题......( 手动微笑脸 )\n\n## 滚动条宽度\n\n![](https://static.skynian.cn/scroll-bar-201861818333.png)\n\n（\b“百花齐放”的宽度）\n\n这里，笔者也是转载\b其他资料的数据，可能有些误差。\n\n但是只要记得一点，这是一个深坑......\n\n我们可以通过 JavaScript 来计算宽度（以下代码仅能测出原始的宽度，通过 CSS \b改变后，便不准了）\n\n```js\nconst outer = document.createElement('div')\nconst inner = document.createElement('div')\n\nouter.style.overflow = 'scroll'\ndocument.body.appendChild(outer)\nouter.appendChild(inner)\n\nconst scrollbarWidth = outer.offsetWidth - inner.offsetWidth\n\ndocument.body.removeChild(outer)\n```\n\n因为\b\b涉及到了操作 DOM，为了性能起见，应该避免这类操作\n\n\n\n","source":"_posts/scroll-bar.md","raw":"---\ntitle: 现代 JavaScript 与 CSS 滚动实现简析\ndate: 2018-06-18 17:20:13\ntags:\n  - JavaScript\n  - CSS\ncategories: 优化\n---\n\n## 页面滚动条引发的抖动出发\n\n为了实现简单的水平居中布局，我们没少使用 margin: 0 auto； 来实现。\n\n然而，这种布局一直存在一个影响用户体验的隐患。我们都知道，现代浏览器滚动条默认是 overflow: auto 类型的，也就是如果尺寸不足一屏，没有滚动条；超出，出现滚动条...\n\n那么，问题来了 -_- !\n\n首先是简单的信息流页面，是从上往下 push 渲染的，如果信息没有超出一屏，都很好说，但是如果超出，那么滚动条就会出现，自然\n margin: 0 auto; 主体元素就会做偏移，用户就会很明显感受到屏幕的抖动\n\n 其他场景，比如，点击加载更多，或者 Tab 切换到有滚动条的区块，都会感觉到抖动。\n\n 公司的 Web 产品一直存在这个问题，我个人觉得这个很影响体验，所以找了不少资料，也找了不少方案，在这里做一次总结。\n\n- 高度确认的，可以用 CSS 把页面尺寸布局骨架搭好，再往里面渲染数据。这样子的话，要么没有滚动条，要么数据直接出现，不会出现跳动，但是这样方式还是存在局限性\n- 还有一种简单粗暴的方式，直接设置 overflow: scroll，这就意味着，即使是在高度较小的时候，也会出现一个滚动条，而且貌似也不好看，存在的意义不明。\n\n经过查找，有一种方式，算是比较匹配我的需求\n\n使用 CSS3 计算 calc 和 vw 单位巧妙实现\n\n可以简单为容器设置样式：\n\n```css\n.wrap-outer {\n  margin-left: calc(100vw - 100%);\n}\n\n// 或者\n\n.wrap-outer {\n  padding-left: calc(100vw - 100%);\n}\n```\n\n100vw 相对于\b浏览器的 window.innerWidth ，是浏览器的内部宽度，这里包括了滚动条的宽度，而我们所使用的 100% 是不包含滚动条宽度的\n\n于是我们就可以愉快的实现不抖动的需求了\n\n兼容性方面的话，支持 IE9+ 以及其他现代浏览器\n\n## 消逝的滚动条\n\n既然讲到了滚动条，后面自己也查阅的不少资料，\b可以\b了解一些相关历史。\n\n![](https://static.skynian.cn/scroll-bar-2018618175358.png)\n\n（windows 上面的滚动条变化历程）\n\n![](https://static.skynian.cn/scroll-bar-2018618175513.png)\n\n（Mac 上面的滚动条）\n\n在这里大赞 Mac，从2011年开始，所有的滚动条均从 Mac 电脑消失，不再占据任何页面空间，只有用户触发滚动时才会重新出现，当然用户可以设置默认显示。\n\n对于开发者和设计师来说，这真的是一个好消息，毕竟计算滚动条的宽度总是不够优雅。\n\n可是！\b划重点！\n\n我们平时可能要使用各种各样的操作系统和浏览器，并且对滚动条的实现方式又各不同，所以我们还是不能避免这个问题......( 手动微笑脸 )\n\n## 滚动条宽度\n\n![](https://static.skynian.cn/scroll-bar-201861818333.png)\n\n（\b“百花齐放”的宽度）\n\n这里，笔者也是转载\b其他资料的数据，可能有些误差。\n\n但是只要记得一点，这是一个深坑......\n\n我们可以通过 JavaScript 来计算宽度（以下代码仅能测出原始的宽度，通过 CSS \b改变后，便不准了）\n\n```js\nconst outer = document.createElement('div')\nconst inner = document.createElement('div')\n\nouter.style.overflow = 'scroll'\ndocument.body.appendChild(outer)\nouter.appendChild(inner)\n\nconst scrollbarWidth = outer.offsetWidth - inner.offsetWidth\n\ndocument.body.removeChild(outer)\n```\n\n因为\b\b涉及到了操作 DOM，为了性能起见，应该避免这类操作\n\n\n\n","slug":"scroll-bar","published":1,"updated":"2018-06-18T10:13:08.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprk0v000ievfy3bnwrkau","content":"<h2 id=\"页面滚动条引发的抖动出发\"><a href=\"#页面滚动条引发的抖动出发\" class=\"headerlink\" title=\"页面滚动条引发的抖动出发\"></a>页面滚动条引发的抖动出发</h2><p>为了实现简单的水平居中布局，我们没少使用 margin: 0 auto； 来实现。</p>\n<p>然而，这种布局一直存在一个影响用户体验的隐患。我们都知道，现代浏览器滚动条默认是 overflow: auto 类型的，也就是如果尺寸不足一屏，没有滚动条；超出，出现滚动条…</p>\n<p>那么，问题来了 -_- !</p>\n<p>首先是简单的信息流页面，是从上往下 push 渲染的，如果信息没有超出一屏，都很好说，但是如果超出，那么滚动条就会出现，自然<br> margin: 0 auto; 主体元素就会做偏移，用户就会很明显感受到屏幕的抖动</p>\n<p> 其他场景，比如，点击加载更多，或者 Tab 切换到有滚动条的区块，都会感觉到抖动。</p>\n<p> 公司的 Web 产品一直存在这个问题，我个人觉得这个很影响体验，所以找了不少资料，也找了不少方案，在这里做一次总结。</p>\n<ul>\n<li>高度确认的，可以用 CSS 把页面尺寸布局骨架搭好，再往里面渲染数据。这样子的话，要么没有滚动条，要么数据直接出现，不会出现跳动，但是这样方式还是存在局限性</li>\n<li>还有一种简单粗暴的方式，直接设置 overflow: scroll，这就意味着，即使是在高度较小的时候，也会出现一个滚动条，而且貌似也不好看，存在的意义不明。</li>\n</ul>\n<p>经过查找，有一种方式，算是比较匹配我的需求</p>\n<p>使用 CSS3 计算 calc 和 vw 单位巧妙实现</p>\n<p>可以简单为容器设置样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap-outer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"built_in\">calc</span>(100vw - 100%);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.wrap-outer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-left</span>: <span class=\"built_in\">calc</span>(100vw - 100%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>100vw 相对于\b浏览器的 window.innerWidth ，是浏览器的内部宽度，这里包括了滚动条的宽度，而我们所使用的 100% 是不包含滚动条宽度的</p>\n<p>于是我们就可以愉快的实现不抖动的需求了</p>\n<p>兼容性方面的话，支持 IE9+ 以及其他现代浏览器</p>\n<h2 id=\"消逝的滚动条\"><a href=\"#消逝的滚动条\" class=\"headerlink\" title=\"消逝的滚动条\"></a>消逝的滚动条</h2><p>既然讲到了滚动条，后面自己也查阅的不少资料，\b可以\b了解一些相关历史。</p>\n<p><img src=\"https://static.skynian.cn/scroll-bar-2018618175358.png\" alt=\"\"></p>\n<p>（windows 上面的滚动条变化历程）</p>\n<p><img src=\"https://static.skynian.cn/scroll-bar-2018618175513.png\" alt=\"\"></p>\n<p>（Mac 上面的滚动条）</p>\n<p>在这里大赞 Mac，从2011年开始，所有的滚动条均从 Mac 电脑消失，不再占据任何页面空间，只有用户触发滚动时才会重新出现，当然用户可以设置默认显示。</p>\n<p>对于开发者和设计师来说，这真的是一个好消息，毕竟计算滚动条的宽度总是不够优雅。</p>\n<p>可是！\b划重点！</p>\n<p>我们平时可能要使用各种各样的操作系统和浏览器，并且对滚动条的实现方式又各不同，所以我们还是不能避免这个问题……( 手动微笑脸 )</p>\n<h2 id=\"滚动条宽度\"><a href=\"#滚动条宽度\" class=\"headerlink\" title=\"滚动条宽度\"></a>滚动条宽度</h2><p><img src=\"https://static.skynian.cn/scroll-bar-201861818333.png\" alt=\"\"></p>\n<p>（\b“百花齐放”的宽度）</p>\n<p>这里，笔者也是转载\b其他资料的数据，可能有些误差。</p>\n<p>但是只要记得一点，这是一个深坑……</p>\n<p>我们可以通过 JavaScript 来计算宽度（以下代码仅能测出原始的宽度，通过 CSS \b改变后，便不准了）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> outer = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> inner = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">outer.style.overflow = <span class=\"string\">'scroll'</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(outer)</span><br><span class=\"line\">outer.appendChild(inner)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> scrollbarWidth = outer.offsetWidth - inner.offsetWidth</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.removeChild(outer)</span><br></pre></td></tr></table></figure>\n<p>因为\b\b涉及到了操作 DOM，为了性能起见，应该避免这类操作</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h2 id=\"页面滚动条引发的抖动出发\"><a href=\"#页面滚动条引发的抖动出发\" class=\"headerlink\" title=\"页面滚动条引发的抖动出发\"></a>页面滚动条引发的抖动出发</h2><p>为了实现简单的水平居中布局，我们没少使用 margin: 0 auto； 来实现。</p>\n<p>然而，这种布局一直存在一个影响用户体验的隐患。我们都知道，现代浏览器滚动条默认是 overflow: auto 类型的，也就是如果尺寸不足一屏，没有滚动条；超出，出现滚动条…</p>\n<p>那么，问题来了 -_- !</p>\n<p>首先是简单的信息流页面，是从上往下 push 渲染的，如果信息没有超出一屏，都很好说，但是如果超出，那么滚动条就会出现，自然<br> margin: 0 auto; 主体元素就会做偏移，用户就会很明显感受到屏幕的抖动</p>\n<p> 其他场景，比如，点击加载更多，或者 Tab 切换到有滚动条的区块，都会感觉到抖动。</p>\n<p> 公司的 Web 产品一直存在这个问题，我个人觉得这个很影响体验，所以找了不少资料，也找了不少方案，在这里做一次总结。</p>\n<ul>\n<li>高度确认的，可以用 CSS 把页面尺寸布局骨架搭好，再往里面渲染数据。这样子的话，要么没有滚动条，要么数据直接出现，不会出现跳动，但是这样方式还是存在局限性</li>\n<li>还有一种简单粗暴的方式，直接设置 overflow: scroll，这就意味着，即使是在高度较小的时候，也会出现一个滚动条，而且貌似也不好看，存在的意义不明。</li>\n</ul>\n<p>经过查找，有一种方式，算是比较匹配我的需求</p>\n<p>使用 CSS3 计算 calc 和 vw 单位巧妙实现</p>\n<p>可以简单为容器设置样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap-outer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"built_in\">calc</span>(100vw - 100%);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.wrap-outer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-left</span>: <span class=\"built_in\">calc</span>(100vw - 100%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>100vw 相对于\b浏览器的 window.innerWidth ，是浏览器的内部宽度，这里包括了滚动条的宽度，而我们所使用的 100% 是不包含滚动条宽度的</p>\n<p>于是我们就可以愉快的实现不抖动的需求了</p>\n<p>兼容性方面的话，支持 IE9+ 以及其他现代浏览器</p>\n<h2 id=\"消逝的滚动条\"><a href=\"#消逝的滚动条\" class=\"headerlink\" title=\"消逝的滚动条\"></a>消逝的滚动条</h2><p>既然讲到了滚动条，后面自己也查阅的不少资料，\b可以\b了解一些相关历史。</p>\n<p><img src=\"https://static.skynian.cn/scroll-bar-2018618175358.png\" alt=\"\"></p>\n<p>（windows 上面的滚动条变化历程）</p>\n<p><img src=\"https://static.skynian.cn/scroll-bar-2018618175513.png\" alt=\"\"></p>\n<p>（Mac 上面的滚动条）</p>\n<p>在这里大赞 Mac，从2011年开始，所有的滚动条均从 Mac 电脑消失，不再占据任何页面空间，只有用户触发滚动时才会重新出现，当然用户可以设置默认显示。</p>\n<p>对于开发者和设计师来说，这真的是一个好消息，毕竟计算滚动条的宽度总是不够优雅。</p>\n<p>可是！\b划重点！</p>\n<p>我们平时可能要使用各种各样的操作系统和浏览器，并且对滚动条的实现方式又各不同，所以我们还是不能避免这个问题……( 手动微笑脸 )</p>\n<h2 id=\"滚动条宽度\"><a href=\"#滚动条宽度\" class=\"headerlink\" title=\"滚动条宽度\"></a>滚动条宽度</h2><p><img src=\"https://static.skynian.cn/scroll-bar-201861818333.png\" alt=\"\"></p>\n<p>（\b“百花齐放”的宽度）</p>\n<p>这里，笔者也是转载\b其他资料的数据，可能有些误差。</p>\n<p>但是只要记得一点，这是一个深坑……</p>\n<p>我们可以通过 JavaScript 来计算宽度（以下代码仅能测出原始的宽度，通过 CSS \b改变后，便不准了）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> outer = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> inner = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">outer.style.overflow = <span class=\"string\">'scroll'</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(outer)</span><br><span class=\"line\">outer.appendChild(inner)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> scrollbarWidth = outer.offsetWidth - inner.offsetWidth</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.removeChild(outer)</span><br></pre></td></tr></table></figure>\n<p>因为\b\b涉及到了操作 DOM，为了性能起见，应该避免这类操作</p>\n"},{"title":"深入理解this","date":"2018-06-11T12:53:06.000Z","_content":"\n![](https://static.skynian.cn/深入理解this-201861122106.jpg)\n\nJavaScript 中 this 的指向一直是困扰我很久的问题，在使用中出错的机率也非常大。在面向对象语言中，它代表了当前对象的一个引用，而在 JS 中却经常让我觉得混乱，它不是固定不变的，而是随着它的执行环境的改变而改变。\n\n<!--more-->\n\n如果没有\b彻底理解\b和掌握这个特性，可能真的会一次又一次\b\b踩坑，不要问我是怎么知道的o(╯□╰)o\n\n可能this不是JS中最复杂的内容，但是它的细节也是蔚为大观。涉及到了函数、函数调用、eval、call/apply/bind、基本包装类型、构造函数实例化、严格模式等等。\n\n\b与此同时ES6引入的箭头函数和\bclass更是把this复杂化了。\n\n其实网上关于this的介绍和总结很多，但是不乏会有很多错漏的地方，笔者\b写这篇博客也是为了做一次总结，同时巩固，更重要的是希望能出坑......\n\n\b\b一个最基本的认知是，this的值会发生变化，但是有一个总的原则，那就是this指向的是调用函数的那个对象。\n\n## 情况\b一：纯粹的函数调用\n\n这是函数的最通常用法，属于全局性调用，因此this就代表着全局对象Global\n\n```js\nfunction func1() {\n  console.log(this === window) // true\n}\nfunc1()\n\nconst func2 = function() {\n  console.log(this === window) // true\n}\nfunc2()\n\nfunction func3() {\n  \"use strict\"\n  console.log(this) // undefined\n}\n```\n\n从上述代码中，我们可以看出，如果不是处于严格模式下，函数的上下文是window对象，严格模式下，函数上下文为undefined。\n\n## 情况二：作为对象方法的调用\n\n函数还可以作为某个对象方法调用，这时this就指这个上级对象\n\n```js\nfunction test() {\n  alert(this.x)\n}\n\nle o = {}\no.x = 1\no.m = test\no.m() // 1\n```\n\n其实，我们这时返回看情况一，实际上可以看出”func1()“，可以理解为“window.func1()”，所以例子中的函数上下文便是this。\n\n## 情况三： 作为构造函数调用\n\n所谓构造函数，\b也就是通过这个函数生成一个新对象（object）。这个时候，this就是指这个新对象。\n\n```js\nfunction test(){\n  this.x = 1\n}\n\nlet o = new test()\nlaert(o.x) // 1\n```\n\n运行结果为1，为了表明这时this对象不是全局对象，我对代码做一点改变：\n\n```js\nlet x = 2\n\nfunction test() {\n  this.x = 1\n}\n\nlet o = new test()\n\nalert(x) // 2\n```\n\n## 情况四： 使用apply()和call()方法进行调用\n\n\bapply()和call()是函数对象中的方法，它的作用是改变函数的调用对象，可以利用任何一个函数都可以显式指定任何一个对象作为其函数上下文。\n\n通过 apply() 方法来调用函数，我们要给 apply() 传入两个参数：一个作为函数上下文对象，另一个作为函数参数所组成的数组。call() 方法的使用方式类似，唯一不同的是给函数传入的参数是一个参数列表，而不是单个数组。\n\n```js\nfunction func() {\n    let result = 0;\n    for(let i = 0; i < arguments.length; i++) {\n        result += arguments[i];\n    }\n    this.result = result;\n}\nconst obj1 = {};\nconst obj2 = {};\nfunc.apply(obj1, [1, 2, 3]);\nfunc.call(obj2, 4, 5, 6);\n\nconsole.log(obj1.result === 6); // true\nconsole.log(obj2.result === 15); // true\n```\n\n在上面的代码中，`func.apply(obj1, [1, 2, 3]);` 将函数的上下文定义为 obj1，并且传入 1、2、3 三个参数，`func.call(obj2, 4, 5, 6);` 将函数的上下文定义为 obj2，并且传入 4、5、6 三个参数。\n\n那 apply 和 call 基本相同，那么我们该用哪一个呢？其实 apply 和 call 的区别仅仅在于调用时传入的参数不同，其他完全一样。所以，在选择时，主要看传入的参数。如果已知参数已经在数组里了则用 apply 即可，或者参数是动态生成的，可以把参数 push 进一个数组，然后再用 apply 调用。当参数数量已知，或者在参数里有很多无关的值则用 call 方法调用。\n\n## ES6 与 this\n\nES6 中引入了一个很棒的特性：箭头函数。说其棒，主要源于其书写简单，更重要的是其使得 this 更易于理解。\n\nES6 中，箭头函数中始终会捕捉其所在上下文的 this 值，作为自己的 this。这一点非常重要，省去了我们很多的麻烦。但对于那些习惯了每个 function 中都有自己 this 的人来说，可能还有些不习惯。举个例子吧，就拿调用方式 2 中的例子。\n\n```js\nconst obj = {\n    func: () => {\n        console.log(this === window); // true，非箭头函数时指向 obj\n    }\n};\nobj.func();\n```\n\n在上面的例子中，func 所在上下文的 this 值指向 window，而 func 是一个箭头函数，所以其里面的 this 会捕捉其所在上下文的 this 作为自己的 this， 所以 func 内的 this 也指向 window 对象。\n\n## 其他补充\n\n> 利用 bind() 改变函数上下文\n\n```js\nconst obj1 = {\n    a: 1\n};\nconst obj2 = {\n    a: 2,\n    func: function() {\n        console.log(this.a);\n    }.bind(obj1)\n};\nobj2.func(); // 1\n```\n\nECMAScript 5 引入了 `Function.prototype.bind`，其会创建一个绑定函数，当调用这个绑定函数时，函数上下文将会是 bind() 方法的第一个参数。上面的例子中，将 obj1 设置为函数上下文，所以利用 func 来调用函数时，函数的上下文为 obj1，而不是它的调用者 obj2。\n\n\n利用 Array 的 5 个方法改变函数上下文\n\n5 个方法分别是：\n\n`Array.prototype.every(callbackfn [, thisArg ])`\n`Array.prototype.some(callbackfn [, thisArg ])`\n`Array.prototype.forEach(callbackfn [, thisArg ])`\n`Array.prototype.map(callbackfn [, thisArg ])`\n`Array.prototype.filter(callbackfn [, thisArg ])`\n\n\n当调用以上 5 个方法时，传入的参数除了回调函数以外，还可以传入另外一个可选地参数，即函数上下文，代表回调函数中的函数上下文。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。看下面的例子：\n\n```js\nconst arr = [\"segmentfault\"];\nconst obj = {};\narr.forEach(function(ele, ind) {\n    console.log(this === window); // true\n});\narr.forEach(function(ele, ind) {\n    console.log(this === obj);    // true\n}, obj);\n```\n\n## 测试\n\n```js\nif (true) {\n    // this\n}\n```\n\n```js\nconst obj = {\n    someData: \"a string\"\n};\nfunction myFun() {\n    // this\n}\nobj.staticFunction = myFun;\nobj.staticFunction();\n```\n\n```js\nconst obj = {\n    myMethod : function () {\n        // this\n    }\n};\nconst myFun = obj.myMethod;\nmyFun();\n```\n\n```js\nfunction myFun() {\n    // this\n}\nconst obj = {\n    someData: \"a string\"\n};\nmyFun.call(obj);\n```\n\n答案：\n\nwindow\n\nobj\n\nwindow\n\nobj","source":"_posts/this.md","raw":"---\ntitle: 深入理解this\ndate: 2018-06-11 20:53:06\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\n![](https://static.skynian.cn/深入理解this-201861122106.jpg)\n\nJavaScript 中 this 的指向一直是困扰我很久的问题，在使用中出错的机率也非常大。在面向对象语言中，它代表了当前对象的一个引用，而在 JS 中却经常让我觉得混乱，它不是固定不变的，而是随着它的执行环境的改变而改变。\n\n<!--more-->\n\n如果没有\b彻底理解\b和掌握这个特性，可能真的会一次又一次\b\b踩坑，不要问我是怎么知道的o(╯□╰)o\n\n可能this不是JS中最复杂的内容，但是它的细节也是蔚为大观。涉及到了函数、函数调用、eval、call/apply/bind、基本包装类型、构造函数实例化、严格模式等等。\n\n\b与此同时ES6引入的箭头函数和\bclass更是把this复杂化了。\n\n其实网上关于this的介绍和总结很多，但是不乏会有很多错漏的地方，笔者\b写这篇博客也是为了做一次总结，同时巩固，更重要的是希望能出坑......\n\n\b\b一个最基本的认知是，this的值会发生变化，但是有一个总的原则，那就是this指向的是调用函数的那个对象。\n\n## 情况\b一：纯粹的函数调用\n\n这是函数的最通常用法，属于全局性调用，因此this就代表着全局对象Global\n\n```js\nfunction func1() {\n  console.log(this === window) // true\n}\nfunc1()\n\nconst func2 = function() {\n  console.log(this === window) // true\n}\nfunc2()\n\nfunction func3() {\n  \"use strict\"\n  console.log(this) // undefined\n}\n```\n\n从上述代码中，我们可以看出，如果不是处于严格模式下，函数的上下文是window对象，严格模式下，函数上下文为undefined。\n\n## 情况二：作为对象方法的调用\n\n函数还可以作为某个对象方法调用，这时this就指这个上级对象\n\n```js\nfunction test() {\n  alert(this.x)\n}\n\nle o = {}\no.x = 1\no.m = test\no.m() // 1\n```\n\n其实，我们这时返回看情况一，实际上可以看出”func1()“，可以理解为“window.func1()”，所以例子中的函数上下文便是this。\n\n## 情况三： 作为构造函数调用\n\n所谓构造函数，\b也就是通过这个函数生成一个新对象（object）。这个时候，this就是指这个新对象。\n\n```js\nfunction test(){\n  this.x = 1\n}\n\nlet o = new test()\nlaert(o.x) // 1\n```\n\n运行结果为1，为了表明这时this对象不是全局对象，我对代码做一点改变：\n\n```js\nlet x = 2\n\nfunction test() {\n  this.x = 1\n}\n\nlet o = new test()\n\nalert(x) // 2\n```\n\n## 情况四： 使用apply()和call()方法进行调用\n\n\bapply()和call()是函数对象中的方法，它的作用是改变函数的调用对象，可以利用任何一个函数都可以显式指定任何一个对象作为其函数上下文。\n\n通过 apply() 方法来调用函数，我们要给 apply() 传入两个参数：一个作为函数上下文对象，另一个作为函数参数所组成的数组。call() 方法的使用方式类似，唯一不同的是给函数传入的参数是一个参数列表，而不是单个数组。\n\n```js\nfunction func() {\n    let result = 0;\n    for(let i = 0; i < arguments.length; i++) {\n        result += arguments[i];\n    }\n    this.result = result;\n}\nconst obj1 = {};\nconst obj2 = {};\nfunc.apply(obj1, [1, 2, 3]);\nfunc.call(obj2, 4, 5, 6);\n\nconsole.log(obj1.result === 6); // true\nconsole.log(obj2.result === 15); // true\n```\n\n在上面的代码中，`func.apply(obj1, [1, 2, 3]);` 将函数的上下文定义为 obj1，并且传入 1、2、3 三个参数，`func.call(obj2, 4, 5, 6);` 将函数的上下文定义为 obj2，并且传入 4、5、6 三个参数。\n\n那 apply 和 call 基本相同，那么我们该用哪一个呢？其实 apply 和 call 的区别仅仅在于调用时传入的参数不同，其他完全一样。所以，在选择时，主要看传入的参数。如果已知参数已经在数组里了则用 apply 即可，或者参数是动态生成的，可以把参数 push 进一个数组，然后再用 apply 调用。当参数数量已知，或者在参数里有很多无关的值则用 call 方法调用。\n\n## ES6 与 this\n\nES6 中引入了一个很棒的特性：箭头函数。说其棒，主要源于其书写简单，更重要的是其使得 this 更易于理解。\n\nES6 中，箭头函数中始终会捕捉其所在上下文的 this 值，作为自己的 this。这一点非常重要，省去了我们很多的麻烦。但对于那些习惯了每个 function 中都有自己 this 的人来说，可能还有些不习惯。举个例子吧，就拿调用方式 2 中的例子。\n\n```js\nconst obj = {\n    func: () => {\n        console.log(this === window); // true，非箭头函数时指向 obj\n    }\n};\nobj.func();\n```\n\n在上面的例子中，func 所在上下文的 this 值指向 window，而 func 是一个箭头函数，所以其里面的 this 会捕捉其所在上下文的 this 作为自己的 this， 所以 func 内的 this 也指向 window 对象。\n\n## 其他补充\n\n> 利用 bind() 改变函数上下文\n\n```js\nconst obj1 = {\n    a: 1\n};\nconst obj2 = {\n    a: 2,\n    func: function() {\n        console.log(this.a);\n    }.bind(obj1)\n};\nobj2.func(); // 1\n```\n\nECMAScript 5 引入了 `Function.prototype.bind`，其会创建一个绑定函数，当调用这个绑定函数时，函数上下文将会是 bind() 方法的第一个参数。上面的例子中，将 obj1 设置为函数上下文，所以利用 func 来调用函数时，函数的上下文为 obj1，而不是它的调用者 obj2。\n\n\n利用 Array 的 5 个方法改变函数上下文\n\n5 个方法分别是：\n\n`Array.prototype.every(callbackfn [, thisArg ])`\n`Array.prototype.some(callbackfn [, thisArg ])`\n`Array.prototype.forEach(callbackfn [, thisArg ])`\n`Array.prototype.map(callbackfn [, thisArg ])`\n`Array.prototype.filter(callbackfn [, thisArg ])`\n\n\n当调用以上 5 个方法时，传入的参数除了回调函数以外，还可以传入另外一个可选地参数，即函数上下文，代表回调函数中的函数上下文。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。看下面的例子：\n\n```js\nconst arr = [\"segmentfault\"];\nconst obj = {};\narr.forEach(function(ele, ind) {\n    console.log(this === window); // true\n});\narr.forEach(function(ele, ind) {\n    console.log(this === obj);    // true\n}, obj);\n```\n\n## 测试\n\n```js\nif (true) {\n    // this\n}\n```\n\n```js\nconst obj = {\n    someData: \"a string\"\n};\nfunction myFun() {\n    // this\n}\nobj.staticFunction = myFun;\nobj.staticFunction();\n```\n\n```js\nconst obj = {\n    myMethod : function () {\n        // this\n    }\n};\nconst myFun = obj.myMethod;\nmyFun();\n```\n\n```js\nfunction myFun() {\n    // this\n}\nconst obj = {\n    someData: \"a string\"\n};\nmyFun.call(obj);\n```\n\n答案：\n\nwindow\n\nobj\n\nwindow\n\nobj","slug":"this","published":1,"updated":"2018-06-13T16:19:32.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiyprk0y000levfyclewv0tt","content":"<p><img src=\"https://static.skynian.cn/深入理解this-201861122106.jpg\" alt=\"\"></p>\n<p>JavaScript 中 this 的指向一直是困扰我很久的问题，在使用中出错的机率也非常大。在面向对象语言中，它代表了当前对象的一个引用，而在 JS 中却经常让我觉得混乱，它不是固定不变的，而是随着它的执行环境的改变而改变。</p>\n<a id=\"more\"></a>\n<p>如果没有\b彻底理解\b和掌握这个特性，可能真的会一次又一次\b\b踩坑，不要问我是怎么知道的o(╯□╰)o</p>\n<p>可能this不是JS中最复杂的内容，但是它的细节也是蔚为大观。涉及到了函数、函数调用、eval、call/apply/bind、基本包装类型、构造函数实例化、严格模式等等。</p>\n<p>\b与此同时ES6引入的箭头函数和\bclass更是把this复杂化了。</p>\n<p>其实网上关于this的介绍和总结很多，但是不乏会有很多错漏的地方，笔者\b写这篇博客也是为了做一次总结，同时巩固，更重要的是希望能出坑……</p>\n<p>\b\b一个最基本的认知是，this的值会发生变化，但是有一个总的原则，那就是this指向的是调用函数的那个对象。</p>\n<h2 id=\"情况一：纯粹的函数调用\"><a href=\"#情况一：纯粹的函数调用\" class=\"headerlink\" title=\"情况\b一：纯粹的函数调用\"></a>情况\b一：纯粹的函数调用</h2><p>这是函数的最通常用法，属于全局性调用，因此this就代表着全局对象Global</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> func2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码中，我们可以看出，如果不是处于严格模式下，函数的上下文是window对象，严格模式下，函数上下文为undefined。</p>\n<h2 id=\"情况二：作为对象方法的调用\"><a href=\"#情况二：作为对象方法的调用\" class=\"headerlink\" title=\"情况二：作为对象方法的调用\"></a>情况二：作为对象方法的调用</h2><p>函数还可以作为某个对象方法调用，这时this就指这个上级对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">le o = &#123;&#125;</span><br><span class=\"line\">o.x = <span class=\"number\">1</span></span><br><span class=\"line\">o.m = test</span><br><span class=\"line\">o.m() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>其实，我们这时返回看情况一，实际上可以看出”func1()“，可以理解为“window.func1()”，所以例子中的函数上下文便是this。</p>\n<h2 id=\"情况三：-作为构造函数调用\"><a href=\"#情况三：-作为构造函数调用\" class=\"headerlink\" title=\"情况三： 作为构造函数调用\"></a>情况三： 作为构造函数调用</h2><p>所谓构造函数，\b也就是通过这个函数生成一个新对象（object）。这个时候，this就是指这个新对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> test()</span><br><span class=\"line\">laert(o.x) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>运行结果为1，为了表明这时this对象不是全局对象，我对代码做一点改变：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> test()</span><br><span class=\"line\"></span><br><span class=\"line\">alert(x) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"情况四：-使用apply-和call-方法进行调用\"><a href=\"#情况四：-使用apply-和call-方法进行调用\" class=\"headerlink\" title=\"情况四： 使用apply()和call()方法进行调用\"></a>情况四： 使用apply()和call()方法进行调用</h2><p>\bapply()和call()是函数对象中的方法，它的作用是改变函数的调用对象，可以利用任何一个函数都可以显式指定任何一个对象作为其函数上下文。</p>\n<p>通过 apply() 方法来调用函数，我们要给 apply() 传入两个参数：一个作为函数上下文对象，另一个作为函数参数所组成的数组。call() 方法的使用方式类似，唯一不同的是给函数传入的参数是一个参数列表，而不是单个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">        result += <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;;</span><br><span class=\"line\">func.apply(obj1, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">func.call(obj2, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.result === <span class=\"number\">6</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.result === <span class=\"number\">15</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，<code>func.apply(obj1, [1, 2, 3]);</code> 将函数的上下文定义为 obj1，并且传入 1、2、3 三个参数，<code>func.call(obj2, 4, 5, 6);</code> 将函数的上下文定义为 obj2，并且传入 4、5、6 三个参数。</p>\n<p>那 apply 和 call 基本相同，那么我们该用哪一个呢？其实 apply 和 call 的区别仅仅在于调用时传入的参数不同，其他完全一样。所以，在选择时，主要看传入的参数。如果已知参数已经在数组里了则用 apply 即可，或者参数是动态生成的，可以把参数 push 进一个数组，然后再用 apply 调用。当参数数量已知，或者在参数里有很多无关的值则用 call 方法调用。</p>\n<h2 id=\"ES6-与-this\"><a href=\"#ES6-与-this\" class=\"headerlink\" title=\"ES6 与 this\"></a>ES6 与 this</h2><p>ES6 中引入了一个很棒的特性：箭头函数。说其棒，主要源于其书写简单，更重要的是其使得 this 更易于理解。</p>\n<p>ES6 中，箭头函数中始终会捕捉其所在上下文的 this 值，作为自己的 this。这一点非常重要，省去了我们很多的麻烦。但对于那些习惯了每个 function 中都有自己 this 的人来说，可能还有些不习惯。举个例子吧，就拿调用方式 2 中的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true，非箭头函数时指向 obj</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.func();</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，func 所在上下文的 this 值指向 window，而 func 是一个箭头函数，所以其里面的 this 会捕捉其所在上下文的 this 作为自己的 this， 所以 func 内的 this 也指向 window 对象。</p>\n<h2 id=\"其他补充\"><a href=\"#其他补充\" class=\"headerlink\" title=\"其他补充\"></a>其他补充</h2><blockquote>\n<p>利用 bind() 改变函数上下文</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">    &#125;.bind(obj1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj2.func(); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>，其会创建一个绑定函数，当调用这个绑定函数时，函数上下文将会是 bind() 方法的第一个参数。上面的例子中，将 obj1 设置为函数上下文，所以利用 func 来调用函数时，函数的上下文为 obj1，而不是它的调用者 obj2。</p>\n<p>利用 Array 的 5 个方法改变函数上下文</p>\n<p>5 个方法分别是：</p>\n<p><code>Array.prototype.every(callbackfn [, thisArg ])</code><br><code>Array.prototype.some(callbackfn [, thisArg ])</code><br><code>Array.prototype.forEach(callbackfn [, thisArg ])</code><br><code>Array.prototype.map(callbackfn [, thisArg ])</code><br><code>Array.prototype.filter(callbackfn [, thisArg ])</code></p>\n<p>当调用以上 5 个方法时，传入的参数除了回调函数以外，还可以传入另外一个可选地参数，即函数上下文，代表回调函数中的函数上下文。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">\"segmentfault\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, ind</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, ind</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);    <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;, obj);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    someData: <span class=\"string\">\"a string\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.staticFunction = myFun;</span><br><span class=\"line\">obj.staticFunction();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    myMethod : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myFun = obj.myMethod;</span><br><span class=\"line\">myFun();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    someData: <span class=\"string\">\"a string\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myFun.call(obj);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<p>window</p>\n<p>obj</p>\n<p>window</p>\n<p>obj</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"9bda50d8ad09c691b013c21b520dea45","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p><img src=\"https://static.skynian.cn/深入理解this-201861122106.jpg\" alt=\"\"></p>\n<p>JavaScript 中 this 的指向一直是困扰我很久的问题，在使用中出错的机率也非常大。在面向对象语言中，它代表了当前对象的一个引用，而在 JS 中却经常让我觉得混乱，它不是固定不变的，而是随着它的执行环境的改变而改变。</p>","more":"<p>如果没有\b彻底理解\b和掌握这个特性，可能真的会一次又一次\b\b踩坑，不要问我是怎么知道的o(╯□╰)o</p>\n<p>可能this不是JS中最复杂的内容，但是它的细节也是蔚为大观。涉及到了函数、函数调用、eval、call/apply/bind、基本包装类型、构造函数实例化、严格模式等等。</p>\n<p>\b与此同时ES6引入的箭头函数和\bclass更是把this复杂化了。</p>\n<p>其实网上关于this的介绍和总结很多，但是不乏会有很多错漏的地方，笔者\b写这篇博客也是为了做一次总结，同时巩固，更重要的是希望能出坑……</p>\n<p>\b\b一个最基本的认知是，this的值会发生变化，但是有一个总的原则，那就是this指向的是调用函数的那个对象。</p>\n<h2 id=\"情况一：纯粹的函数调用\"><a href=\"#情况一：纯粹的函数调用\" class=\"headerlink\" title=\"情况\b一：纯粹的函数调用\"></a>情况\b一：纯粹的函数调用</h2><p>这是函数的最通常用法，属于全局性调用，因此this就代表着全局对象Global</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> func2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码中，我们可以看出，如果不是处于严格模式下，函数的上下文是window对象，严格模式下，函数上下文为undefined。</p>\n<h2 id=\"情况二：作为对象方法的调用\"><a href=\"#情况二：作为对象方法的调用\" class=\"headerlink\" title=\"情况二：作为对象方法的调用\"></a>情况二：作为对象方法的调用</h2><p>函数还可以作为某个对象方法调用，这时this就指这个上级对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">le o = &#123;&#125;</span><br><span class=\"line\">o.x = <span class=\"number\">1</span></span><br><span class=\"line\">o.m = test</span><br><span class=\"line\">o.m() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>其实，我们这时返回看情况一，实际上可以看出”func1()“，可以理解为“window.func1()”，所以例子中的函数上下文便是this。</p>\n<h2 id=\"情况三：-作为构造函数调用\"><a href=\"#情况三：-作为构造函数调用\" class=\"headerlink\" title=\"情况三： 作为构造函数调用\"></a>情况三： 作为构造函数调用</h2><p>所谓构造函数，\b也就是通过这个函数生成一个新对象（object）。这个时候，this就是指这个新对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> test()</span><br><span class=\"line\">laert(o.x) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>运行结果为1，为了表明这时this对象不是全局对象，我对代码做一点改变：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> test()</span><br><span class=\"line\"></span><br><span class=\"line\">alert(x) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"情况四：-使用apply-和call-方法进行调用\"><a href=\"#情况四：-使用apply-和call-方法进行调用\" class=\"headerlink\" title=\"情况四： 使用apply()和call()方法进行调用\"></a>情况四： 使用apply()和call()方法进行调用</h2><p>\bapply()和call()是函数对象中的方法，它的作用是改变函数的调用对象，可以利用任何一个函数都可以显式指定任何一个对象作为其函数上下文。</p>\n<p>通过 apply() 方法来调用函数，我们要给 apply() 传入两个参数：一个作为函数上下文对象，另一个作为函数参数所组成的数组。call() 方法的使用方式类似，唯一不同的是给函数传入的参数是一个参数列表，而不是单个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">        result += <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;;</span><br><span class=\"line\">func.apply(obj1, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">func.call(obj2, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.result === <span class=\"number\">6</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.result === <span class=\"number\">15</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，<code>func.apply(obj1, [1, 2, 3]);</code> 将函数的上下文定义为 obj1，并且传入 1、2、3 三个参数，<code>func.call(obj2, 4, 5, 6);</code> 将函数的上下文定义为 obj2，并且传入 4、5、6 三个参数。</p>\n<p>那 apply 和 call 基本相同，那么我们该用哪一个呢？其实 apply 和 call 的区别仅仅在于调用时传入的参数不同，其他完全一样。所以，在选择时，主要看传入的参数。如果已知参数已经在数组里了则用 apply 即可，或者参数是动态生成的，可以把参数 push 进一个数组，然后再用 apply 调用。当参数数量已知，或者在参数里有很多无关的值则用 call 方法调用。</p>\n<h2 id=\"ES6-与-this\"><a href=\"#ES6-与-this\" class=\"headerlink\" title=\"ES6 与 this\"></a>ES6 与 this</h2><p>ES6 中引入了一个很棒的特性：箭头函数。说其棒，主要源于其书写简单，更重要的是其使得 this 更易于理解。</p>\n<p>ES6 中，箭头函数中始终会捕捉其所在上下文的 this 值，作为自己的 this。这一点非常重要，省去了我们很多的麻烦。但对于那些习惯了每个 function 中都有自己 this 的人来说，可能还有些不习惯。举个例子吧，就拿调用方式 2 中的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true，非箭头函数时指向 obj</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.func();</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，func 所在上下文的 this 值指向 window，而 func 是一个箭头函数，所以其里面的 this 会捕捉其所在上下文的 this 作为自己的 this， 所以 func 内的 this 也指向 window 对象。</p>\n<h2 id=\"其他补充\"><a href=\"#其他补充\" class=\"headerlink\" title=\"其他补充\"></a>其他补充</h2><blockquote>\n<p>利用 bind() 改变函数上下文</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">    &#125;.bind(obj1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj2.func(); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>，其会创建一个绑定函数，当调用这个绑定函数时，函数上下文将会是 bind() 方法的第一个参数。上面的例子中，将 obj1 设置为函数上下文，所以利用 func 来调用函数时，函数的上下文为 obj1，而不是它的调用者 obj2。</p>\n<p>利用 Array 的 5 个方法改变函数上下文</p>\n<p>5 个方法分别是：</p>\n<p><code>Array.prototype.every(callbackfn [, thisArg ])</code><br><code>Array.prototype.some(callbackfn [, thisArg ])</code><br><code>Array.prototype.forEach(callbackfn [, thisArg ])</code><br><code>Array.prototype.map(callbackfn [, thisArg ])</code><br><code>Array.prototype.filter(callbackfn [, thisArg ])</code></p>\n<p>当调用以上 5 个方法时，传入的参数除了回调函数以外，还可以传入另外一个可选地参数，即函数上下文，代表回调函数中的函数上下文。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">\"segmentfault\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, ind</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, ind</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);    <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;, obj);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    someData: <span class=\"string\">\"a string\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.staticFunction = myFun;</span><br><span class=\"line\">obj.staticFunction();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    myMethod : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myFun = obj.myMethod;</span><br><span class=\"line\">myFun();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    someData: <span class=\"string\">\"a string\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myFun.call(obj);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<p>window</p>\n<p>obj</p>\n<p>window</p>\n<p>obj</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjiyprk0k0007evfya6o875jo","category_id":"cjiyprk0d0004evfydauhy2sg","_id":"cjiyprk0s000fevfynk3n63f5"},{"post_id":"cjiyprjzy0000evfyxa1tg10s","category_id":"cjiyprk0d0004evfydauhy2sg","_id":"cjiyprk0x000jevfyfnokc7sk"},{"post_id":"cjiyprk0l0008evfyfyrauy41","category_id":"cjiyprk0d0004evfydauhy2sg","_id":"cjiyprk13000mevfy225gp4qy"},{"post_id":"cjiyprk0o000cevfymrxtxxit","category_id":"cjiyprk0d0004evfydauhy2sg","_id":"cjiyprk14000qevfyaiynp2t0"},{"post_id":"cjiyprk040002evfytdq0sh41","category_id":"cjiyprk0m0009evfy6ofu163t","_id":"cjiyprk15000sevfy6ie5tsh6"},{"post_id":"cjiyprk0q000eevfyc32ktjnw","category_id":"cjiyprk0d0004evfydauhy2sg","_id":"cjiyprk16000vevfy3079emcf"},{"post_id":"cjiyprk0h0006evfygb2iaowl","category_id":"cjiyprk0d0004evfydauhy2sg","_id":"cjiyprk16000xevfyydh7zy32"},{"post_id":"cjiyprk0y000levfyclewv0tt","category_id":"cjiyprk0d0004evfydauhy2sg","_id":"cjiyprk17000zevfyyplhargk"},{"post_id":"cjiyprk0v000ievfy3bnwrkau","category_id":"cjiyprk14000pevfyf9r6rq6n","_id":"cjiyprk170011evfyjaug8hld"}],"PostTag":[{"post_id":"cjiyprjzy0000evfyxa1tg10s","tag_id":"cjiyprk0h0005evfy3tkmra57","_id":"cjiyprk0n000bevfyf2ar39bn"},{"post_id":"cjiyprk0l0008evfyfyrauy41","tag_id":"cjiyprk0h0005evfy3tkmra57","_id":"cjiyprk0p000devfy1tq7zww9"},{"post_id":"cjiyprk040002evfytdq0sh41","tag_id":"cjiyprk0n000aevfyail36bhv","_id":"cjiyprk0x000kevfycje0unjr"},{"post_id":"cjiyprk0q000eevfyc32ktjnw","tag_id":"cjiyprk0h0005evfy3tkmra57","_id":"cjiyprk13000nevfymsuvswol"},{"post_id":"cjiyprk0v000ievfy3bnwrkau","tag_id":"cjiyprk0h0005evfy3tkmra57","_id":"cjiyprk14000revfy4ui6h1ct"},{"post_id":"cjiyprk0v000ievfy3bnwrkau","tag_id":"cjiyprk0n000aevfyail36bhv","_id":"cjiyprk15000tevfygwcjqhzc"},{"post_id":"cjiyprk0h0006evfygb2iaowl","tag_id":"cjiyprk0h0005evfy3tkmra57","_id":"cjiyprk16000wevfyvf9rimt5"},{"post_id":"cjiyprk0y000levfyclewv0tt","tag_id":"cjiyprk0h0005evfy3tkmra57","_id":"cjiyprk16000yevfypehqu84l"},{"post_id":"cjiyprk0k0007evfya6o875jo","tag_id":"cjiyprk13000oevfyik7yxnc1","_id":"cjiyprk170010evfy7275mrb6"},{"post_id":"cjiyprk0o000cevfymrxtxxit","tag_id":"cjiyprk0h0005evfy3tkmra57","_id":"cjiyprk170012evfy4uhmr7qu"},{"post_id":"cjiyprk0o000cevfymrxtxxit","tag_id":"cjiyprk15000uevfysdaaagan","_id":"cjiyprk180013evfy19nh0ya2"}],"Tag":[{"name":"JavaScript","_id":"cjiyprk0h0005evfy3tkmra57"},{"name":"CSS","_id":"cjiyprk0n000aevfyail36bhv"},{"name":"Vue","_id":"cjiyprk13000oevfyik7yxnc1"},{"name":"优化","_id":"cjiyprk15000uevfysdaaagan"}]}}