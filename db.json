{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/melody/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":0,"renderable":1},{"_id":"themes/melody/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/melody/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/melody/source/js/copy.js","path":"js/copy.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/fireworks.js","path":"js/fireworks.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/head.js","path":"js/head.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/love.js","path":"js/love.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/transition.js","path":"js/transition.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","path":"js/third-party/reveal/markdown.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","path":"js/third-party/reveal/math.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","path":"js/third-party/reveal/marked.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","path":"js/third-party/reveal/notes.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","path":"js/third-party/reveal/zoom.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","path":"js/third-party/reveal/reveal.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","path":"js/third-party/reveal/highlight.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/melody/.eslintignore","hash":"55f36fe3be2270ae2746eddbb2982e4e1472bc31","modified":1545035938353},{"_id":"themes/melody/.eslintrc","hash":"cfcd1b454efdd6cc1a0d43be7bc79027b84531f7","modified":1545035938353},{"_id":"themes/melody/.git","hash":"e6794e173017140bda10dd4facd15cda2ca2d0fa","modified":1545035938287},{"_id":"themes/melody/.gitignore","hash":"7ed73f0edfb682b12a42070fd2730d5d712ec2fa","modified":1545035938354},{"_id":"themes/melody/.travis.demo.yml","hash":"4482d40a58a035ef96888dfc4ed96c861b8f78a5","modified":1545035938354},{"_id":"themes/melody/LICENSE","hash":"c372b56b7553dafd2d8a8abf12d0dd71b4e2bfc0","modified":1545035938354},{"_id":"themes/melody/README.md","hash":"dd203ba6fd7b5719137cc5e9f8e18f5eaddc96ae","modified":1545035938355},{"_id":"themes/melody/_config.yml","hash":"9ffaa5c07fce8d0ae12f2b06b2ec278886f50f95","modified":1545724442828},{"_id":"themes/melody/package.json","hash":"1a085e47cbce39f0fce09c4b27efb45bb2eb81da","modified":1545035938362},{"_id":"source/CNAME","hash":"6baf632f635978497ab38b3651af288c29cf8461","modified":1545095790520},{"_id":"source/favicon.ico","hash":"822401324009c49021e6feea57b882278897942a","modified":1545035046460},{"_id":"themes/melody/stylus_format.json","hash":"2fbe63b06901d202773457d7ce658ab6aa85d02b","modified":1545035938374},{"_id":"themes/melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545035938363},{"_id":"source/_data/melody.yml","hash":"a965a1fbdd40ff7cfdc34507404804bf7d0f98d6","modified":1545718734890},{"_id":"source/_posts/BFC.md","hash":"1e5c9aacb5f699bc705aa673573d3abcbd5e7d14","modified":1545722721232},{"_id":"source/_posts/JS-简写技术.md","hash":"7176173b6c32768b8c64a881465e4f4fb3d1f7f9","modified":1545722690009},{"_id":"source/_posts/abstract-syntax-tree.md","hash":"53f9cc49f569dd7212b0a3e3c4cd1ad3daa2a668","modified":1545722717743},{"_id":"source/_posts/data-in-vue-component-is-function.md","hash":"d27b0b0cb8b27108247b4adb890cd7e8d94b800b","modified":1545722723963},{"_id":"source/_posts/debounce-and-throttle.md","hash":"21f1248091d6dffc42d4720c5f36c88f16b17844","modified":1545722726969},{"_id":"source/_posts/flex.md","hash":"96fc3bf3a9550e2a09a8e542176fcb4f5e4d7a34","modified":1545722730084},{"_id":"source/_posts/js-async.md","hash":"21932124bcee279637d6f5f7024f9b3633168675","modified":1545722737416},{"_id":"source/_posts/module.md","hash":"2913dd5b2d42ae1ed223ee755651319e26edee58","modified":1545722740616},{"_id":"source/_posts/javascript-memory-management.md","hash":"eca85f69ae20e1ea9d1ad348e402563d415860cd","modified":1545722733650},{"_id":"source/_posts/scroll-bar.md","hash":"6b852b45a381e65fe308a74603131a6ced00d0b9","modified":1545722743747},{"_id":"source/_posts/this.md","hash":"822891472091884150cd065f79cf14d6ba526544","modified":1545722746392},{"_id":"source/_posts/浅析浏览器缓存.md","hash":"19e96787ca85341c2bf40e03846c33ccd346bb57","modified":1545722753513},{"_id":"source/categories/index.md","hash":"2d64a02bd5c53c593d3852218cd47bf6645b41a7","modified":1545035046460},{"_id":"source/_posts/浅谈-Web-Components.md","hash":"f3ea7b725b870a85a969a2516a8d0068e3c19506","modified":1545722757955},{"_id":"source/tags/index.md","hash":"fc4edd119f3d1c51d9f43ed055cb7afb986a0984","modified":1545035046460},{"_id":"source/_posts/实现半像素边框.md","hash":"aa666dd6e0d36050e0bfbf541eac6183d9cc40e8","modified":1545036702985},{"_id":"themes/melody/.github/ISSUE_TEMPLATE.md","hash":"c5f14119189d9930fd7afd6e8822592fcd314ecf","modified":1545035938353},{"_id":"themes/melody/.vscode/launch.json","hash":"3098e8e395a33fa130747d2fd104a21278f266a6","modified":1545035938354},{"_id":"themes/melody/.vscode/settings.json","hash":"2e4acade0812cbeaf1363971c696a1d52d4f05ba","modified":1545035938354},{"_id":"themes/melody/languages/default.yml","hash":"5859596db5ed9b2e7f86874c4df71409323ef9b8","modified":1545035938355},{"_id":"themes/melody/languages/en.yml","hash":"5859596db5ed9b2e7f86874c4df71409323ef9b8","modified":1545035938355},{"_id":"themes/melody/languages/zh-Hans.yml","hash":"a0b752f18dd31e56c3e4ae6860f87f92c2e1a95c","modified":1545035938355},{"_id":"themes/melody/layout/archive.pug","hash":"2133e9f369dac19b9f843fc956521f864ace7567","modified":1545035938355},{"_id":"themes/melody/layout/category.pug","hash":"ea5f82d69e586f293f428f3b237c17bf873b4f03","modified":1545035938356},{"_id":"themes/melody/layout/gallery.pug","hash":"c083a7bbf5f46305daed74632aef3403b7d94dc7","modified":1545035938356},{"_id":"themes/melody/layout/index.pug","hash":"5e969c09fa5902829ad0b14c0af8d432bd4c7078","modified":1545035938362},{"_id":"themes/melody/layout/page.pug","hash":"6bb4336f74784679ac3f8691b0cce427f2282e02","modified":1545035938362},{"_id":"themes/melody/layout/post.pug","hash":"84268639485e56638f07805f65b965caf69c201a","modified":1545035938362},{"_id":"themes/melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1545035938362},{"_id":"themes/melody/layout/tag.pug","hash":"ca333911bc97bc9d3eba6e1bc05e96b209ecedfb","modified":1545035938362},{"_id":"themes/melody/scripts/gallery-tag.js","hash":"74e2e95f8daec619578f4b7dd1ed77cd5907f37e","modified":1545035938362},{"_id":"themes/melody/scripts/replace-config.js","hash":"3439d79603f66830925a19e136e9ead54a85ed8b","modified":1545035938363},{"_id":"themes/melody/source/favicon.ico","hash":"822401324009c49021e6feea57b882278897942a","modified":1545036007949},{"_id":"themes/melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545035938367},{"_id":"themes/melody/layout/includes/additional-js.pug","hash":"61184a51602bba21acaead49e78a0ffe16ecf0e6","modified":1545724368550},{"_id":"themes/melody/layout/includes/config.pug","hash":"f11a6427cf7c06b357b336ba6ba60149c324c750","modified":1545035938358},{"_id":"themes/melody/layout/includes/footer.pug","hash":"0e9f1778f021f1c205f0b1be83014fba576797af","modified":1545035938358},{"_id":"themes/melody/layout/includes/head.pug","hash":"eb40f41ad1b1133c4a210009af7e9cc4b8b8eabd","modified":1545277011612},{"_id":"themes/melody/layout/includes/header.pug","hash":"341cf0ec75ce9da25738bc929342995148518bd2","modified":1545278473911},{"_id":"themes/melody/layout/includes/layout.pug","hash":"56a6eca22e050faf4ace834294f9c07bfb07291a","modified":1545723963059},{"_id":"themes/melody/layout/includes/nav.pug","hash":"d9d341d690a03680ef66c4d84715cab1f5a39372","modified":1545035938360},{"_id":"themes/melody/layout/includes/pagination.pug","hash":"556d055e2f0c30d41ec16ef7943bd3227afcdfd1","modified":1545035938360},{"_id":"themes/melody/layout/includes/recent-posts.pug","hash":"aefcb3462d1b9ed2fb8d16414a4f580fc4e7a4e7","modified":1545035938360},{"_id":"themes/melody/layout/includes/sidebar.pug","hash":"4369f692f5069f3d510e35c00de2702cb90761b2","modified":1545036007948},{"_id":"themes/melody/source/css/index.styl","hash":"111ec52cde3e5fae92cf61dc2a1bd8726b3aa8f9","modified":1545035938366},{"_id":"themes/melody/source/css/var.styl","hash":"bbb372afd00ecdeee767266692e9f0792ac6be2f","modified":1545035938366},{"_id":"themes/melody/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1545035938366},{"_id":"themes/melody/source/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1545035938366},{"_id":"themes/melody/source/js/copy.js","hash":"cfae08721664d19cf0059172b994c0a2e253d334","modified":1545035938367},{"_id":"themes/melody/source/js/fancybox.js","hash":"0c2c506559129a5108893cf054b9aa46fe878fc3","modified":1545035938367},{"_id":"themes/melody/source/js/fireworks.js","hash":"5e3da1344966d5d6328a410cad69e92297699f3b","modified":1545035938367},{"_id":"themes/melody/source/js/head.js","hash":"212a32f824cadea0167bf4204c9714df5b7e5f5d","modified":1545035938367},{"_id":"themes/melody/source/js/love.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1545722159942},{"_id":"themes/melody/source/js/scroll.js","hash":"73d57e7cf9921ba5724ad48b8d0e8b25dbce059f","modified":1545035938367},{"_id":"themes/melody/source/js/sidebar.js","hash":"185790b0d811fd7eeb96f78b1b1195dd71df1da6","modified":1545036007949},{"_id":"themes/melody/source/js/transition.js","hash":"998c3bb6523a248d4dd4d747510c03a914a6378d","modified":1545035938374},{"_id":"themes/melody/source/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1545035938374},{"_id":"themes/melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545035938358},{"_id":"themes/melody/layout/includes/comments/disqus.pug","hash":"989de5ed05fb462e5a46601eb41ab3963b4d4e9d","modified":1545035938356},{"_id":"themes/melody/layout/includes/comments/gitalk.pug","hash":"86bdbc4a52024c3573bea27817394dd118b70a26","modified":1545035938357},{"_id":"themes/melody/layout/includes/comments/gitment.pug","hash":"4a9e172c2b7a9f6f1f8c313d0d45266de828f209","modified":1545035938357},{"_id":"themes/melody/layout/includes/comments/index.pug","hash":"6c16214e5945142e5f3b58e7694397e26f28849d","modified":1545035938357},{"_id":"themes/melody/layout/includes/comments/laibili.pug","hash":"97de1d1fb0459e7a2394ac2f5e449adf9b6986cb","modified":1545035938357},{"_id":"themes/melody/layout/includes/comments/valine.pug","hash":"e87eca6aed5a7e234a8acaa93e08ed674cb1531e","modified":1545035938358},{"_id":"themes/melody/layout/includes/count/busuanzi.pug","hash":"73e5b1e722ef9f30c41588243760da4cd284d691","modified":1545275399283},{"_id":"themes/melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1545035938358},{"_id":"themes/melody/layout/includes/mixins/article-sort.pug","hash":"da7572fcc4aac6b63a651a3320e5d853ea07b347","modified":1545035938359},{"_id":"themes/melody/layout/includes/mixins/slide.pug","hash":"91975f700b20131ab4df4d2ea3e1acc8bf2d3eef","modified":1545035938359},{"_id":"themes/melody/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1545035938360},{"_id":"themes/melody/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1545035938360},{"_id":"themes/melody/layout/includes/search/local-search.pug","hash":"85347ad18da0a81bfa7b0c0a8643886f4c0cacc1","modified":1545035938360},{"_id":"themes/melody/layout/includes/share/add-this.pug","hash":"17a11c1c36c9078639c2a82628ce5fc6584daffb","modified":1545035938360},{"_id":"themes/melody/layout/includes/share/index.pug","hash":"65ea837388ddf806f89c3b9082ceb31776dc6be5","modified":1545035938360},{"_id":"themes/melody/layout/includes/share/share-js.pug","hash":"f428b3bbc7a22d176098826c5e0aadf32b47f865","modified":1545035938361},{"_id":"themes/melody/layout/includes/slide/layout.pug","hash":"6b24f298d442e409c1149e4c1df38efce0453883","modified":1545035938361},{"_id":"themes/melody/layout/includes/slide/script.pug","hash":"c35c2af397f41bb858070032c702e8503371fd07","modified":1545035938361},{"_id":"themes/melody/layout/includes/third-party/mathjax.pug","hash":"035656871566bdcb8c45d3a0fe0b0835c524eb11","modified":1545035938361},{"_id":"themes/melody/source/css/_global/index.styl","hash":"c3418bbacedfe134f64f2ad5e7ae7a9b7292f84f","modified":1545035938363},{"_id":"themes/melody/source/css/_highlight/diff.styl","hash":"b0079f6da761935b720d70dafd826ef62fad86d2","modified":1545035938363},{"_id":"themes/melody/source/css/_highlight/highlight.styl","hash":"23e968654631932861602f6e54f4b3098e803589","modified":1545723164701},{"_id":"themes/melody/source/css/_highlight/theme.styl","hash":"7d85860927afa1d93b4a39febff3d95a73de4c36","modified":1545035938363},{"_id":"themes/melody/source/css/_layout/comments.styl","hash":"e58602aad6792f1a5dbda0677ecb04d21ac10e97","modified":1545035938364},{"_id":"themes/melody/source/css/_layout/footer.styl","hash":"a72a6bb4477c18a14a2b779db183df22b4cba272","modified":1545035938364},{"_id":"themes/melody/source/css/_layout/head.styl","hash":"049c5eddcb2ee80fdce91992087df2e7b80afd9c","modified":1545035938364},{"_id":"themes/melody/source/css/_layout/pagination.styl","hash":"a3f52d1f7ff1eaead8df016b2a4def6f7b4e9559","modified":1545035938364},{"_id":"themes/melody/source/css/_layout/page.styl","hash":"79d551beaea2458abcedbf585618b9fa8d3d22e5","modified":1545035938364},{"_id":"themes/melody/source/css/_layout/post.styl","hash":"9bdd9b5c957c3c5494cdf0b40700fd1f08162ac5","modified":1545035938365},{"_id":"themes/melody/source/css/_layout/sidebar.styl","hash":"67b99a55f6fc9daa42de9c73c2adc61bd7513de6","modified":1545036007949},{"_id":"themes/melody/source/css/_search/algolia.styl","hash":"8129d254a30e3a66cdb7eb77253036221928f47b","modified":1545035938365},{"_id":"themes/melody/source/css/_search/index.styl","hash":"031b1577e8a07f18c047b27e6b4723b14ae018b0","modified":1545035938365},{"_id":"themes/melody/source/css/_search/local-search.styl","hash":"e1b082bfb4e04ffe42efa149b02fdb66aad682a7","modified":1545035938365},{"_id":"themes/melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1545035938366},{"_id":"themes/melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1545035938365},{"_id":"themes/melody/source/js/search/algolia.js","hash":"884ecf62fe22cb869bbb7968ee770c1a699f591d","modified":1545712920885},{"_id":"themes/melody/source/js/search/local-search.js","hash":"951bbc3fe459a448d5a3e555ad84225272d91071","modified":1545035938368},{"_id":"themes/melody/source/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1545035938368},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1545035938368},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1545035938374},{"_id":"themes/melody/source/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1545035938373},{"_id":"themes/melody/source/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1545035938369},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","hash":"8c9495c76d5aa00d3dfb88653c362fba9f10cbb2","modified":1545035938369},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1545035938372},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1545035938372},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1545035938372},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1545035938373},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1545035938373},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1545035938373},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1545035938372},{"_id":"public/categories/index.html","hash":"aca648b08a1f288b28c68b2c3f0baee514de26cf","modified":1545724391430},{"_id":"public/tags/index.html","hash":"c7d09bb3a9601ce47e608caa5d684b66e93aa09c","modified":1545724391431},{"_id":"public/2018/12/17/实现半像素边框/index.html","hash":"db22ca26865d62ee629b444036d10fa57fb446de","modified":1545724391431},{"_id":"public/2018/07/07/浅析浏览器缓存/index.html","hash":"91f3f698083f76403f09800e0f4018439a507e5f","modified":1545724391431},{"_id":"public/2018/06/20/data-in-vue-component-is-function/index.html","hash":"d4fb647810327f80e6042254a6fa9c516b232791","modified":1545724391431},{"_id":"public/2018/06/18/scroll-bar/index.html","hash":"7b8bb14316ebfb552594a1289d41c0ed00d33a7f","modified":1545724391431},{"_id":"public/2018/06/17/abstract-syntax-tree/index.html","hash":"bbef8cae2978fc115a87fe28285f27dd3c6e07da","modified":1545724391431},{"_id":"public/archives/index.html","hash":"adcb8157278c75456774bfba3124f6fdd20f629f","modified":1545724391432},{"_id":"public/archives/2017/index.html","hash":"7009cd0c36f73ac21f3de78659bc0e5dc0eb804f","modified":1545724391432},{"_id":"public/archives/2017/11/index.html","hash":"9c14fba296a219b9fa6c32aaeb38b998c0d01495","modified":1545724391432},{"_id":"public/archives/2018/index.html","hash":"03ac0ff77a1f16a54da7a2bbff6601798f069143","modified":1545724391432},{"_id":"public/archives/2018/06/index.html","hash":"933297e5457bb3e66ccb919ad24b000a5b0770f8","modified":1545724391432},{"_id":"public/archives/2018/07/index.html","hash":"198879a8cc9449a8080ff2e13fb3c952dc810d9e","modified":1545724391432},{"_id":"public/archives/2018/12/index.html","hash":"1db96e46239ece5ba041888ae322701a9f37babe","modified":1545724391432},{"_id":"public/categories/布局/index.html","hash":"205692952d214802d99b2333a1844f4778225326","modified":1545724391431},{"_id":"public/categories/JavaScript/index.html","hash":"7c974523641195837aafb75def8dfbaea97aee8e","modified":1545724391431},{"_id":"public/categories/CSS/index.html","hash":"bccb58e7e25bdad9a48f0a01100e1a258abfb293","modified":1545724391431},{"_id":"public/categories/优化/index.html","hash":"ace760499f1ac29370754c3e42943053989749d9","modified":1545724391431},{"_id":"public/categories/WEB/index.html","hash":"e696d8dbe7b8d6bb72d556563091487567dd775c","modified":1545724391431},{"_id":"public/categories/JavaCcript/index.html","hash":"3cff03b86001e7385ca27356d22b3dc6fe6daeb8","modified":1545724391431},{"_id":"public/page/2/index.html","hash":"250abd0b2251bdec2d81c21961d7e94ce4c5b4b7","modified":1545724391431},{"_id":"public/tags/布局/index.html","hash":"8277dbe84da70ffe73d4fa3247fdd0d0f2cbe66f","modified":1545724391432},{"_id":"public/tags/CSS/index.html","hash":"00a1a0f3629c285df7cbcbdbc5e0d8b47647ee71","modified":1545724391432},{"_id":"public/tags/JavaScript/index.html","hash":"1cbb3a30450894a08c6b538fa361379685accbe1","modified":1545724391432},{"_id":"public/tags/Vue/index.html","hash":"5b4bd84bbc82c285f8cde1a5e94bb927ae44fbb5","modified":1545724391433},{"_id":"public/tags/HTTP/index.html","hash":"0d0dddae47d6acd239e779cbaed7630d70a59e39","modified":1545724391433},{"_id":"public/tags/优化/index.html","hash":"492ea85a6a53572f38802e668b9e274d046a3fdc","modified":1545724391433},{"_id":"public/tags/JavaCcript/index.html","hash":"49f9dd760087549d0c2e2a5200356e71002740c6","modified":1545724391433},{"_id":"public/2018/07/22/JS-简写技术/index.html","hash":"e84ca8ac88986bb9f67d45358716ba62b24df3b2","modified":1545724391433},{"_id":"public/2018/07/19/浅谈-Web-Components/index.html","hash":"1b00a0763ea2b67ed60a76dca4b55bec9b8c1538","modified":1545724391433},{"_id":"public/2018/06/30/BFC/index.html","hash":"5dd7d94d2e3695746ff13d27fd33d0d684a975a1","modified":1545724391433},{"_id":"public/2018/06/28/debounce-and-throttle/index.html","hash":"392a5be460fc5d34f25b2485cf8f94ba2bb5c640","modified":1545724391433},{"_id":"public/2018/06/22/javascript-memory-management/index.html","hash":"1da00093c6551cfdc61fe79fa5f44d76ca36f515","modified":1545724391433},{"_id":"public/2018/06/17/module/index.html","hash":"0d1a0b110eeda274d2a9274229f2f50766d29264","modified":1545724391434},{"_id":"public/2018/06/13/js-async/index.html","hash":"76780180e791d442810d7ec5154cf3f7d5631db1","modified":1545724391434},{"_id":"public/2018/06/11/this/index.html","hash":"febd285cad7d19135f32a5b2138157e746dd96fd","modified":1545724391434},{"_id":"public/2017/11/20/flex/index.html","hash":"7a8f2cf53d94e5bd6949b77ecc3cbc13d268f1da","modified":1545724391434},{"_id":"public/index.html","hash":"33bbeb36c30ca7ad00baaab32be44828e91be409","modified":1545724391434},{"_id":"public/CNAME","hash":"6baf632f635978497ab38b3651af288c29cf8461","modified":1545723850304},{"_id":"public/favicon.ico","hash":"822401324009c49021e6feea57b882278897942a","modified":1545723850304},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1545723850304},{"_id":"public/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1545723850304},{"_id":"public/live2dw/assets/exp/f01.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1545723850304},{"_id":"public/live2dw/assets/exp/f02.exp.json","hash":"241b6afafa2e25c6d7a54692a8b5aa060a137ab1","modified":1545723850304},{"_id":"public/live2dw/assets/exp/f03.exp.json","hash":"fbf7729e504f14f83f976827fcf62301a6579a34","modified":1545723850304},{"_id":"public/live2dw/assets/exp/f04.exp.json","hash":"35e746ede62e7090e7dfb08561d77772f58b4153","modified":1545723850304},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"fb0ff0949c9179447690e049aaced1ee0615941b","modified":1545723850304},{"_id":"public/live2dw/assets/mtn/idle_00.mtn","hash":"378b4577217c604c9d28ab4edf8b707c8d8c2fbb","modified":1545723850304},{"_id":"public/live2dw/assets/mtn/idle_01.mtn","hash":"88c2494655dbb712b842f03232b619f381753d52","modified":1545723850304},{"_id":"public/live2dw/assets/mtn/idle_02.mtn","hash":"7f5d2cf8706007c8659938eba132a68c470a4c26","modified":1545723850304},{"_id":"public/live2dw/assets/mtn/flickHead_00.mtn","hash":"f64c79c9171660db5c440bef229ac2e35a1597d5","modified":1545723850304},{"_id":"public/live2dw/assets/mtn/flickHead_01.mtn","hash":"a1011d6bf397bcd3c3c968d9616f88fe1ffbc83c","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/flickHead_02.mtn","hash":"d3c9c0acb4dc25a2274f3b9faa71e5ce60ad92e4","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/pinchIn_00.mtn","hash":"70978b4c983f6a9fd6d3d9c24571586f7d6eac30","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/pinchIn_02.mtn","hash":"aa0d66ca9b06c374577fd7e64e89756de1e1f2ae","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/pinchIn_01.mtn","hash":"a5fefb45115695db72b9499e627a51b2b9394f2c","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/pinchOut_00.mtn","hash":"e07fe8fd8c2810e3c1d28b730bd49c8c25849bad","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/pinchOut_02.mtn","hash":"b323fd350d334b33bbdfb31194ae664089986c27","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/pinchOut_01.mtn","hash":"e05df948d08b17f34c993a9c1f901190509d5db0","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/shake_01.mtn","hash":"e812985a56796e122018f9d57d1606a4866ff7d1","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/shake_00.mtn","hash":"5185d02c7ab9f0bec3d4a890b54b2378e553373d","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/shake_02.mtn","hash":"2702970805e07777974c383613e631730982bcff","modified":1545723850305},{"_id":"public/live2dw/assets/shizuku.model.json","hash":"19a05bd41b806a935cea42c2000626fc82da2536","modified":1545723850305},{"_id":"public/live2dw/assets/shizuku.physics.json","hash":"6484d646e79a44c83784c6ae434cf7349746c5c8","modified":1545723850305},{"_id":"public/live2dw/assets/shizuku.pose.json","hash":"ac5505efbf80ba0a2e5783d67fe232bc5c6f1f80","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/tapBody_00.mtn","hash":"835aa3d4a8fbd26c0bb66b164a19464fa3f17a99","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/tapBody_02.mtn","hash":"a75acb51c1191ce5050d3ee1af6f2dcc787c7c5e","modified":1545723850305},{"_id":"public/live2dw/assets/mtn/tapBody_01.mtn","hash":"78fca17436ab5e065e27f419f135aa6c0a0b52ef","modified":1545723850306},{"_id":"public/live2dw/assets/snd/flickHead_00.mp3","hash":"356388d939006b03cf9e6158c603b58d4800bec1","modified":1545723850306},{"_id":"public/live2dw/assets/snd/flickHead_01.mp3","hash":"436d0bbccf6e7a2744447554947eee4563608970","modified":1545723850306},{"_id":"public/live2dw/assets/snd/flickHead_02.mp3","hash":"5f63477ce63f2073e24d68fea906fe136fe6349e","modified":1545723850306},{"_id":"public/live2dw/assets/snd/pinchIn_00.mp3","hash":"f9baa3b7cadec20b714135fc49cfab3ff6adeeb4","modified":1545723850306},{"_id":"public/live2dw/assets/snd/pinchIn_01.mp3","hash":"d5c8cc6f61b56222a83a5174f75006f83c3b88da","modified":1545723850306},{"_id":"public/live2dw/assets/snd/shake_00.mp3","hash":"f65dd58e7b44ec5c865d13c190316070b625b5fe","modified":1545723850306},{"_id":"public/live2dw/assets/snd/shake_01.mp3","hash":"c1e0e8a07ff268ee06c2b7825d1b645e193f21b9","modified":1545723850306},{"_id":"public/live2dw/assets/snd/tapBody_00.mp3","hash":"003e68a59a9c8392e230f34c91860efbd946277a","modified":1545723850306},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"6e013af9c502b2e63ac5e42944e3244f8f515eb7","modified":1545723850306},{"_id":"public/live2dw/assets/snd/shake_02.mp3","hash":"8882b94bce00f09232588b7301badb105fa8acab","modified":1545723850306},{"_id":"public/live2dw/assets/snd/tapBody_02.mp3","hash":"15e7815ed0a0e5164e18e0c53b97aedc742a134d","modified":1545723850306},{"_id":"public/live2dw/assets/snd/tapBody_01.mp3","hash":"5314b50f153df71559e51e2586581c006df00722","modified":1545723850306},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_00.png","hash":"21bdb28b31783e23b26b3aa061e90be4088665aa","modified":1545723850977},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_03.png","hash":"07f568a2bb8045b6bdff7783fb4daf62c821f9ab","modified":1545723850979},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_05.png","hash":"0cd00007fb8bff62a2eb08e1d7c43abab8722224","modified":1545723850979},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"001e6cc7c8f14dd9c544942410cea2dda5fe5387","modified":1545723850980},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"5244731131a647d230c1d80731171191adc7e2a8","modified":1545723850980},{"_id":"public/live2dw/assets/snd/pinchIn_02.mp3","hash":"5b63e02607571ac601c500995e836e6c861b1c62","modified":1545723850980},{"_id":"public/live2dw/assets/snd/pinchOut_00.mp3","hash":"0654f38f6e9fd623eaf8be11b5d58c9d12991949","modified":1545723850981},{"_id":"public/live2dw/assets/snd/pinchOut_02.mp3","hash":"554edb2f3838cbdc27d1a9c6b8a9cb6eb465cbdd","modified":1545723850981},{"_id":"public/live2dw/assets/snd/pinchOut_01.mp3","hash":"8a081030fd53c07bffe3edd48f87a371ca77296b","modified":1545723850981},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545723850987},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545723850987},{"_id":"public/js/fancybox.js","hash":"0c2c506559129a5108893cf054b9aa46fe878fc3","modified":1545723850987},{"_id":"public/js/copy.js","hash":"cfae08721664d19cf0059172b994c0a2e253d334","modified":1545723850988},{"_id":"public/js/head.js","hash":"212a32f824cadea0167bf4204c9714df5b7e5f5d","modified":1545723850988},{"_id":"public/js/fireworks.js","hash":"5e3da1344966d5d6328a410cad69e92297699f3b","modified":1545723850988},{"_id":"public/js/scroll.js","hash":"73d57e7cf9921ba5724ad48b8d0e8b25dbce059f","modified":1545723850988},{"_id":"public/js/sidebar.js","hash":"185790b0d811fd7eeb96f78b1b1195dd71df1da6","modified":1545723850988},{"_id":"public/js/transition.js","hash":"998c3bb6523a248d4dd4d747510c03a914a6378d","modified":1545723850988},{"_id":"public/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1545723850988},{"_id":"public/js/love.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1545723850988},{"_id":"public/js/search/algolia.js","hash":"884ecf62fe22cb869bbb7968ee770c1a699f591d","modified":1545723850988},{"_id":"public/js/search/local-search.js","hash":"951bbc3fe459a448d5a3e555ad84225272d91071","modified":1545723850988},{"_id":"public/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1545723850988},{"_id":"public/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1545723850988},{"_id":"public/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1545723850988},{"_id":"public/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1545723850988},{"_id":"public/css/index.css","hash":"95d8425a4807c2df137a188c4d560c4a2766e0bb","modified":1545723850988},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_04.png","hash":"f764d594841905db8b2998dd61c329866125ad97","modified":1545723850988},{"_id":"public/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1545723851003},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1545723851003},{"_id":"public/js/third-party/reveal/head.min.js","hash":"95c9de30444117adbbb3218070fda00af187a76a","modified":1545723851004},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_01.png","hash":"3d0e745f3e560071ee08beeecde186e5ea35d99e","modified":1545723851004},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"7d3a9c937317b9c15f2c3a872f0e26607a729458","modified":1545723851004},{"_id":"public/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1545723851011},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_02.png","hash":"055eb2da9c13e9116be93a1e60c0ea2b660af864","modified":1545723851011},{"_id":"public/assets/algolia/algoliasearch.js","hash":"f0e3215b0553fcc11715d655e35cbc8dea9bae85","modified":1545723851011},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"5e7669733ecd0b1bc3881d2cf7fcc01e2990a07d","modified":1545723851012},{"_id":"public/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1545723851052},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1545723851067},{"_id":"public/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1545723851067},{"_id":"public/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1545723851123},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"09521263ecc625a246b3406c385300e99e966a2e","modified":1545723851126},{"_id":"public/live2dw/assets/moc/shizuku.moc","hash":"c2670a0f75830edc89d7fe6d074de4ee67e8dc5d","modified":1545723851143},{"_id":"public/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1545723851189}],"Category":[{"name":"布局","_id":"cjq3g2ieg0002gzq2z6bmahhg"},{"name":"JavaScript","_id":"cjq3g2iek0007gzq2r5ghrwfb"},{"name":"CSS","_id":"cjq3g2iew000qgzq2whf6t506"},{"name":"优化","_id":"cjq3g2iex000wgzq2iysiqo5z"},{"name":"WEB","_id":"cjq3g2iey0012gzq241n61log"},{"name":"JavaCcript","_id":"cjq3g2jbl001qgzq2x0kylbz4"}],"Data":[{"_id":"melody","data":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}],"Page":[{"title":"分类","date":"2017-09-11T02:53:14.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-09-11 10:53:14\ntype: \"categories\"\n---\n","updated":"2018-12-17T08:24:06.460Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjq3g2jb9001dgzq2c8amp8qk","content":"","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":""},{"title":"标签","date":"2017-09-11T02:51:01.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-09-11 10:51:01\ntype: \"tags\"\n---\n","updated":"2018-12-17T08:24:06.460Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjq3g2jbb001fgzq2nc2446rl","content":"","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":""}],"Post":[{"title":"快速掌握 BFC 原理","date":"2018-06-30T02:09:01.000Z","_content":"\n## 前言\n\n对于 BFC 的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。\n\n## BFC 的定义\n\nBox 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。\n\n元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。让我们看看有哪些盒子：\n\n`block-level`\n\nbox:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；\n\n`inline-level`\n\nbox:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；\n\nrun-in box: css3 中才有， 这儿先不讲了。\n\n## 常见定位方案\n\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n### 普通流 (normal flow)\n\n在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n\n### 浮动 (float)\n\n在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n\n### 绝对定位 (absolute positioning)\n\n在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## BFC 的概念\n\nFormatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n`那么 BFC 是什么呢？BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。`\n\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n## 触发 BFC\n\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n## BFC 特性及应用\n\n1. 同一个 BFC 下外边距会发生折叠\n\n```html\n<style>\n  div {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n  }\n</style>\n<body>\n  <div></div>\n  <div></div>\n</body>\n```\n\n![](https://static.skynian.cn/BFC-2018630102818.jpg)\n\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n\n首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。\n\n```html\n<div class=\"container\"><p></p></div>\n<div class=\"container\"><p></p></div>\n```\n\n```css\n.container {\n  overflow: hidden;\n}\np {\n  width: 100px;\n  height: 100px;\n  background: lightblue;\n  margin: 100px;\n}\n```\n\n![](https://static.skynian.cn/BFC-2018630102853.jpg)\n\n2. BFC 可以包含浮动的元素（清除浮动）\n\n我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子\n\n```html\n<div style=\"border: 1px solid #000;\">\n  <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n![](https://static.skynian.cn/BFC-2018630102917.jpg)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。\n\n```html\n<div style=\"border: 1px solid #000;overflow: hidden\">\n  <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n![](https://static.skynian.cn/BFC-2018630102941.jpg)\n\n3. BFC 可以阻止元素被浮动元素覆盖\n\n先来看一个文字环绕效果：\n\n![](https://static.skynian.cn/BFC-201863010303.jpg)\n\n```html\n<div style=\"height: 100px;width: 100px;float: left;background: lightblue\">\n  我是一个左浮动的元素\n</div>\n<div style=\"width: 200px; height: 200px;background: #eee\">\n  我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px;\n  background: #eee;\n</div>\n```\n\n这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：\n\n![](https://static.skynian.cn/BFC-2018630103021.jpg)\n\n这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。\n","source":"_posts/BFC.md","raw":"---\ntitle: 快速掌握 BFC 原理\ndate: 2018-06-30 10:09:01\ntags:\n  - 布局\n  - CSS\ncategories: 布局\n---\n\n## 前言\n\n对于 BFC 的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。\n\n## BFC 的定义\n\nBox 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。\n\n元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。让我们看看有哪些盒子：\n\n`block-level`\n\nbox:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；\n\n`inline-level`\n\nbox:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；\n\nrun-in box: css3 中才有， 这儿先不讲了。\n\n## 常见定位方案\n\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n### 普通流 (normal flow)\n\n在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n\n### 浮动 (float)\n\n在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n\n### 绝对定位 (absolute positioning)\n\n在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## BFC 的概念\n\nFormatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n`那么 BFC 是什么呢？BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。`\n\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n## 触发 BFC\n\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n## BFC 特性及应用\n\n1. 同一个 BFC 下外边距会发生折叠\n\n```html\n<style>\n  div {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n  }\n</style>\n<body>\n  <div></div>\n  <div></div>\n</body>\n```\n\n![](https://static.skynian.cn/BFC-2018630102818.jpg)\n\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n\n首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。\n\n```html\n<div class=\"container\"><p></p></div>\n<div class=\"container\"><p></p></div>\n```\n\n```css\n.container {\n  overflow: hidden;\n}\np {\n  width: 100px;\n  height: 100px;\n  background: lightblue;\n  margin: 100px;\n}\n```\n\n![](https://static.skynian.cn/BFC-2018630102853.jpg)\n\n2. BFC 可以包含浮动的元素（清除浮动）\n\n我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子\n\n```html\n<div style=\"border: 1px solid #000;\">\n  <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n![](https://static.skynian.cn/BFC-2018630102917.jpg)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。\n\n```html\n<div style=\"border: 1px solid #000;overflow: hidden\">\n  <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n![](https://static.skynian.cn/BFC-2018630102941.jpg)\n\n3. BFC 可以阻止元素被浮动元素覆盖\n\n先来看一个文字环绕效果：\n\n![](https://static.skynian.cn/BFC-201863010303.jpg)\n\n```html\n<div style=\"height: 100px;width: 100px;float: left;background: lightblue\">\n  我是一个左浮动的元素\n</div>\n<div style=\"width: 200px; height: 200px;background: #eee\">\n  我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px;\n  background: #eee;\n</div>\n```\n\n这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：\n\n![](https://static.skynian.cn/BFC-2018630103021.jpg)\n\n这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。\n","slug":"BFC","published":1,"updated":"2018-12-25T07:25:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2iea0000gzq2gwelzt0x","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于 BFC 的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。</p>\n<h2 id=\"BFC-的定义\"><a href=\"#BFC-的定义\" class=\"headerlink\" title=\"BFC 的定义\"></a>BFC 的定义</h2><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。</p>\n<p>元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p>\n<p><code>block-level</code></p>\n<p>box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</p>\n<p><code>inline-level</code></p>\n<p>box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</p>\n<p>run-in box: css3 中才有， 这儿先不讲了。</p>\n<h2 id=\"常见定位方案\"><a href=\"#常见定位方案\" class=\"headerlink\" title=\"常见定位方案\"></a>常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<h3 id=\"普通流-normal-flow\"><a href=\"#普通流-normal-flow\" class=\"headerlink\" title=\"普通流 (normal flow)\"></a>普通流 (normal flow)</h3><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n<h3 id=\"浮动-float\"><a href=\"#浮动-float\" class=\"headerlink\" title=\"浮动 (float)\"></a>浮动 (float)</h3><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n<h3 id=\"绝对定位-absolute-positioning\"><a href=\"#绝对定位-absolute-positioning\" class=\"headerlink\" title=\"绝对定位 (absolute positioning)\"></a>绝对定位 (absolute positioning)</h3><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n<h2 id=\"BFC-的概念\"><a href=\"#BFC-的概念\" class=\"headerlink\" title=\"BFC 的概念\"></a>BFC 的概念</h2><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p><code>那么 BFC 是什么呢？BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</code></p>\n<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h2 id=\"触发-BFC\"><a href=\"#触发-BFC\" class=\"headerlink\" title=\"触发 BFC\"></a>触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n<h2 id=\"BFC-特性及应用\"><a href=\"#BFC-特性及应用\" class=\"headerlink\" title=\"BFC 特性及应用\"></a>BFC 特性及应用</h2><ol>\n<li>同一个 BFC 下外边距会发生折叠</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  div &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">    height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">    background: lightblue;</span></span><br><span class=\"line\"><span class=\"undefined\">    margin: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/BFC-2018630102818.jpg\" alt=\"\"></p>\n<p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p>\n<p>首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/BFC-2018630102853.jpg\" alt=\"\"></p>\n<ol start=\"2\">\n<li>BFC 可以包含浮动的元素（清除浮动）</li>\n</ol>\n<p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid #000;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100px;height: 100px;background: #eee;float: left;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/BFC-2018630102917.jpg\" alt=\"\"></p>\n<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid #000;overflow: hidden\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100px;height: 100px;background: #eee;float: left;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/BFC-2018630102941.jpg\" alt=\"\"></p>\n<ol start=\"3\">\n<li>BFC 可以阻止元素被浮动元素覆盖</li>\n</ol>\n<p>先来看一个文字环绕效果：</p>\n<p><img src=\"https://static.skynian.cn/BFC-201863010303.jpg\" alt=\"\"></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height: 100px;width: 100px;float: left;background: lightblue\"</span>&gt;</span></span><br><span class=\"line\">  我是一个左浮动的元素</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 200px; height: 200px;background: #eee\"</span>&gt;</span></span><br><span class=\"line\">  我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px;</span><br><span class=\"line\">  background: #eee;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：</p>\n<p><img src=\"https://static.skynian.cn/BFC-2018630103021.jpg\" alt=\"\"></p>\n<p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于 BFC 的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。</p>\n<h2 id=\"BFC-的定义\"><a href=\"#BFC-的定义\" class=\"headerlink\" title=\"BFC 的定义\"></a>BFC 的定义</h2><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。</p>\n<p>元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p>\n<p><code>block-level</code></p>\n<p>box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</p>\n<p><code>inline-level</code></p>\n<p>box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</p>\n<p>run-in box: css3 中才有， 这儿先不讲了。</p>\n<h2 id=\"常见定位方案\"><a href=\"#常见定位方案\" class=\"headerlink\" title=\"常见定位方案\"></a>常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<h3 id=\"普通流-normal-flow\"><a href=\"#普通流-normal-flow\" class=\"headerlink\" title=\"普通流 (normal flow)\"></a>普通流 (normal flow)</h3><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n<h3 id=\"浮动-float\"><a href=\"#浮动-float\" class=\"headerlink\" title=\"浮动 (float)\"></a>浮动 (float)</h3><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n<h3 id=\"绝对定位-absolute-positioning\"><a href=\"#绝对定位-absolute-positioning\" class=\"headerlink\" title=\"绝对定位 (absolute positioning)\"></a>绝对定位 (absolute positioning)</h3><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n<h2 id=\"BFC-的概念\"><a href=\"#BFC-的概念\" class=\"headerlink\" title=\"BFC 的概念\"></a>BFC 的概念</h2><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p><code>那么 BFC 是什么呢？BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</code></p>\n<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h2 id=\"触发-BFC\"><a href=\"#触发-BFC\" class=\"headerlink\" title=\"触发 BFC\"></a>触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n<h2 id=\"BFC-特性及应用\"><a href=\"#BFC-特性及应用\" class=\"headerlink\" title=\"BFC 特性及应用\"></a>BFC 特性及应用</h2><ol>\n<li>同一个 BFC 下外边距会发生折叠</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  div &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">    height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">    background: lightblue;</span></span><br><span class=\"line\"><span class=\"undefined\">    margin: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/BFC-2018630102818.jpg\" alt=\"\"></p>\n<p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p>\n<p>首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/BFC-2018630102853.jpg\" alt=\"\"></p>\n<ol start=\"2\">\n<li>BFC 可以包含浮动的元素（清除浮动）</li>\n</ol>\n<p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid #000;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100px;height: 100px;background: #eee;float: left;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/BFC-2018630102917.jpg\" alt=\"\"></p>\n<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid #000;overflow: hidden\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100px;height: 100px;background: #eee;float: left;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/BFC-2018630102941.jpg\" alt=\"\"></p>\n<ol start=\"3\">\n<li>BFC 可以阻止元素被浮动元素覆盖</li>\n</ol>\n<p>先来看一个文字环绕效果：</p>\n<p><img src=\"https://static.skynian.cn/BFC-201863010303.jpg\" alt=\"\"></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height: 100px;width: 100px;float: left;background: lightblue\"</span>&gt;</span></span><br><span class=\"line\">  我是一个左浮动的元素</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 200px; height: 200px;background: #eee\"</span>&gt;</span></span><br><span class=\"line\">  我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px;</span><br><span class=\"line\">  background: #eee;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：</p>\n<p><img src=\"https://static.skynian.cn/BFC-2018630103021.jpg\" alt=\"\"></p>\n<p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>\n"},{"title":"抽象语法树 Abstract syntax tree","date":"2018-06-17T08:59:17.000Z","_content":"\n因为最近在了解 Webpack、 gulp 等打包工具的相关知识，并且一个核心的概念是抽象语法树。所以就收集相关资料，当做一个简单的记录。\n\n## 什么是抽象语法树\n\n在计算机科学中，抽象语法和抽象语法树其实就是源代码的抽象语法结构的树状表现形式。\n\n我们可以通过在线的抽象语法转换器了解大概，[在线转换器](https://astexplorer.net)\n\n<!--more-->\n\n如图：\n\n![](https://static.skynian.cn/Abstract-syntax-tree-2018617171212.jpg)\n\n如上图中的变量声明语句，转化成 AST 之后就是有图的样子\n\n\b 先来 \b 简单分析左图\n\n```\nvar 是一个关键字\n\nAST 是一个定义者\n\n= 是 Equal \b等号的叫法有很多种形式，在后面我们还会看到\n\n\"is tree\" 是一个字符串\n\n; 就是 semicoion\n```\n\n再来对应下右图，里面包含了所有的对于该语句的描述信息\n\n## 抽象语法树有哪些用途？\n\n代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码错误提示，代码自动补全等等......\n\n如：\n\nJSLint、JSHint 等代码风格的检查器\n\n## 通过什么工具或者库来实现源码转化成抽象语法树？\n\n简单的来说就是， JavaScript Parset 解析器\n\n浏览器会把 JS 源码通过解析器转化成抽象语法树，再进一步转化成字节码或者直接生成机器码\n\n## 后记\n\n因为只是简单记录一些概念，所以这里篇幅比较小。\n\n后续的一些，实际应用场景，先占位，后面有时间再填......\n","source":"_posts/abstract-syntax-tree.md","raw":"---\ntitle: 抽象语法树 Abstract syntax tree\ndate: 2018-06-17 16:59:17\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\n因为最近在了解 Webpack、 gulp 等打包工具的相关知识，并且一个核心的概念是抽象语法树。所以就收集相关资料，当做一个简单的记录。\n\n## 什么是抽象语法树\n\n在计算机科学中，抽象语法和抽象语法树其实就是源代码的抽象语法结构的树状表现形式。\n\n我们可以通过在线的抽象语法转换器了解大概，[在线转换器](https://astexplorer.net)\n\n<!--more-->\n\n如图：\n\n![](https://static.skynian.cn/Abstract-syntax-tree-2018617171212.jpg)\n\n如上图中的变量声明语句，转化成 AST 之后就是有图的样子\n\n\b 先来 \b 简单分析左图\n\n```\nvar 是一个关键字\n\nAST 是一个定义者\n\n= 是 Equal \b等号的叫法有很多种形式，在后面我们还会看到\n\n\"is tree\" 是一个字符串\n\n; 就是 semicoion\n```\n\n再来对应下右图，里面包含了所有的对于该语句的描述信息\n\n## 抽象语法树有哪些用途？\n\n代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码错误提示，代码自动补全等等......\n\n如：\n\nJSLint、JSHint 等代码风格的检查器\n\n## 通过什么工具或者库来实现源码转化成抽象语法树？\n\n简单的来说就是， JavaScript Parset 解析器\n\n浏览器会把 JS 源码通过解析器转化成抽象语法树，再进一步转化成字节码或者直接生成机器码\n\n## 后记\n\n因为只是简单记录一些概念，所以这里篇幅比较小。\n\n后续的一些，实际应用场景，先占位，后面有时间再填......\n","slug":"abstract-syntax-tree","published":1,"updated":"2018-12-25T07:25:17.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2iee0001gzq26sorvefo","content":"<p>因为最近在了解 Webpack、 gulp 等打包工具的相关知识，并且一个核心的概念是抽象语法树。所以就收集相关资料，当做一个简单的记录。</p>\n<h2 id=\"什么是抽象语法树\"><a href=\"#什么是抽象语法树\" class=\"headerlink\" title=\"什么是抽象语法树\"></a>什么是抽象语法树</h2><p>在计算机科学中，抽象语法和抽象语法树其实就是源代码的抽象语法结构的树状表现形式。</p>\n<p>我们可以通过在线的抽象语法转换器了解大概，<a href=\"https://astexplorer.net\" target=\"_blank\" rel=\"noopener\">在线转换器</a></p>\n<a id=\"more\"></a>\n<p>如图：</p>\n<p><img src=\"https://static.skynian.cn/Abstract-syntax-tree-2018617171212.jpg\" alt=\"\"></p>\n<p>如上图中的变量声明语句，转化成 AST 之后就是有图的样子</p>\n<p>\b 先来 \b 简单分析左图</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 是一个关键字</span><br><span class=\"line\"></span><br><span class=\"line\">AST 是一个定义者</span><br><span class=\"line\"></span><br><span class=\"line\">= 是 Equal \b等号的叫法有很多种形式，在后面我们还会看到</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;is tree&quot; 是一个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">; 就是 semicoion</span><br></pre></td></tr></table></figure>\n<p>再来对应下右图，里面包含了所有的对于该语句的描述信息</p>\n<h2 id=\"抽象语法树有哪些用途？\"><a href=\"#抽象语法树有哪些用途？\" class=\"headerlink\" title=\"抽象语法树有哪些用途？\"></a>抽象语法树有哪些用途？</h2><p>代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码错误提示，代码自动补全等等……</p>\n<p>如：</p>\n<p>JSLint、JSHint 等代码风格的检查器</p>\n<h2 id=\"通过什么工具或者库来实现源码转化成抽象语法树？\"><a href=\"#通过什么工具或者库来实现源码转化成抽象语法树？\" class=\"headerlink\" title=\"通过什么工具或者库来实现源码转化成抽象语法树？\"></a>通过什么工具或者库来实现源码转化成抽象语法树？</h2><p>简单的来说就是， JavaScript Parset 解析器</p>\n<p>浏览器会把 JS 源码通过解析器转化成抽象语法树，再进一步转化成字节码或者直接生成机器码</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>因为只是简单记录一些概念，所以这里篇幅比较小。</p>\n<p>后续的一些，实际应用场景，先占位，后面有时间再填……</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>因为最近在了解 Webpack、 gulp 等打包工具的相关知识，并且一个核心的概念是抽象语法树。所以就收集相关资料，当做一个简单的记录。</p>\n<h2 id=\"什么是抽象语法树\"><a href=\"#什么是抽象语法树\" class=\"headerlink\" title=\"什么是抽象语法树\"></a>什么是抽象语法树</h2><p>在计算机科学中，抽象语法和抽象语法树其实就是源代码的抽象语法结构的树状表现形式。</p>\n<p>我们可以通过在线的抽象语法转换器了解大概，<a href=\"https://astexplorer.net\" target=\"_blank\" rel=\"noopener\">在线转换器</a></p>","more":"<p>如图：</p>\n<p><img src=\"https://static.skynian.cn/Abstract-syntax-tree-2018617171212.jpg\" alt=\"\"></p>\n<p>如上图中的变量声明语句，转化成 AST 之后就是有图的样子</p>\n<p>\b 先来 \b 简单分析左图</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 是一个关键字</span><br><span class=\"line\"></span><br><span class=\"line\">AST 是一个定义者</span><br><span class=\"line\"></span><br><span class=\"line\">= 是 Equal \b等号的叫法有很多种形式，在后面我们还会看到</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;is tree&quot; 是一个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">; 就是 semicoion</span><br></pre></td></tr></table></figure>\n<p>再来对应下右图，里面包含了所有的对于该语句的描述信息</p>\n<h2 id=\"抽象语法树有哪些用途？\"><a href=\"#抽象语法树有哪些用途？\" class=\"headerlink\" title=\"抽象语法树有哪些用途？\"></a>抽象语法树有哪些用途？</h2><p>代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码错误提示，代码自动补全等等……</p>\n<p>如：</p>\n<p>JSLint、JSHint 等代码风格的检查器</p>\n<h2 id=\"通过什么工具或者库来实现源码转化成抽象语法树？\"><a href=\"#通过什么工具或者库来实现源码转化成抽象语法树？\" class=\"headerlink\" title=\"通过什么工具或者库来实现源码转化成抽象语法树？\"></a>通过什么工具或者库来实现源码转化成抽象语法树？</h2><p>简单的来说就是， JavaScript Parset 解析器</p>\n<p>浏览器会把 JS 源码通过解析器转化成抽象语法树，再进一步转化成字节码或者直接生成机器码</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>因为只是简单记录一些概念，所以这里篇幅比较小。</p>\n<p>后续的一些，实际应用场景，先占位，后面有时间再填……</p>"},{"title":"为什么 Vue 组件中的 data 必须是函数","date":"2018-06-20T12:52:58.000Z","_content":"\nVue 组件化使用，能够提高开发效率，方便重复使用。\n\n组件写法还是有一点区别的，最明显的是\n\n```\n// 直接实例化\ndata: {\n  count: 0,\n},\n\n// 组价形式\ndata: function() {\n  return {\n    count: 0,\n  }\n},\n```\n\n也就是，**一个组件的 data 选项必须是一个函数**\n\nvue 官方解释：\n\n通过函数返回，因此每一个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，点击一个按钮就可能会影响到其他实例\n\n## 从原型链分析\n\n首先，Object 是引用类型，如果不用 Function 返回，每个组件的 data 都是内存的同一个地址，因此彼此之间改变会有影响\n\neg：\n\n```js\nconst MyComponent = function() {};\n\nMyComponent.prototype.data = {\n  a: 1,\n  b: 2\n};\n\nconst component1 = new MyComponent();\nconst component2 = new MyComponent();\n\ncomponent1.data.a === component2.data.a; // true\n\ncomponent1.data.b = 5;\ncomponent2.data.b; // 5\n```\n\n因此两个实例都应该拥有一个自己的域\n\n```js\nconst MyComponent = function() {\n  this.data = this.data();\n};\n\nMyComponent.prototype.data = function() {\n  return {\n    a: 1,\n    b: 2\n  };\n};\n```\n\n\b 我们从以上代码，可以很清晰度明白其中的原因。\n\n其实，data()，可以命名为 setData() ，这样子 \b 更容易让 \b 人理解。\n\n## 参考\n\n- [为什么在 vue 的组件中，data 要用 function 返回对象呢？](https://blog.csdn.net/shaleilei/article/details/78084171)\n- [vue 官网-data 必须是函数](https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0)\n","source":"_posts/data-in-vue-component-is-function.md","raw":"---\ntitle: 为什么 Vue 组件中的 data 必须是函数\ndate: 2018-06-20 20:52:58\ntags:\n  - Vue\ncategories: JavaScript\n---\n\nVue 组件化使用，能够提高开发效率，方便重复使用。\n\n组件写法还是有一点区别的，最明显的是\n\n```\n// 直接实例化\ndata: {\n  count: 0,\n},\n\n// 组价形式\ndata: function() {\n  return {\n    count: 0,\n  }\n},\n```\n\n也就是，**一个组件的 data 选项必须是一个函数**\n\nvue 官方解释：\n\n通过函数返回，因此每一个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，点击一个按钮就可能会影响到其他实例\n\n## 从原型链分析\n\n首先，Object 是引用类型，如果不用 Function 返回，每个组件的 data 都是内存的同一个地址，因此彼此之间改变会有影响\n\neg：\n\n```js\nconst MyComponent = function() {};\n\nMyComponent.prototype.data = {\n  a: 1,\n  b: 2\n};\n\nconst component1 = new MyComponent();\nconst component2 = new MyComponent();\n\ncomponent1.data.a === component2.data.a; // true\n\ncomponent1.data.b = 5;\ncomponent2.data.b; // 5\n```\n\n因此两个实例都应该拥有一个自己的域\n\n```js\nconst MyComponent = function() {\n  this.data = this.data();\n};\n\nMyComponent.prototype.data = function() {\n  return {\n    a: 1,\n    b: 2\n  };\n};\n```\n\n\b 我们从以上代码，可以很清晰度明白其中的原因。\n\n其实，data()，可以命名为 setData() ，这样子 \b 更容易让 \b 人理解。\n\n## 参考\n\n- [为什么在 vue 的组件中，data 要用 function 返回对象呢？](https://blog.csdn.net/shaleilei/article/details/78084171)\n- [vue 官网-data 必须是函数](https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0)\n","slug":"data-in-vue-component-is-function","published":1,"updated":"2018-12-25T07:25:23.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2iei0004gzq23p4v1wtt","content":"<p>Vue 组件化使用，能够提高开发效率，方便重复使用。</p>\n<p>组件写法还是有一点区别的，最明显的是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 直接实例化</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">  count: 0,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 组价形式</span><br><span class=\"line\">data: function() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    count: 0,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>也就是，<strong>一个组件的 data 选项必须是一个函数</strong></p>\n<p>vue 官方解释：</p>\n<p>通过函数返回，因此每一个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，点击一个按钮就可能会影响到其他实例</p>\n<h2 id=\"从原型链分析\"><a href=\"#从原型链分析\" class=\"headerlink\" title=\"从原型链分析\"></a>从原型链分析</h2><p>首先，Object 是引用类型，如果不用 Function 返回，每个组件的 data 都是内存的同一个地址，因此彼此之间改变会有影响</p>\n<p>eg：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.prototype.data = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> component1 = <span class=\"keyword\">new</span> MyComponent();</span><br><span class=\"line\"><span class=\"keyword\">const</span> component2 = <span class=\"keyword\">new</span> MyComponent();</span><br><span class=\"line\"></span><br><span class=\"line\">component1.data.a === component2.data.a; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">component1.data.b = <span class=\"number\">5</span>;</span><br><span class=\"line\">component2.data.b; <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>因此两个实例都应该拥有一个自己的域</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data = <span class=\"keyword\">this</span>.data();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.prototype.data = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>\b 我们从以上代码，可以很清晰度明白其中的原因。</p>\n<p>其实，data()，可以命名为 setData() ，这样子 \b 更容易让 \b 人理解。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/shaleilei/article/details/78084171\" target=\"_blank\" rel=\"noopener\">为什么在 vue 的组件中，data 要用 function 返回对象呢？</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\">vue 官网-data 必须是函数</a></li>\n</ul>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>Vue 组件化使用，能够提高开发效率，方便重复使用。</p>\n<p>组件写法还是有一点区别的，最明显的是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 直接实例化</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">  count: 0,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 组价形式</span><br><span class=\"line\">data: function() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    count: 0,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>也就是，<strong>一个组件的 data 选项必须是一个函数</strong></p>\n<p>vue 官方解释：</p>\n<p>通过函数返回，因此每一个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，点击一个按钮就可能会影响到其他实例</p>\n<h2 id=\"从原型链分析\"><a href=\"#从原型链分析\" class=\"headerlink\" title=\"从原型链分析\"></a>从原型链分析</h2><p>首先，Object 是引用类型，如果不用 Function 返回，每个组件的 data 都是内存的同一个地址，因此彼此之间改变会有影响</p>\n<p>eg：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.prototype.data = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> component1 = <span class=\"keyword\">new</span> MyComponent();</span><br><span class=\"line\"><span class=\"keyword\">const</span> component2 = <span class=\"keyword\">new</span> MyComponent();</span><br><span class=\"line\"></span><br><span class=\"line\">component1.data.a === component2.data.a; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">component1.data.b = <span class=\"number\">5</span>;</span><br><span class=\"line\">component2.data.b; <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>因此两个实例都应该拥有一个自己的域</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data = <span class=\"keyword\">this</span>.data();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.prototype.data = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>\b 我们从以上代码，可以很清晰度明白其中的原因。</p>\n<p>其实，data()，可以命名为 setData() ，这样子 \b 更容易让 \b 人理解。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/shaleilei/article/details/78084171\" target=\"_blank\" rel=\"noopener\">为什么在 vue 的组件中，data 要用 function 返回对象呢？</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\">vue 官网-data 必须是函数</a></li>\n</ul>\n"},{"title":"函数去抖和函数节流","date":"2018-06-28T15:19:56.000Z","_content":"\ndebounce，在项目中其实使用的频率挺高的，但是一直没有彻底理解应用场景和原理，这次就做一次简单的总结。\n\n函数防抖与节流是很相似的概念，但是他们的应用场景不太一样。\n\n我们先从概念上深刻理解它们。\n\n## 先说函数防抖，debounce。\n\n其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。\n\n单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成 JS 就是，事件内的 N 个动作会变忽略，只有事件后`由程序触发`的动作只是有效。\n\n实现思路如下，将目标方法（动作）包装在 setTimeout 里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个 clearTimeout，这样 setTimeout 里的方法就不会执行！ 为什么要 clearTimeout 呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么 setTimeout 就自然会执行这个方法。\n\n那么这个方法用在什么地方呢，就是用于 input 输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔 170ms 才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔 350ms。\n\n> 简单实现\n\n```js\nfunction debounce(func, delay) {\n  let timeout;\n  return function(e) {\n    console.log(\"清除\", timeout, e.target.value);\n    clearTimeout(timeout);\n    let context = this,\n      args = arguments;\n    console.log(\"新的\", timeout, e.target.value);\n    timeout = setTimeout(function() {\n      console.log(\"----\");\n      func.apply(context, args);\n    }, delay);\n  };\n}\n\nlet validate = debounce(function(e) {\n  console.log(\"change\", e.target.value, new Date() - 0);\n}, 380);\n\n// 绑定监听\ndocument.querySelector(\"input\").addEventListener(\"input\", validate);\n```\n\n这个保证了正常的用户每输入 1，2 个字符就能触发一次。如果用户是输入法狂魔，也可以狠制他每输入 3 ～ 6 个字符触发一次。\n\n这个方法的重点是，它在用户不触发事件的时，才触发动作，并且抑制了本来在事件中要执行的动作。\n\n其他应用场合：提交按钮的点击事件。\n\n## 再看节流，throttle。\n\n节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是 debounce 了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。\n\n```js\nfunction throttle(fn, threshhold) {\n  let timeout;\n  let start = new Date();\n  let threshhold = threshhold || 160;\n  return function() {\n    let context = this,\n      args = arguments,\n      curr = new Date() - 0;\n\n    clearTimeout(timeout); //总是干掉事件回调\n    if (curr - start >= threshhold) {\n      console.log(\"now\", curr, curr - start); //注意这里相减的结果，都差不多是160左右\n      fn.apply(context, args); //只执行一部分方法，这些方法是在某个时间段内执行一次\n      start = curr;\n    } else {\n      // 让方法在脱离事件后也能执行一次\n      timeout = setTimeout(function() {\n        fn.apply(context, args);\n      }, threshhold);\n    }\n  };\n}\nlet mousemove = throttle(function(e) {\n  console.log(e.pageX, e.pageY);\n});\n\n// 绑定监听\ndocument.querySelector(\"#panel\").addEventListener(\"mousemove\", mousemove);\n```\n\n函数节流会用在比 input, keyup 更频繁触发的事件中，如 resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。\n\n> \b 函数抖动和节流视图\n\n![debounce-and-throttle-2018628233717](https://static.skynian.cn/debounce-and-throttle-2018628233717.png)\n","source":"_posts/debounce-and-throttle.md","raw":"---\ntitle: 函数去抖和函数节流\ndate: 2018-06-28 23:19:56\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\ndebounce，在项目中其实使用的频率挺高的，但是一直没有彻底理解应用场景和原理，这次就做一次简单的总结。\n\n函数防抖与节流是很相似的概念，但是他们的应用场景不太一样。\n\n我们先从概念上深刻理解它们。\n\n## 先说函数防抖，debounce。\n\n其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。\n\n单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成 JS 就是，事件内的 N 个动作会变忽略，只有事件后`由程序触发`的动作只是有效。\n\n实现思路如下，将目标方法（动作）包装在 setTimeout 里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个 clearTimeout，这样 setTimeout 里的方法就不会执行！ 为什么要 clearTimeout 呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么 setTimeout 就自然会执行这个方法。\n\n那么这个方法用在什么地方呢，就是用于 input 输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔 170ms 才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔 350ms。\n\n> 简单实现\n\n```js\nfunction debounce(func, delay) {\n  let timeout;\n  return function(e) {\n    console.log(\"清除\", timeout, e.target.value);\n    clearTimeout(timeout);\n    let context = this,\n      args = arguments;\n    console.log(\"新的\", timeout, e.target.value);\n    timeout = setTimeout(function() {\n      console.log(\"----\");\n      func.apply(context, args);\n    }, delay);\n  };\n}\n\nlet validate = debounce(function(e) {\n  console.log(\"change\", e.target.value, new Date() - 0);\n}, 380);\n\n// 绑定监听\ndocument.querySelector(\"input\").addEventListener(\"input\", validate);\n```\n\n这个保证了正常的用户每输入 1，2 个字符就能触发一次。如果用户是输入法狂魔，也可以狠制他每输入 3 ～ 6 个字符触发一次。\n\n这个方法的重点是，它在用户不触发事件的时，才触发动作，并且抑制了本来在事件中要执行的动作。\n\n其他应用场合：提交按钮的点击事件。\n\n## 再看节流，throttle。\n\n节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是 debounce 了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。\n\n```js\nfunction throttle(fn, threshhold) {\n  let timeout;\n  let start = new Date();\n  let threshhold = threshhold || 160;\n  return function() {\n    let context = this,\n      args = arguments,\n      curr = new Date() - 0;\n\n    clearTimeout(timeout); //总是干掉事件回调\n    if (curr - start >= threshhold) {\n      console.log(\"now\", curr, curr - start); //注意这里相减的结果，都差不多是160左右\n      fn.apply(context, args); //只执行一部分方法，这些方法是在某个时间段内执行一次\n      start = curr;\n    } else {\n      // 让方法在脱离事件后也能执行一次\n      timeout = setTimeout(function() {\n        fn.apply(context, args);\n      }, threshhold);\n    }\n  };\n}\nlet mousemove = throttle(function(e) {\n  console.log(e.pageX, e.pageY);\n});\n\n// 绑定监听\ndocument.querySelector(\"#panel\").addEventListener(\"mousemove\", mousemove);\n```\n\n函数节流会用在比 input, keyup 更频繁触发的事件中，如 resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。\n\n> \b 函数抖动和节流视图\n\n![debounce-and-throttle-2018628233717](https://static.skynian.cn/debounce-and-throttle-2018628233717.png)\n","slug":"debounce-and-throttle","published":1,"updated":"2018-12-25T07:25:26.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2iei0005gzq27ntyzpau","content":"<p>debounce，在项目中其实使用的频率挺高的，但是一直没有彻底理解应用场景和原理，这次就做一次简单的总结。</p>\n<p>函数防抖与节流是很相似的概念，但是他们的应用场景不太一样。</p>\n<p>我们先从概念上深刻理解它们。</p>\n<h2 id=\"先说函数防抖，debounce。\"><a href=\"#先说函数防抖，debounce。\" class=\"headerlink\" title=\"先说函数防抖，debounce。\"></a>先说函数防抖，debounce。</h2><p>其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。</p>\n<p>单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成 JS 就是，事件内的 N 个动作会变忽略，只有事件后<code>由程序触发</code>的动作只是有效。</p>\n<p>实现思路如下，将目标方法（动作）包装在 setTimeout 里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个 clearTimeout，这样 setTimeout 里的方法就不会执行！ 为什么要 clearTimeout 呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么 setTimeout 就自然会执行这个方法。</p>\n<p>那么这个方法用在什么地方呢，就是用于 input 输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔 170ms 才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔 350ms。</p>\n<blockquote>\n<p>简单实现</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"清除\"</span>, timeout, e.target.value);</span><br><span class=\"line\">    clearTimeout(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">      args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"新的\"</span>, timeout, e.target.value);</span><br><span class=\"line\">    timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"----\"</span>);</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> validate = debounce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"change\"</span>, e.target.value, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">380</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"input\"</span>).addEventListener(<span class=\"string\">\"input\"</span>, validate);</span><br></pre></td></tr></table></figure>\n<p>这个保证了正常的用户每输入 1，2 个字符就能触发一次。如果用户是输入法狂魔，也可以狠制他每输入 3 ～ 6 个字符触发一次。</p>\n<p>这个方法的重点是，它在用户不触发事件的时，才触发动作，并且抑制了本来在事件中要执行的动作。</p>\n<p>其他应用场合：提交按钮的点击事件。</p>\n<h2 id=\"再看节流，throttle。\"><a href=\"#再看节流，throttle。\" class=\"headerlink\" title=\"再看节流，throttle。\"></a>再看节流，throttle。</h2><p>节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是 debounce 了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, threshhold</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> threshhold = threshhold || <span class=\"number\">160</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">      args = <span class=\"built_in\">arguments</span>,</span><br><span class=\"line\">      curr = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    clearTimeout(timeout); <span class=\"comment\">//总是干掉事件回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr - start &gt;= threshhold) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"now\"</span>, curr, curr - start); <span class=\"comment\">//注意这里相减的结果，都差不多是160左右</span></span><br><span class=\"line\">      fn.apply(context, args); <span class=\"comment\">//只执行一部分方法，这些方法是在某个时间段内执行一次</span></span><br><span class=\"line\">      start = curr;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 让方法在脱离事件后也能执行一次</span></span><br><span class=\"line\">      timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, threshhold);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mousemove = throttle(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.pageX, e.pageY);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#panel\"</span>).addEventListener(<span class=\"string\">\"mousemove\"</span>, mousemove);</span><br></pre></td></tr></table></figure>\n<p>函数节流会用在比 input, keyup 更频繁触发的事件中，如 resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。</p>\n<blockquote>\n<p>\b 函数抖动和节流视图</p>\n</blockquote>\n<p><img src=\"https://static.skynian.cn/debounce-and-throttle-2018628233717.png\" alt=\"debounce-and-throttle-2018628233717\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>debounce，在项目中其实使用的频率挺高的，但是一直没有彻底理解应用场景和原理，这次就做一次简单的总结。</p>\n<p>函数防抖与节流是很相似的概念，但是他们的应用场景不太一样。</p>\n<p>我们先从概念上深刻理解它们。</p>\n<h2 id=\"先说函数防抖，debounce。\"><a href=\"#先说函数防抖，debounce。\" class=\"headerlink\" title=\"先说函数防抖，debounce。\"></a>先说函数防抖，debounce。</h2><p>其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。</p>\n<p>单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成 JS 就是，事件内的 N 个动作会变忽略，只有事件后<code>由程序触发</code>的动作只是有效。</p>\n<p>实现思路如下，将目标方法（动作）包装在 setTimeout 里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个 clearTimeout，这样 setTimeout 里的方法就不会执行！ 为什么要 clearTimeout 呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么 setTimeout 就自然会执行这个方法。</p>\n<p>那么这个方法用在什么地方呢，就是用于 input 输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔 170ms 才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔 350ms。</p>\n<blockquote>\n<p>简单实现</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"清除\"</span>, timeout, e.target.value);</span><br><span class=\"line\">    clearTimeout(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">      args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"新的\"</span>, timeout, e.target.value);</span><br><span class=\"line\">    timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"----\"</span>);</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> validate = debounce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"change\"</span>, e.target.value, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">380</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"input\"</span>).addEventListener(<span class=\"string\">\"input\"</span>, validate);</span><br></pre></td></tr></table></figure>\n<p>这个保证了正常的用户每输入 1，2 个字符就能触发一次。如果用户是输入法狂魔，也可以狠制他每输入 3 ～ 6 个字符触发一次。</p>\n<p>这个方法的重点是，它在用户不触发事件的时，才触发动作，并且抑制了本来在事件中要执行的动作。</p>\n<p>其他应用场合：提交按钮的点击事件。</p>\n<h2 id=\"再看节流，throttle。\"><a href=\"#再看节流，throttle。\" class=\"headerlink\" title=\"再看节流，throttle。\"></a>再看节流，throttle。</h2><p>节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是 debounce 了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, threshhold</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> threshhold = threshhold || <span class=\"number\">160</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">      args = <span class=\"built_in\">arguments</span>,</span><br><span class=\"line\">      curr = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    clearTimeout(timeout); <span class=\"comment\">//总是干掉事件回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr - start &gt;= threshhold) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"now\"</span>, curr, curr - start); <span class=\"comment\">//注意这里相减的结果，都差不多是160左右</span></span><br><span class=\"line\">      fn.apply(context, args); <span class=\"comment\">//只执行一部分方法，这些方法是在某个时间段内执行一次</span></span><br><span class=\"line\">      start = curr;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 让方法在脱离事件后也能执行一次</span></span><br><span class=\"line\">      timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, threshhold);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mousemove = throttle(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.pageX, e.pageY);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#panel\"</span>).addEventListener(<span class=\"string\">\"mousemove\"</span>, mousemove);</span><br></pre></td></tr></table></figure>\n<p>函数节流会用在比 input, keyup 更频繁触发的事件中，如 resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。</p>\n<blockquote>\n<p>\b 函数抖动和节流视图</p>\n</blockquote>\n<p><img src=\"https://static.skynian.cn/debounce-and-throttle-2018628233717.png\" alt=\"debounce-and-throttle-2018628233717\"></p>\n"},{"title":"浅谈Flex布局","date":"2017-11-20T07:24:44.000Z","_content":"\n![](https://static.skynian.cn/flex-2018613142131.png)\n\n布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n\n2009 年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n\n<!--more-->\n\n这次笔者简单谈谈 flexbox 中的 5 个常见的属性\n\n## 属性 1：Display:Flex\n\n以下是实例页面：\n\n![](https://static.skynian.cn/flex-2018531202637.gif)\n\n我们可以看到，在灰色的容器中，包含了 4 种不同颜色与大小的 div 元素，每个元素都默认 display:block ，因此每个立方体都占据了一行的整个宽度。\n\n为了开始使用 Flexbox 布局，需要把容器变成 Flex 容器\n\n```css\n#container {\n  display: flex;\n  display: -webkit-flex; // 兼容性写法\n}\n```\n\n![](https://static.skynian.cn/flex-2018531204333.gif)\n\n## 属性 2：Flex Direction\n\nFlexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：\n\n![](https://static.skynian.cn/flex-2018531204418.gif)\n\n**项目默认是由主轴（从左到右）排列的**，这就是你使用 display:flex 后，四方体以水平线排列的原因\n\n而 Flex-direction 决定了主轴的方向\n\n```css\n#container {\n  display: flex;\n  flex-direction: column;\n}\n```\n\n![](https://static.skynian.cn/flex-2018531204454.gif)\n\n**这里有一个重要的区别：** flex-direction:column\n\n**所指的是四方体将沿主轴的垂直方向对齐，它使主轴自身从水平到垂直**\n\n而 flex-direction 还有一些其他的值供你选择，例如：row-reverse 与 column-reverse\n\n![](https://static.skynian.cn/flex-2018531204544.gif)\n\n## 属性 3：Justify Content\n\njustify-content 属性定义了项目在主轴上的对齐方式。\n\n在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到 flex-direction:row 值上\n\n```css\n#container {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n}\n```\n\njustify-content 属性包含了 5 个值供你使用\n\n```\nFlex-start\n\nFlex-end\n\nCenter\n\nSpace-between\n\nSpace-around\n```\n\n![](https://static.skynian.cn/flex-2018531204619.gif)\n\nSpace-around 与 Space-between 是两个不容易直观理解的值。Space-between 实现了两端对齐，而四方体之间的间隔都是相等的。\nSpace-around 使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）\n\n最后一点：请记住 justify-content 沿主轴对齐，而 flex-direction 决定了主轴的方向。它将决定你移动的方向。\n\n## 属性 4：Align Items\n\n当你理解了 justify-content 属性，理解 Align Items 属性就变得轻而易举了。\n\njustify-content 定义了项目在主轴的对齐方式，而 align-items 属性则定义了项目在交叉轴上是如何对齐的。\n\n![](https://static.skynian.cn/flex-2018531204650.gif)\n\n当我们将 flex-direction 属性值重置为 row 后，我们的轴看上去就与上图一致。那么，让我们深入的了解下 Align Items 属性有哪些值：\n\n```\nflex-start\n\nflex-end\n\ncenter\n\nstretch\n\nbaseline\n```\n\n前三个值与 justify-content 属性中的值完全一致，没有太多需要解释的地方。\n\n但是，接下来两个值却有些不同。\n\nStretch 指的是如果项目未设置高度或设为 auto，项目将占满整个容器。而 baseline 是指项目将与段落标签的底部对齐。\n\n![](https://static.skynian.cn/flex-2018531204725.gif)\n\n（请注意，对于 align-items：stretch，我不得不将四方体的高度设置为 auto，否则 height 属性将覆盖该 stretch）\n\n对于 baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：\n\n![](https://static.skynian.cn/flex-2018531204754.gif)\n\n为了更好地演示主轴和交叉轴的表现，在基于 justify-content 属性和 align-items 属性的值为 center 的情况下，让我们看看赋予 flex-direction 属性两个不同值后，它的表现如何：\n\n我们可以看到，对于 row 值，四方体沿着与主轴水平方向排列，而对于 column 值，它们则沿着与主轴垂直的方向排列。\n\n![](https://static.skynian.cn/flex-2018531204835.gif)\n\n## 属性 5：Align Self\n\nalign-self 属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖 align-items 属性。虽然它的默认值为 auto，但它继承了父元素 align-items 的属性。除了 auto 外，其他都与 align-items 属性完全一致。\n\n```css\n#container {\n  align-items: flex-start;\n}\n.square#one {\n  align-self: center;\n}\n```\n\n我们将在四个四方体上应用 align-self 属性，而其余的四方体则应用 align-items:center 与 flex-direction:row，让我们看看会发生什么\n\n![](https://static.skynian.cn/flex-2018531204920.gif)\n\n## 结论\n\n虽然我们只是仅仅了解了 Flexbox 的一些浅层的用法，但是已足够入门\n","source":"_posts/flex.md","raw":"---\ntitle: 浅谈Flex布局\ndate: 2017-11-20 15:24:44\ntags:\n  - CSS\ncategories: CSS\n---\n\n![](https://static.skynian.cn/flex-2018613142131.png)\n\n布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n\n2009 年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n\n<!--more-->\n\n这次笔者简单谈谈 flexbox 中的 5 个常见的属性\n\n## 属性 1：Display:Flex\n\n以下是实例页面：\n\n![](https://static.skynian.cn/flex-2018531202637.gif)\n\n我们可以看到，在灰色的容器中，包含了 4 种不同颜色与大小的 div 元素，每个元素都默认 display:block ，因此每个立方体都占据了一行的整个宽度。\n\n为了开始使用 Flexbox 布局，需要把容器变成 Flex 容器\n\n```css\n#container {\n  display: flex;\n  display: -webkit-flex; // 兼容性写法\n}\n```\n\n![](https://static.skynian.cn/flex-2018531204333.gif)\n\n## 属性 2：Flex Direction\n\nFlexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：\n\n![](https://static.skynian.cn/flex-2018531204418.gif)\n\n**项目默认是由主轴（从左到右）排列的**，这就是你使用 display:flex 后，四方体以水平线排列的原因\n\n而 Flex-direction 决定了主轴的方向\n\n```css\n#container {\n  display: flex;\n  flex-direction: column;\n}\n```\n\n![](https://static.skynian.cn/flex-2018531204454.gif)\n\n**这里有一个重要的区别：** flex-direction:column\n\n**所指的是四方体将沿主轴的垂直方向对齐，它使主轴自身从水平到垂直**\n\n而 flex-direction 还有一些其他的值供你选择，例如：row-reverse 与 column-reverse\n\n![](https://static.skynian.cn/flex-2018531204544.gif)\n\n## 属性 3：Justify Content\n\njustify-content 属性定义了项目在主轴上的对齐方式。\n\n在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到 flex-direction:row 值上\n\n```css\n#container {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n}\n```\n\njustify-content 属性包含了 5 个值供你使用\n\n```\nFlex-start\n\nFlex-end\n\nCenter\n\nSpace-between\n\nSpace-around\n```\n\n![](https://static.skynian.cn/flex-2018531204619.gif)\n\nSpace-around 与 Space-between 是两个不容易直观理解的值。Space-between 实现了两端对齐，而四方体之间的间隔都是相等的。\nSpace-around 使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）\n\n最后一点：请记住 justify-content 沿主轴对齐，而 flex-direction 决定了主轴的方向。它将决定你移动的方向。\n\n## 属性 4：Align Items\n\n当你理解了 justify-content 属性，理解 Align Items 属性就变得轻而易举了。\n\njustify-content 定义了项目在主轴的对齐方式，而 align-items 属性则定义了项目在交叉轴上是如何对齐的。\n\n![](https://static.skynian.cn/flex-2018531204650.gif)\n\n当我们将 flex-direction 属性值重置为 row 后，我们的轴看上去就与上图一致。那么，让我们深入的了解下 Align Items 属性有哪些值：\n\n```\nflex-start\n\nflex-end\n\ncenter\n\nstretch\n\nbaseline\n```\n\n前三个值与 justify-content 属性中的值完全一致，没有太多需要解释的地方。\n\n但是，接下来两个值却有些不同。\n\nStretch 指的是如果项目未设置高度或设为 auto，项目将占满整个容器。而 baseline 是指项目将与段落标签的底部对齐。\n\n![](https://static.skynian.cn/flex-2018531204725.gif)\n\n（请注意，对于 align-items：stretch，我不得不将四方体的高度设置为 auto，否则 height 属性将覆盖该 stretch）\n\n对于 baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：\n\n![](https://static.skynian.cn/flex-2018531204754.gif)\n\n为了更好地演示主轴和交叉轴的表现，在基于 justify-content 属性和 align-items 属性的值为 center 的情况下，让我们看看赋予 flex-direction 属性两个不同值后，它的表现如何：\n\n我们可以看到，对于 row 值，四方体沿着与主轴水平方向排列，而对于 column 值，它们则沿着与主轴垂直的方向排列。\n\n![](https://static.skynian.cn/flex-2018531204835.gif)\n\n## 属性 5：Align Self\n\nalign-self 属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖 align-items 属性。虽然它的默认值为 auto，但它继承了父元素 align-items 的属性。除了 auto 外，其他都与 align-items 属性完全一致。\n\n```css\n#container {\n  align-items: flex-start;\n}\n.square#one {\n  align-self: center;\n}\n```\n\n我们将在四个四方体上应用 align-self 属性，而其余的四方体则应用 align-items:center 与 flex-direction:row，让我们看看会发生什么\n\n![](https://static.skynian.cn/flex-2018531204920.gif)\n\n## 结论\n\n虽然我们只是仅仅了解了 Flexbox 的一些浅层的用法，但是已足够入门\n","slug":"flex","published":1,"updated":"2018-12-25T07:25:30.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2iej0006gzq2izjmrwdb","content":"<p><img src=\"https://static.skynian.cn/flex-2018613142131.png\" alt=\"\"></p>\n<p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<p>2009 年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>\n<a id=\"more\"></a>\n<p>这次笔者简单谈谈 flexbox 中的 5 个常见的属性</p>\n<h2 id=\"属性-1：Display-Flex\"><a href=\"#属性-1：Display-Flex\" class=\"headerlink\" title=\"属性 1：Display:Flex\"></a>属性 1：Display:Flex</h2><p>以下是实例页面：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531202637.gif\" alt=\"\"></p>\n<p>我们可以看到，在灰色的容器中，包含了 4 种不同颜色与大小的 div 元素，每个元素都默认 display:block ，因此每个立方体都占据了一行的整个宽度。</p>\n<p>为了开始使用 Flexbox 布局，需要把容器变成 Flex 容器</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  display: -webkit-flex; // 兼容性写法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204333.gif\" alt=\"\"></p>\n<h2 id=\"属性-2：Flex-Direction\"><a href=\"#属性-2：Flex-Direction\" class=\"headerlink\" title=\"属性 2：Flex Direction\"></a>属性 2：Flex Direction</h2><p>Flexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204418.gif\" alt=\"\"></p>\n<p><strong>项目默认是由主轴（从左到右）排列的</strong>，这就是你使用 display:flex 后，四方体以水平线排列的原因</p>\n<p>而 Flex-direction 决定了主轴的方向</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: column;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204454.gif\" alt=\"\"></p>\n<p><strong>这里有一个重要的区别：</strong> flex-direction:column</p>\n<p><strong>所指的是四方体将沿主轴的垂直方向对齐，它使主轴自身从水平到垂直</strong></p>\n<p>而 flex-direction 还有一些其他的值供你选择，例如：row-reverse 与 column-reverse</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204544.gif\" alt=\"\"></p>\n<h2 id=\"属性-3：Justify-Content\"><a href=\"#属性-3：Justify-Content\" class=\"headerlink\" title=\"属性 3：Justify Content\"></a>属性 3：Justify Content</h2><p>justify-content 属性定义了项目在主轴上的对齐方式。</p>\n<p>在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到 flex-direction:row 值上</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>justify-content 属性包含了 5 个值供你使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flex-start</span><br><span class=\"line\"></span><br><span class=\"line\">Flex-end</span><br><span class=\"line\"></span><br><span class=\"line\">Center</span><br><span class=\"line\"></span><br><span class=\"line\">Space-between</span><br><span class=\"line\"></span><br><span class=\"line\">Space-around</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204619.gif\" alt=\"\"></p>\n<p>Space-around 与 Space-between 是两个不容易直观理解的值。Space-between 实现了两端对齐，而四方体之间的间隔都是相等的。<br>Space-around 使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）</p>\n<p>最后一点：请记住 justify-content 沿主轴对齐，而 flex-direction 决定了主轴的方向。它将决定你移动的方向。</p>\n<h2 id=\"属性-4：Align-Items\"><a href=\"#属性-4：Align-Items\" class=\"headerlink\" title=\"属性 4：Align Items\"></a>属性 4：Align Items</h2><p>当你理解了 justify-content 属性，理解 Align Items 属性就变得轻而易举了。</p>\n<p>justify-content 定义了项目在主轴的对齐方式，而 align-items 属性则定义了项目在交叉轴上是如何对齐的。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204650.gif\" alt=\"\"></p>\n<p>当我们将 flex-direction 属性值重置为 row 后，我们的轴看上去就与上图一致。那么，让我们深入的了解下 Align Items 属性有哪些值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start</span><br><span class=\"line\"></span><br><span class=\"line\">flex-end</span><br><span class=\"line\"></span><br><span class=\"line\">center</span><br><span class=\"line\"></span><br><span class=\"line\">stretch</span><br><span class=\"line\"></span><br><span class=\"line\">baseline</span><br></pre></td></tr></table></figure>\n<p>前三个值与 justify-content 属性中的值完全一致，没有太多需要解释的地方。</p>\n<p>但是，接下来两个值却有些不同。</p>\n<p>Stretch 指的是如果项目未设置高度或设为 auto，项目将占满整个容器。而 baseline 是指项目将与段落标签的底部对齐。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204725.gif\" alt=\"\"></p>\n<p>（请注意，对于 align-items：stretch，我不得不将四方体的高度设置为 auto，否则 height 属性将覆盖该 stretch）</p>\n<p>对于 baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204754.gif\" alt=\"\"></p>\n<p>为了更好地演示主轴和交叉轴的表现，在基于 justify-content 属性和 align-items 属性的值为 center 的情况下，让我们看看赋予 flex-direction 属性两个不同值后，它的表现如何：</p>\n<p>我们可以看到，对于 row 值，四方体沿着与主轴水平方向排列，而对于 column 值，它们则沿着与主轴垂直的方向排列。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204835.gif\" alt=\"\"></p>\n<h2 id=\"属性-5：Align-Self\"><a href=\"#属性-5：Align-Self\" class=\"headerlink\" title=\"属性 5：Align Self\"></a>属性 5：Align Self</h2><p>align-self 属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖 align-items 属性。虽然它的默认值为 auto，但它继承了父元素 align-items 的属性。除了 auto 外，其他都与 align-items 属性完全一致。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.square</span><span class=\"selector-id\">#one</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-self</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将在四个四方体上应用 align-self 属性，而其余的四方体则应用 align-items:center 与 flex-direction:row，让我们看看会发生什么</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204920.gif\" alt=\"\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>虽然我们只是仅仅了解了 Flexbox 的一些浅层的用法，但是已足够入门</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p><img src=\"https://static.skynian.cn/flex-2018613142131.png\" alt=\"\"></p>\n<p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<p>2009 年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>","more":"<p>这次笔者简单谈谈 flexbox 中的 5 个常见的属性</p>\n<h2 id=\"属性-1：Display-Flex\"><a href=\"#属性-1：Display-Flex\" class=\"headerlink\" title=\"属性 1：Display:Flex\"></a>属性 1：Display:Flex</h2><p>以下是实例页面：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531202637.gif\" alt=\"\"></p>\n<p>我们可以看到，在灰色的容器中，包含了 4 种不同颜色与大小的 div 元素，每个元素都默认 display:block ，因此每个立方体都占据了一行的整个宽度。</p>\n<p>为了开始使用 Flexbox 布局，需要把容器变成 Flex 容器</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  display: -webkit-flex; // 兼容性写法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204333.gif\" alt=\"\"></p>\n<h2 id=\"属性-2：Flex-Direction\"><a href=\"#属性-2：Flex-Direction\" class=\"headerlink\" title=\"属性 2：Flex Direction\"></a>属性 2：Flex Direction</h2><p>Flexbox 容器有两根轴：主轴和垂直的交叉轴，默认情况如下：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204418.gif\" alt=\"\"></p>\n<p><strong>项目默认是由主轴（从左到右）排列的</strong>，这就是你使用 display:flex 后，四方体以水平线排列的原因</p>\n<p>而 Flex-direction 决定了主轴的方向</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: column;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204454.gif\" alt=\"\"></p>\n<p><strong>这里有一个重要的区别：</strong> flex-direction:column</p>\n<p><strong>所指的是四方体将沿主轴的垂直方向对齐，它使主轴自身从水平到垂直</strong></p>\n<p>而 flex-direction 还有一些其他的值供你选择，例如：row-reverse 与 column-reverse</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204544.gif\" alt=\"\"></p>\n<h2 id=\"属性-3：Justify-Content\"><a href=\"#属性-3：Justify-Content\" class=\"headerlink\" title=\"属性 3：Justify Content\"></a>属性 3：Justify Content</h2><p>justify-content 属性定义了项目在主轴上的对齐方式。</p>\n<p>在这里，你将更多的了解主轴与交叉轴的区别。首先，让我们回到 flex-direction:row 值上</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>justify-content 属性包含了 5 个值供你使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flex-start</span><br><span class=\"line\"></span><br><span class=\"line\">Flex-end</span><br><span class=\"line\"></span><br><span class=\"line\">Center</span><br><span class=\"line\"></span><br><span class=\"line\">Space-between</span><br><span class=\"line\"></span><br><span class=\"line\">Space-around</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://static.skynian.cn/flex-2018531204619.gif\" alt=\"\"></p>\n<p>Space-around 与 Space-between 是两个不容易直观理解的值。Space-between 实现了两端对齐，而四方体之间的间隔都是相等的。<br>Space-around 使四方体两侧的间隔相等，这意味着四方体之间的间隔比最外边四方体与边框的间隔要大一倍。（每个四方体贡献了不重叠的等量余量，从而使空间翻倍）</p>\n<p>最后一点：请记住 justify-content 沿主轴对齐，而 flex-direction 决定了主轴的方向。它将决定你移动的方向。</p>\n<h2 id=\"属性-4：Align-Items\"><a href=\"#属性-4：Align-Items\" class=\"headerlink\" title=\"属性 4：Align Items\"></a>属性 4：Align Items</h2><p>当你理解了 justify-content 属性，理解 Align Items 属性就变得轻而易举了。</p>\n<p>justify-content 定义了项目在主轴的对齐方式，而 align-items 属性则定义了项目在交叉轴上是如何对齐的。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204650.gif\" alt=\"\"></p>\n<p>当我们将 flex-direction 属性值重置为 row 后，我们的轴看上去就与上图一致。那么，让我们深入的了解下 Align Items 属性有哪些值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start</span><br><span class=\"line\"></span><br><span class=\"line\">flex-end</span><br><span class=\"line\"></span><br><span class=\"line\">center</span><br><span class=\"line\"></span><br><span class=\"line\">stretch</span><br><span class=\"line\"></span><br><span class=\"line\">baseline</span><br></pre></td></tr></table></figure>\n<p>前三个值与 justify-content 属性中的值完全一致，没有太多需要解释的地方。</p>\n<p>但是，接下来两个值却有些不同。</p>\n<p>Stretch 指的是如果项目未设置高度或设为 auto，项目将占满整个容器。而 baseline 是指项目将与段落标签的底部对齐。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204725.gif\" alt=\"\"></p>\n<p>（请注意，对于 align-items：stretch，我不得不将四方体的高度设置为 auto，否则 height 属性将覆盖该 stretch）</p>\n<p>对于 baseline，如果你去掉段落标签，它则会对齐四方形的底部，如下图所示：</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204754.gif\" alt=\"\"></p>\n<p>为了更好地演示主轴和交叉轴的表现，在基于 justify-content 属性和 align-items 属性的值为 center 的情况下，让我们看看赋予 flex-direction 属性两个不同值后，它的表现如何：</p>\n<p>我们可以看到，对于 row 值，四方体沿着与主轴水平方向排列，而对于 column 值，它们则沿着与主轴垂直的方向排列。</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204835.gif\" alt=\"\"></p>\n<h2 id=\"属性-5：Align-Self\"><a href=\"#属性-5：Align-Self\" class=\"headerlink\" title=\"属性 5：Align Self\"></a>属性 5：Align Self</h2><p>align-self 属性允许你对特定的项目有与其他项目不一样的对齐方式，它可覆盖 align-items 属性。虽然它的默认值为 auto，但它继承了父元素 align-items 的属性。除了 auto 外，其他都与 align-items 属性完全一致。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.square</span><span class=\"selector-id\">#one</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-self</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将在四个四方体上应用 align-self 属性，而其余的四方体则应用 align-items:center 与 flex-direction:row，让我们看看会发生什么</p>\n<p><img src=\"https://static.skynian.cn/flex-2018531204920.gif\" alt=\"\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>虽然我们只是仅仅了解了 Flexbox 的一些浅层的用法，但是已足够入门</p>"},{"title":"浅谈JavaScript异步","date":"2018-06-13T15:38:17.000Z","_content":"\n## JavaScript 是单线程？\n\n- JS 引擎中负责解释和执行 JS 代码的线程只有一个（主）\n- AJAX 、处理 DOM 、定时器、读写......（工作线程）\n- 对于耗时或者时间不确定的操作，使用异步\n- HTML5 Web Worker 多线程\n\n<!--more-->\n\n## 异步执行机制\n\n1. 所有同步任务都在主线程执行，形成执行栈\n2. “任务队列”，异步任务的结果存放\n3. 同步任务执行完毕，读取“任务队列”\n4. 主线程不断重复第三步\n5. 主线程阻塞，任务队列依旧能够被推入任务\n\n## Event Loop\n\n主线程从“任务队列”中读取事件，不断循环\n\n![](https://static.skynian.cn/js-async-201861401039.jpg)\n\n## Macrotask 和 Microtask\n\n**macro-tasks：** script (整体代码)，setTimeout，setInterval，setImmediate，I/O，UI\n\n**micro-tasks：** process.nextTick，Promises，Object.observe，MutationObserver（HTML5 新特性）\n\n在一个事件循环里，\n\n这两个队列会分两步执行，\n\n第一步会固定地执行一个（且仅一个）Macrotask 任务，\n\n第二步会执行整个 Microtask 队列中的所有任务。\n\n![](https://static.skynian.cn/js-async-2018614020.png)\n\n> 接下来，我们用代码来感受\n\n```js\nsetTimeout(function() {\n  console.log(\"timeout1\");\n});\n\nnew Promise(resolve => {\n  console.log(\"promise1\");\n\n  for (let i = 0; i < 1000; i++) {\n    i === 99 && resolve();\n  }\n\n  console.log(\"promise2\");\n}).then(() => {\n  console.log(\"then1\");\n});\n\nconsole.log(\"glogal1\");\n```\n\n答案:\n\n```cmd\npromise1\npromise2\nglobal1\nthen1\ntimeout1\n```\n\n## 在线演示\n\n[地址](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n\n![](https://static.skynian.cn/js-async-20186140952.png)\n\n## 作用\n\n**Macrotasks:** 代表一些离散的独立的工作，task 结束后，浏览器继续其他工作如页面重渲染和垃圾回收等\n\n**Microtasks:** 更新完成应用程序状态的较小任务，在 UI 重渲染之前执行某些任务，避免不必要的 UI 渲染\n\n## Vue 中 MutationObserver\n\n[\bhttps://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95](https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95)\n\n```js\nlet counter = 1;\nlet observer = new MutationObserver(nextTickHandler);\nlet textNode = document.createTextNode(String(counter));\nobserver.observe(textNode, {\n  characterData: true\n});\ntimerFunc = () => {\n  counter = (counter + 1) % 2;\n  textNode.data = String(counter);\n};\n```\n\n## JS 异步发展\n\n- Callback\n- Promise\n- Generator\n- Async function\n- rxjs ??\n- ......\n\n## Callback\n\n- 给匿名函数命名\n- 模块化\n- ...\n\n```js\ngetData(function(a){\n    getMoreData(a, function(b){\n        getMoreData(b, function(c){\n            getMoreData(c, function(d){\n                getMoreData(d, function(e){\n                    ...\n                })\n            })\n        })\n    })\n})\n```\n\n## Promise\n\n- 解决了异步回调函数层层嵌套\n- 错误处理以及链式回调\n\n```js\n// 没有 promise\na(getResultFromA, (aResult, err) => {\n  if (!err) {\n    b(getResultFromB, (bResult, err) => {\n      if (!err) {\n        c(getResultFromC, (cResult, err) => {\n          if (!err) {\n            // do something\n          } else {\n            throw err\n          }\n        })\n      } else {\n        throw err\n      }\n    })\n  } else {\n    throw err\n  }\n})\n\n// 用了 promise 后\nnew promise((resolve, reject) => {\n  a(getResultFromA, (aResult, err) => {\n    if (!err) resolve(aResult) else reject(err)\n  })\n})\n.then(data => {\n  return new Promise((resolve, reject) => {\n    b(getResultFromB, (bResult, err) => {\n      if (!err) resolve(bResult) else reject(err)\n    })\n  }\n})\n.then(data => {\n  return new Promise((resolve, reject) => {\n    c(getResultFromC, (cResult, err) => {\n      if (!err) resolve(cResult) else reject(err)\n    })\n  }\n})\n.then(data => {\n  // do something\n})\n.catch(err => {\n  throw err\n})\n```\n\n## Generator\n\n- \"协程\"（coroutine），意思是多个线程互相协作，完成异步任务\n- 流程管理却不方便\n\n```js\n// 定义\nvar fetch = require(\"node-fetch\");\n\nfunction* gen() {\n  var url = \"https://api.github.com/users/github\";\n  var result = yield fetch(url);\n  console.log(result.bio);\n}\n\n// 使用\nvar g = gen();\nvar result = g.next();\n\nresult.value\n  .then(function(data) {\n    return data.json();\n  })\n  .then(function(data) {\n    g.next(data);\n  });\n```\n\n## Async\n\n- 内置执行器\n- 更好的语义\n- 更广的适用性\n- 返回值是 Promise\n\n## Rxjs(流 Stream)\n\nReactive Extensions for JavaScript\n\n观察者 + 迭代器模式\n\nObservables 与 Observer\n\n**订阅：** Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable\n**发布：** Observable 通过回调 next 方法向 Observer 发布事件\n\n[构建流式应用—RxJS 详解(AlloyTeam)](http://www.alloyteam.com/2016/12/learn-rxjs/)\n","source":"_posts/js-async.md","raw":"---\ntitle: 浅谈JavaScript异步\ndate: 2018-06-13 23:38:17\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\n## JavaScript 是单线程？\n\n- JS 引擎中负责解释和执行 JS 代码的线程只有一个（主）\n- AJAX 、处理 DOM 、定时器、读写......（工作线程）\n- 对于耗时或者时间不确定的操作，使用异步\n- HTML5 Web Worker 多线程\n\n<!--more-->\n\n## 异步执行机制\n\n1. 所有同步任务都在主线程执行，形成执行栈\n2. “任务队列”，异步任务的结果存放\n3. 同步任务执行完毕，读取“任务队列”\n4. 主线程不断重复第三步\n5. 主线程阻塞，任务队列依旧能够被推入任务\n\n## Event Loop\n\n主线程从“任务队列”中读取事件，不断循环\n\n![](https://static.skynian.cn/js-async-201861401039.jpg)\n\n## Macrotask 和 Microtask\n\n**macro-tasks：** script (整体代码)，setTimeout，setInterval，setImmediate，I/O，UI\n\n**micro-tasks：** process.nextTick，Promises，Object.observe，MutationObserver（HTML5 新特性）\n\n在一个事件循环里，\n\n这两个队列会分两步执行，\n\n第一步会固定地执行一个（且仅一个）Macrotask 任务，\n\n第二步会执行整个 Microtask 队列中的所有任务。\n\n![](https://static.skynian.cn/js-async-2018614020.png)\n\n> 接下来，我们用代码来感受\n\n```js\nsetTimeout(function() {\n  console.log(\"timeout1\");\n});\n\nnew Promise(resolve => {\n  console.log(\"promise1\");\n\n  for (let i = 0; i < 1000; i++) {\n    i === 99 && resolve();\n  }\n\n  console.log(\"promise2\");\n}).then(() => {\n  console.log(\"then1\");\n});\n\nconsole.log(\"glogal1\");\n```\n\n答案:\n\n```cmd\npromise1\npromise2\nglobal1\nthen1\ntimeout1\n```\n\n## 在线演示\n\n[地址](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n\n![](https://static.skynian.cn/js-async-20186140952.png)\n\n## 作用\n\n**Macrotasks:** 代表一些离散的独立的工作，task 结束后，浏览器继续其他工作如页面重渲染和垃圾回收等\n\n**Microtasks:** 更新完成应用程序状态的较小任务，在 UI 重渲染之前执行某些任务，避免不必要的 UI 渲染\n\n## Vue 中 MutationObserver\n\n[\bhttps://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95](https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95)\n\n```js\nlet counter = 1;\nlet observer = new MutationObserver(nextTickHandler);\nlet textNode = document.createTextNode(String(counter));\nobserver.observe(textNode, {\n  characterData: true\n});\ntimerFunc = () => {\n  counter = (counter + 1) % 2;\n  textNode.data = String(counter);\n};\n```\n\n## JS 异步发展\n\n- Callback\n- Promise\n- Generator\n- Async function\n- rxjs ??\n- ......\n\n## Callback\n\n- 给匿名函数命名\n- 模块化\n- ...\n\n```js\ngetData(function(a){\n    getMoreData(a, function(b){\n        getMoreData(b, function(c){\n            getMoreData(c, function(d){\n                getMoreData(d, function(e){\n                    ...\n                })\n            })\n        })\n    })\n})\n```\n\n## Promise\n\n- 解决了异步回调函数层层嵌套\n- 错误处理以及链式回调\n\n```js\n// 没有 promise\na(getResultFromA, (aResult, err) => {\n  if (!err) {\n    b(getResultFromB, (bResult, err) => {\n      if (!err) {\n        c(getResultFromC, (cResult, err) => {\n          if (!err) {\n            // do something\n          } else {\n            throw err\n          }\n        })\n      } else {\n        throw err\n      }\n    })\n  } else {\n    throw err\n  }\n})\n\n// 用了 promise 后\nnew promise((resolve, reject) => {\n  a(getResultFromA, (aResult, err) => {\n    if (!err) resolve(aResult) else reject(err)\n  })\n})\n.then(data => {\n  return new Promise((resolve, reject) => {\n    b(getResultFromB, (bResult, err) => {\n      if (!err) resolve(bResult) else reject(err)\n    })\n  }\n})\n.then(data => {\n  return new Promise((resolve, reject) => {\n    c(getResultFromC, (cResult, err) => {\n      if (!err) resolve(cResult) else reject(err)\n    })\n  }\n})\n.then(data => {\n  // do something\n})\n.catch(err => {\n  throw err\n})\n```\n\n## Generator\n\n- \"协程\"（coroutine），意思是多个线程互相协作，完成异步任务\n- 流程管理却不方便\n\n```js\n// 定义\nvar fetch = require(\"node-fetch\");\n\nfunction* gen() {\n  var url = \"https://api.github.com/users/github\";\n  var result = yield fetch(url);\n  console.log(result.bio);\n}\n\n// 使用\nvar g = gen();\nvar result = g.next();\n\nresult.value\n  .then(function(data) {\n    return data.json();\n  })\n  .then(function(data) {\n    g.next(data);\n  });\n```\n\n## Async\n\n- 内置执行器\n- 更好的语义\n- 更广的适用性\n- 返回值是 Promise\n\n## Rxjs(流 Stream)\n\nReactive Extensions for JavaScript\n\n观察者 + 迭代器模式\n\nObservables 与 Observer\n\n**订阅：** Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable\n**发布：** Observable 通过回调 next 方法向 Observer 发布事件\n\n[构建流式应用—RxJS 详解(AlloyTeam)](http://www.alloyteam.com/2016/12/learn-rxjs/)\n","slug":"js-async","published":1,"updated":"2018-12-25T07:25:37.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2iel0009gzq295qjvk5i","content":"<h2 id=\"JavaScript-是单线程？\"><a href=\"#JavaScript-是单线程？\" class=\"headerlink\" title=\"JavaScript 是单线程？\"></a>JavaScript 是单线程？</h2><ul>\n<li>JS 引擎中负责解释和执行 JS 代码的线程只有一个（主）</li>\n<li>AJAX 、处理 DOM 、定时器、读写……（工作线程）</li>\n<li>对于耗时或者时间不确定的操作，使用异步</li>\n<li>HTML5 Web Worker 多线程</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"异步执行机制\"><a href=\"#异步执行机制\" class=\"headerlink\" title=\"异步执行机制\"></a>异步执行机制</h2><ol>\n<li>所有同步任务都在主线程执行，形成执行栈</li>\n<li>“任务队列”，异步任务的结果存放</li>\n<li>同步任务执行完毕，读取“任务队列”</li>\n<li>主线程不断重复第三步</li>\n<li>主线程阻塞，任务队列依旧能够被推入任务</li>\n</ol>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>主线程从“任务队列”中读取事件，不断循环</p>\n<p><img src=\"https://static.skynian.cn/js-async-201861401039.jpg\" alt=\"\"></p>\n<h2 id=\"Macrotask-和-Microtask\"><a href=\"#Macrotask-和-Microtask\" class=\"headerlink\" title=\"Macrotask 和 Microtask\"></a>Macrotask 和 Microtask</h2><p><strong>macro-tasks：</strong> script (整体代码)，setTimeout，setInterval，setImmediate，I/O，UI</p>\n<p><strong>micro-tasks：</strong> process.nextTick，Promises，Object.observe，MutationObserver（HTML5 新特性）</p>\n<p>在一个事件循环里，</p>\n<p>这两个队列会分两步执行，</p>\n<p>第一步会固定地执行一个（且仅一个）Macrotask 任务，</p>\n<p>第二步会执行整个 Microtask 队列中的所有任务。</p>\n<p><img src=\"https://static.skynian.cn/js-async-2018614020.png\" alt=\"\"></p>\n<blockquote>\n<p>接下来，我们用代码来感受</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"timeout1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    i === <span class=\"number\">99</span> &amp;&amp; resolve();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise2\"</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"then1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"glogal1\"</span>);</span><br></pre></td></tr></table></figure>\n<p>答案:</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">global1</span><br><span class=\"line\">then1</span><br><span class=\"line\">timeout1</span><br></pre></td></tr></table></figure>\n<h2 id=\"在线演示\"><a href=\"#在线演示\" class=\"headerlink\" title=\"在线演示\"></a>在线演示</h2><p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n<p><img src=\"https://static.skynian.cn/js-async-20186140952.png\" alt=\"\"></p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p><strong>Macrotasks:</strong> 代表一些离散的独立的工作，task 结束后，浏览器继续其他工作如页面重渲染和垃圾回收等</p>\n<p><strong>Microtasks:</strong> 更新完成应用程序状态的较小任务，在 UI 重渲染之前执行某些任务，避免不必要的 UI 渲染</p>\n<h2 id=\"Vue-中-MutationObserver\"><a href=\"#Vue-中-MutationObserver\" class=\"headerlink\" title=\"Vue 中 MutationObserver\"></a>Vue 中 MutationObserver</h2><p><a href=\"https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95\" target=\"_blank\" rel=\"noopener\">\bhttps://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> counter = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> observer = <span class=\"keyword\">new</span> MutationObserver(nextTickHandler);</span><br><span class=\"line\"><span class=\"keyword\">let</span> textNode = <span class=\"built_in\">document</span>.createTextNode(<span class=\"built_in\">String</span>(counter));</span><br><span class=\"line\">observer.observe(textNode, &#123;</span><br><span class=\"line\">  characterData: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">timerFunc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  counter = (counter + <span class=\"number\">1</span>) % <span class=\"number\">2</span>;</span><br><span class=\"line\">  textNode.data = <span class=\"built_in\">String</span>(counter);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS-异步发展\"><a href=\"#JS-异步发展\" class=\"headerlink\" title=\"JS 异步发展\"></a>JS 异步发展</h2><ul>\n<li>Callback</li>\n<li>Promise</li>\n<li>Generator</li>\n<li>Async function</li>\n<li>rxjs ??</li>\n<li>……</li>\n</ul>\n<h2 id=\"Callback\"><a href=\"#Callback\" class=\"headerlink\" title=\"Callback\"></a>Callback</h2><ul>\n<li>给匿名函数命名</li>\n<li>模块化</li>\n<li>…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getData(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    getMoreData(a, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">        getMoreData(b, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">            getMoreData(c, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123;</span><br><span class=\"line\">                getMoreData(d, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><ul>\n<li>解决了异步回调函数层层嵌套</li>\n<li>错误处理以及链式回调</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有 promise</span></span><br><span class=\"line\">a(getResultFromA, (aResult, err) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">    b(getResultFromB, (bResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">        c(getResultFromC, (cResult, err) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用了 promise 后</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  a(getResultFromA, (aResult, err) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err) resolve(aResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    b(getResultFromB, (bResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) resolve(bResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    c(getResultFromC, (cResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) resolve(cResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><ul>\n<li>“协程”（coroutine），意思是多个线程互相协作，完成异步任务</li>\n<li>流程管理却不方便</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">\"node-fetch\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"string\">\"https://api.github.com/users/github\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result.bio);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen();</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = g.next();</span><br><span class=\"line\"></span><br><span class=\"line\">result.value</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.json();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    g.next(data);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><ul>\n<li>内置执行器</li>\n<li>更好的语义</li>\n<li>更广的适用性</li>\n<li>返回值是 Promise</li>\n</ul>\n<h2 id=\"Rxjs-流-Stream\"><a href=\"#Rxjs-流-Stream\" class=\"headerlink\" title=\"Rxjs(流 Stream)\"></a>Rxjs(流 Stream)</h2><p>Reactive Extensions for JavaScript</p>\n<p>观察者 + 迭代器模式</p>\n<p>Observables 与 Observer</p>\n<p><strong>订阅：</strong> Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable<br><strong>发布：</strong> Observable 通过回调 next 方法向 Observer 发布事件</p>\n<p><a href=\"http://www.alloyteam.com/2016/12/learn-rxjs/\" target=\"_blank\" rel=\"noopener\">构建流式应用—RxJS 详解(AlloyTeam)</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<h2 id=\"JavaScript-是单线程？\"><a href=\"#JavaScript-是单线程？\" class=\"headerlink\" title=\"JavaScript 是单线程？\"></a>JavaScript 是单线程？</h2><ul>\n<li>JS 引擎中负责解释和执行 JS 代码的线程只有一个（主）</li>\n<li>AJAX 、处理 DOM 、定时器、读写……（工作线程）</li>\n<li>对于耗时或者时间不确定的操作，使用异步</li>\n<li>HTML5 Web Worker 多线程</li>\n</ul>","more":"<h2 id=\"异步执行机制\"><a href=\"#异步执行机制\" class=\"headerlink\" title=\"异步执行机制\"></a>异步执行机制</h2><ol>\n<li>所有同步任务都在主线程执行，形成执行栈</li>\n<li>“任务队列”，异步任务的结果存放</li>\n<li>同步任务执行完毕，读取“任务队列”</li>\n<li>主线程不断重复第三步</li>\n<li>主线程阻塞，任务队列依旧能够被推入任务</li>\n</ol>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>主线程从“任务队列”中读取事件，不断循环</p>\n<p><img src=\"https://static.skynian.cn/js-async-201861401039.jpg\" alt=\"\"></p>\n<h2 id=\"Macrotask-和-Microtask\"><a href=\"#Macrotask-和-Microtask\" class=\"headerlink\" title=\"Macrotask 和 Microtask\"></a>Macrotask 和 Microtask</h2><p><strong>macro-tasks：</strong> script (整体代码)，setTimeout，setInterval，setImmediate，I/O，UI</p>\n<p><strong>micro-tasks：</strong> process.nextTick，Promises，Object.observe，MutationObserver（HTML5 新特性）</p>\n<p>在一个事件循环里，</p>\n<p>这两个队列会分两步执行，</p>\n<p>第一步会固定地执行一个（且仅一个）Macrotask 任务，</p>\n<p>第二步会执行整个 Microtask 队列中的所有任务。</p>\n<p><img src=\"https://static.skynian.cn/js-async-2018614020.png\" alt=\"\"></p>\n<blockquote>\n<p>接下来，我们用代码来感受</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"timeout1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    i === <span class=\"number\">99</span> &amp;&amp; resolve();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise2\"</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"then1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"glogal1\"</span>);</span><br></pre></td></tr></table></figure>\n<p>答案:</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">global1</span><br><span class=\"line\">then1</span><br><span class=\"line\">timeout1</span><br></pre></td></tr></table></figure>\n<h2 id=\"在线演示\"><a href=\"#在线演示\" class=\"headerlink\" title=\"在线演示\"></a>在线演示</h2><p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n<p><img src=\"https://static.skynian.cn/js-async-20186140952.png\" alt=\"\"></p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p><strong>Macrotasks:</strong> 代表一些离散的独立的工作，task 结束后，浏览器继续其他工作如页面重渲染和垃圾回收等</p>\n<p><strong>Microtasks:</strong> 更新完成应用程序状态的较小任务，在 UI 重渲染之前执行某些任务，避免不必要的 UI 渲染</p>\n<h2 id=\"Vue-中-MutationObserver\"><a href=\"#Vue-中-MutationObserver\" class=\"headerlink\" title=\"Vue 中 MutationObserver\"></a>Vue 中 MutationObserver</h2><p><a href=\"https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95\" target=\"_blank\" rel=\"noopener\">\bhttps://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> counter = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> observer = <span class=\"keyword\">new</span> MutationObserver(nextTickHandler);</span><br><span class=\"line\"><span class=\"keyword\">let</span> textNode = <span class=\"built_in\">document</span>.createTextNode(<span class=\"built_in\">String</span>(counter));</span><br><span class=\"line\">observer.observe(textNode, &#123;</span><br><span class=\"line\">  characterData: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">timerFunc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  counter = (counter + <span class=\"number\">1</span>) % <span class=\"number\">2</span>;</span><br><span class=\"line\">  textNode.data = <span class=\"built_in\">String</span>(counter);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS-异步发展\"><a href=\"#JS-异步发展\" class=\"headerlink\" title=\"JS 异步发展\"></a>JS 异步发展</h2><ul>\n<li>Callback</li>\n<li>Promise</li>\n<li>Generator</li>\n<li>Async function</li>\n<li>rxjs ??</li>\n<li>……</li>\n</ul>\n<h2 id=\"Callback\"><a href=\"#Callback\" class=\"headerlink\" title=\"Callback\"></a>Callback</h2><ul>\n<li>给匿名函数命名</li>\n<li>模块化</li>\n<li>…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getData(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    getMoreData(a, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">        getMoreData(b, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">            getMoreData(c, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123;</span><br><span class=\"line\">                getMoreData(d, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><ul>\n<li>解决了异步回调函数层层嵌套</li>\n<li>错误处理以及链式回调</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有 promise</span></span><br><span class=\"line\">a(getResultFromA, (aResult, err) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">    b(getResultFromB, (bResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">        c(getResultFromC, (cResult, err) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用了 promise 后</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  a(getResultFromA, (aResult, err) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err) resolve(aResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    b(getResultFromB, (bResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) resolve(bResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    c(getResultFromC, (cResult, err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!err) resolve(cResult) <span class=\"keyword\">else</span> reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><ul>\n<li>“协程”（coroutine），意思是多个线程互相协作，完成异步任务</li>\n<li>流程管理却不方便</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">\"node-fetch\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"string\">\"https://api.github.com/users/github\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result.bio);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen();</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = g.next();</span><br><span class=\"line\"></span><br><span class=\"line\">result.value</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.json();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    g.next(data);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><ul>\n<li>内置执行器</li>\n<li>更好的语义</li>\n<li>更广的适用性</li>\n<li>返回值是 Promise</li>\n</ul>\n<h2 id=\"Rxjs-流-Stream\"><a href=\"#Rxjs-流-Stream\" class=\"headerlink\" title=\"Rxjs(流 Stream)\"></a>Rxjs(流 Stream)</h2><p>Reactive Extensions for JavaScript</p>\n<p>观察者 + 迭代器模式</p>\n<p>Observables 与 Observer</p>\n<p><strong>订阅：</strong> Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable<br><strong>发布：</strong> Observable 通过回调 next 方法向 Observer 发布事件</p>\n<p><a href=\"http://www.alloyteam.com/2016/12/learn-rxjs/\" target=\"_blank\" rel=\"noopener\">构建流式应用—RxJS 详解(AlloyTeam)</a></p>"},{"title":"前端模块化","date":"2018-06-17T04:25:39.000Z","_content":"\n模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 [module-loader](https://note.youdao.com/)。\n\n<!--more-->\n\n## \b 一、CommonJS\n\nNode.js 是 commonJS 规范的主要时间者，它有四个重要的环境变量为模块化的实现提供支持：\n**module**、\b**exports**、**require**、**global**。\n\n实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用 exports），用 require 加载模块\n\n```js\n// 定义模块 math.js\n\nlet basicNum = 0\n\nfunction add(a, b) {\n  return a + b\n}\n\n// 在这里写需要向外暴露的函数、变量\nmodule.exports = {\n  add,\n  basicNum: basicNum,\n}\n\n// 引用自定义的模块，参数包含路径，可省略 .js\nlet math = require('./math')\nmath.add(2, 5)\n\n// 引用核心模块时，不需要带路径\nlet http = require('http')\nhttp.createService(...).listen(3000)\n```\n\ncommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\n\n## 二、AMD 和 require.js\n\nAMD: 提前执行（异步加载：依赖先执行 + 延迟执行）\n\nAMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。\n\n由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS，实际上 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。\n\n\bAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行。\n\n这里介绍用 require.js 实现 AMD 规范的模块化：\n\n用 **require.config()** 指定引用路径，用 **define()** 定义模块，用 require() 加载模块\n\n首先我们需要引入 require.js 文件和一个入口文件 main.js。 main.js 中配置 require.config() 并规定项目中用到的基础模块。\n\n```js\n// 网页中引入 require.js 及 main.js\n<script src=\"js/require.js\" data-main=\"js/main\" />;\n\n// main.js 入口文件/主模块\n// 首先用 config() 指定各模块\b路径和引用名\nrequire.config({\n  baseUrl: \"js/lib\",\n  paths: {\n    jquery: \"jquery.min\",\n    underscore: \"underscore.min\"\n  }\n});\n\n// 执行基本操作\nrequire([\"jqery\", \"underscore\"], function($, _) {\n  // some code here\n});\n```\n\n引用模块的时候，我们将模块名放在[]中作为 reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为 define()的第一参数。\n\n```js\n// 定义math.js模块\ndefine(function() {\n  let basicNum = 0;\n  let add = function(x, y) {\n    return x + y;\n  };\n  return {\n    add,\n    basicNum: basicNum\n  };\n});\n// 定义一个依赖underscore.js的模块\ndefine([\"underscore\"], function(_) {\n  let classify = function(list) {\n    _.countBy(list, function(num) {\n      return num > 30 ? \"old\" : \"young\";\n    });\n  };\n  return {\n    classify\n  };\n});\n\n// 引用模块，将模块放在[]内\nrequire([\"jquery\", \"math\"], function($, math) {\n  var sum = math.add(10, 20);\n  $(\"#sum\").html(sum);\n});\n```\n\n## 三、CMD 和 sea.js\n\nCMD: 延迟执行（运行到需加载，根据顺序执行）\n\nCMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n\nrequire.js 在申明依赖的模块时会在第一时间加载并执行模块内的代码：\n\n```js\n// AMD 写法\ndefine([\"a\", \"b\", \"c\"], function(a, b, c) {\n  // 等于在最前面声明并初始化了要用到的所有模块\n  if (false) {\n    // 即便没用到某个模块，但 b 还是提前执行了\n    b.foo();\n  }\n});\n\n// CMD 写法\ndefine(function(require, exports, module) {\n  let a = require(\"./a\"); //在需要时申明\n\n  a.doSomething();\n\n  if (false) {\n    var b = require(\"./b\");\n    b.doSomething();\n  }\n});\n\n// sea.js\n// 定义模块 math.js\ndefine(function(require, exports, module) {\n  let $ = require(\"jquery.js\");\n  var add = function(a, b) {\n    return a + b;\n  };\n  exports.add = add;\n});\n// 加载模块\nseajs.use([\"math.js\"], function(math) {\n  let sum = math.add(1 + 2);\n});\n```\n\n四、ES6 Module\n\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。\n\n```js\n// 定义模块 math.js\nlet basicNum = 0;\nlet add = function(a, b) {\n  return a + b;\n};\n\nexport { basicNum, add };\n\n// 引用模块\nimport { basicNum, add } from \"./math\";\n\nfunction test(ele) {\n  ele.textContent = add(99 + basicNum);\n}\n```\n\n如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名。其实 ES6 还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号。这也更趋近于 ADM 的引用写法。\n\n```js\n// export default\n// 定义输出\nexport default { basicNum, add };\n// 引入\nimport math from \"./math\";\n\nfunction test(ele) {\n  ele.textContent = math.add(99 + math.basicNum);\n}\n```\n\nES6 的模块不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\n## 五、ES6 模块与 CommonJS 模块的差异\n\n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\n- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n- 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。\n\nCommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n","source":"_posts/module.md","raw":"---\ntitle: 前端模块化\ndate: 2018-06-17 12:25:39\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\n模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 [module-loader](https://note.youdao.com/)。\n\n<!--more-->\n\n## \b 一、CommonJS\n\nNode.js 是 commonJS 规范的主要时间者，它有四个重要的环境变量为模块化的实现提供支持：\n**module**、\b**exports**、**require**、**global**。\n\n实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用 exports），用 require 加载模块\n\n```js\n// 定义模块 math.js\n\nlet basicNum = 0\n\nfunction add(a, b) {\n  return a + b\n}\n\n// 在这里写需要向外暴露的函数、变量\nmodule.exports = {\n  add,\n  basicNum: basicNum,\n}\n\n// 引用自定义的模块，参数包含路径，可省略 .js\nlet math = require('./math')\nmath.add(2, 5)\n\n// 引用核心模块时，不需要带路径\nlet http = require('http')\nhttp.createService(...).listen(3000)\n```\n\ncommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\n\n## 二、AMD 和 require.js\n\nAMD: 提前执行（异步加载：依赖先执行 + 延迟执行）\n\nAMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。\n\n由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS，实际上 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。\n\n\bAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行。\n\n这里介绍用 require.js 实现 AMD 规范的模块化：\n\n用 **require.config()** 指定引用路径，用 **define()** 定义模块，用 require() 加载模块\n\n首先我们需要引入 require.js 文件和一个入口文件 main.js。 main.js 中配置 require.config() 并规定项目中用到的基础模块。\n\n```js\n// 网页中引入 require.js 及 main.js\n<script src=\"js/require.js\" data-main=\"js/main\" />;\n\n// main.js 入口文件/主模块\n// 首先用 config() 指定各模块\b路径和引用名\nrequire.config({\n  baseUrl: \"js/lib\",\n  paths: {\n    jquery: \"jquery.min\",\n    underscore: \"underscore.min\"\n  }\n});\n\n// 执行基本操作\nrequire([\"jqery\", \"underscore\"], function($, _) {\n  // some code here\n});\n```\n\n引用模块的时候，我们将模块名放在[]中作为 reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为 define()的第一参数。\n\n```js\n// 定义math.js模块\ndefine(function() {\n  let basicNum = 0;\n  let add = function(x, y) {\n    return x + y;\n  };\n  return {\n    add,\n    basicNum: basicNum\n  };\n});\n// 定义一个依赖underscore.js的模块\ndefine([\"underscore\"], function(_) {\n  let classify = function(list) {\n    _.countBy(list, function(num) {\n      return num > 30 ? \"old\" : \"young\";\n    });\n  };\n  return {\n    classify\n  };\n});\n\n// 引用模块，将模块放在[]内\nrequire([\"jquery\", \"math\"], function($, math) {\n  var sum = math.add(10, 20);\n  $(\"#sum\").html(sum);\n});\n```\n\n## 三、CMD 和 sea.js\n\nCMD: 延迟执行（运行到需加载，根据顺序执行）\n\nCMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n\nrequire.js 在申明依赖的模块时会在第一时间加载并执行模块内的代码：\n\n```js\n// AMD 写法\ndefine([\"a\", \"b\", \"c\"], function(a, b, c) {\n  // 等于在最前面声明并初始化了要用到的所有模块\n  if (false) {\n    // 即便没用到某个模块，但 b 还是提前执行了\n    b.foo();\n  }\n});\n\n// CMD 写法\ndefine(function(require, exports, module) {\n  let a = require(\"./a\"); //在需要时申明\n\n  a.doSomething();\n\n  if (false) {\n    var b = require(\"./b\");\n    b.doSomething();\n  }\n});\n\n// sea.js\n// 定义模块 math.js\ndefine(function(require, exports, module) {\n  let $ = require(\"jquery.js\");\n  var add = function(a, b) {\n    return a + b;\n  };\n  exports.add = add;\n});\n// 加载模块\nseajs.use([\"math.js\"], function(math) {\n  let sum = math.add(1 + 2);\n});\n```\n\n四、ES6 Module\n\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。\n\n```js\n// 定义模块 math.js\nlet basicNum = 0;\nlet add = function(a, b) {\n  return a + b;\n};\n\nexport { basicNum, add };\n\n// 引用模块\nimport { basicNum, add } from \"./math\";\n\nfunction test(ele) {\n  ele.textContent = add(99 + basicNum);\n}\n```\n\n如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名。其实 ES6 还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号。这也更趋近于 ADM 的引用写法。\n\n```js\n// export default\n// 定义输出\nexport default { basicNum, add };\n// 引入\nimport math from \"./math\";\n\nfunction test(ele) {\n  ele.textContent = math.add(99 + math.basicNum);\n}\n```\n\nES6 的模块不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\n## 五、ES6 模块与 CommonJS 模块的差异\n\n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\n- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n- 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。\n\nCommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n","slug":"module","published":1,"updated":"2018-12-25T07:25:40.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2iem000agzq24hxbj5zm","content":"<p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 <a href=\"https://note.youdao.com/\" target=\"_blank\" rel=\"noopener\">module-loader</a>。</p>\n<a id=\"more\"></a>\n<h2 id=\"一、CommonJS\"><a href=\"#一、CommonJS\" class=\"headerlink\" title=\"\b 一、CommonJS\"></a>\b 一、CommonJS</h2><p>Node.js 是 commonJS 规范的主要时间者，它有四个重要的环境变量为模块化的实现提供支持：<br><strong>module</strong>、\b<strong>exports</strong>、<strong>require</strong>、<strong>global</strong>。</p>\n<p>实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用 exports），用 require 加载模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在这里写需要向外暴露的函数、变量</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  add,</span><br><span class=\"line\">  basicNum: basicNum,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用自定义的模块，参数包含路径，可省略 .js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'./math'</span>)</span><br><span class=\"line\">math.add(<span class=\"number\">2</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用核心模块时，不需要带路径</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</span><br><span class=\"line\">http.createService(...).listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>commonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>\n<h2 id=\"二、AMD-和-require-js\"><a href=\"#二、AMD-和-require-js\" class=\"headerlink\" title=\"二、AMD 和 require.js\"></a>二、AMD 和 require.js</h2><p>AMD: 提前执行（异步加载：依赖先执行 + 延迟执行）</p>\n<p>AMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。</p>\n<p>由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS，实际上 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。</p>\n<p>\bAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行。</p>\n<p>这里介绍用 require.js 实现 AMD 规范的模块化：</p>\n<p>用 <strong>require.config()</strong> 指定引用路径，用 <strong>define()</strong> 定义模块，用 require() 加载模块</p>\n<p>首先我们需要引入 require.js 文件和一个入口文件 main.js。 main.js 中配置 require.config() 并规定项目中用到的基础模块。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 网页中引入 require.js 及 main.js</span></span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"js/require.js\"</span> data-main=<span class=\"string\">\"js/main\"</span> /&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js 入口文件/主模块</span></span><br><span class=\"line\"><span class=\"comment\">// 首先用 config() 指定各模块\b路径和引用名</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">  baseUrl: <span class=\"string\">\"js/lib\"</span>,</span><br><span class=\"line\">  paths: &#123;</span><br><span class=\"line\">    jquery: <span class=\"string\">\"jquery.min\"</span>,</span><br><span class=\"line\">    underscore: <span class=\"string\">\"underscore.min\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行基本操作</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"jqery\"</span>, <span class=\"string\">\"underscore\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, _</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code here</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>引用模块的时候，我们将模块名放在[]中作为 reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为 define()的第一参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义math.js模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    add,</span><br><span class=\"line\">    basicNum: basicNum</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 定义一个依赖underscore.js的模块</span></span><br><span class=\"line\">define([<span class=\"string\">\"underscore\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> classify = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    _.countBy(list, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> num &gt; <span class=\"number\">30</span> ? <span class=\"string\">\"old\"</span> : <span class=\"string\">\"young\"</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    classify</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用模块，将模块放在[]内</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"jquery\"</span>, <span class=\"string\">\"math\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, math</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = math.add(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  $(<span class=\"string\">\"#sum\"</span>).html(sum);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、CMD-和-sea-js\"><a href=\"#三、CMD-和-sea-js\" class=\"headerlink\" title=\"三、CMD 和 sea.js\"></a>三、CMD 和 sea.js</h2><p>CMD: 延迟执行（运行到需加载，根据顺序执行）</p>\n<p>CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>\n<p>require.js 在申明依赖的模块时会在第一时间加载并执行模块内的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AMD 写法</span></span><br><span class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 即便没用到某个模块，但 b 还是提前执行了</span></span><br><span class=\"line\">    b.foo();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CMD 写法</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>); <span class=\"comment\">//在需要时申明</span></span><br><span class=\"line\"></span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">\"./b\"</span>);</span><br><span class=\"line\">    b.doSomething();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sea.js</span></span><br><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">\"jquery.js\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  exports.add = add;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 加载模块</span></span><br><span class=\"line\">seajs.use([<span class=\"string\">\"math.js\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = math.add(<span class=\"number\">1</span> + <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>四、ES6 Module</p>\n<p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; basicNum, add &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; basicNum, add &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">  ele.textContent = add(<span class=\"number\">99</span> + basicNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名。其实 ES6 还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号。这也更趋近于 ADM 的引用写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export default</span></span><br><span class=\"line\"><span class=\"comment\">// 定义输出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123; basicNum, add &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> math <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">  ele.textContent = math.add(<span class=\"number\">99</span> + math.basicNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6 的模块不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>\n<h2 id=\"五、ES6-模块与-CommonJS-模块的差异\"><a href=\"#五、ES6-模块与-CommonJS-模块的差异\" class=\"headerlink\" title=\"五、ES6 模块与 CommonJS 模块的差异\"></a>五、ES6 模块与 CommonJS 模块的差异</h2><ol>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>\n</ol>\n<ul>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n<ol start=\"2\">\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>\n</ol>\n<ul>\n<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n<p>CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 <a href=\"https://note.youdao.com/\" target=\"_blank\" rel=\"noopener\">module-loader</a>。</p>","more":"<h2 id=\"一、CommonJS\"><a href=\"#一、CommonJS\" class=\"headerlink\" title=\"\b 一、CommonJS\"></a>\b 一、CommonJS</h2><p>Node.js 是 commonJS 规范的主要时间者，它有四个重要的环境变量为模块化的实现提供支持：<br><strong>module</strong>、\b<strong>exports</strong>、<strong>require</strong>、<strong>global</strong>。</p>\n<p>实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用 exports），用 require 加载模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在这里写需要向外暴露的函数、变量</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  add,</span><br><span class=\"line\">  basicNum: basicNum,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用自定义的模块，参数包含路径，可省略 .js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'./math'</span>)</span><br><span class=\"line\">math.add(<span class=\"number\">2</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用核心模块时，不需要带路径</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</span><br><span class=\"line\">http.createService(...).listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>commonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>\n<h2 id=\"二、AMD-和-require-js\"><a href=\"#二、AMD-和-require-js\" class=\"headerlink\" title=\"二、AMD 和 require.js\"></a>二、AMD 和 require.js</h2><p>AMD: 提前执行（异步加载：依赖先执行 + 延迟执行）</p>\n<p>AMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。</p>\n<p>由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS，实际上 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。</p>\n<p>\bAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，这个回调函数才会运行。</p>\n<p>这里介绍用 require.js 实现 AMD 规范的模块化：</p>\n<p>用 <strong>require.config()</strong> 指定引用路径，用 <strong>define()</strong> 定义模块，用 require() 加载模块</p>\n<p>首先我们需要引入 require.js 文件和一个入口文件 main.js。 main.js 中配置 require.config() 并规定项目中用到的基础模块。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 网页中引入 require.js 及 main.js</span></span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"js/require.js\"</span> data-main=<span class=\"string\">\"js/main\"</span> /&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js 入口文件/主模块</span></span><br><span class=\"line\"><span class=\"comment\">// 首先用 config() 指定各模块\b路径和引用名</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">  baseUrl: <span class=\"string\">\"js/lib\"</span>,</span><br><span class=\"line\">  paths: &#123;</span><br><span class=\"line\">    jquery: <span class=\"string\">\"jquery.min\"</span>,</span><br><span class=\"line\">    underscore: <span class=\"string\">\"underscore.min\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行基本操作</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"jqery\"</span>, <span class=\"string\">\"underscore\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, _</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code here</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>引用模块的时候，我们将模块名放在[]中作为 reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为 define()的第一参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义math.js模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    add,</span><br><span class=\"line\">    basicNum: basicNum</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 定义一个依赖underscore.js的模块</span></span><br><span class=\"line\">define([<span class=\"string\">\"underscore\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> classify = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    _.countBy(list, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> num &gt; <span class=\"number\">30</span> ? <span class=\"string\">\"old\"</span> : <span class=\"string\">\"young\"</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    classify</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用模块，将模块放在[]内</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"jquery\"</span>, <span class=\"string\">\"math\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$, math</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = math.add(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  $(<span class=\"string\">\"#sum\"</span>).html(sum);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、CMD-和-sea-js\"><a href=\"#三、CMD-和-sea-js\" class=\"headerlink\" title=\"三、CMD 和 sea.js\"></a>三、CMD 和 sea.js</h2><p>CMD: 延迟执行（运行到需加载，根据顺序执行）</p>\n<p>CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>\n<p>require.js 在申明依赖的模块时会在第一时间加载并执行模块内的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AMD 写法</span></span><br><span class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 即便没用到某个模块，但 b 还是提前执行了</span></span><br><span class=\"line\">    b.foo();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CMD 写法</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>); <span class=\"comment\">//在需要时申明</span></span><br><span class=\"line\"></span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">\"./b\"</span>);</span><br><span class=\"line\">    b.doSomething();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sea.js</span></span><br><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">\"jquery.js\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  exports.add = add;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 加载模块</span></span><br><span class=\"line\">seajs.use([<span class=\"string\">\"math.js\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = math.add(<span class=\"number\">1</span> + <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>四、ES6 Module</p>\n<p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块 math.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> basicNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; basicNum, add &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; basicNum, add &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">  ele.textContent = add(<span class=\"number\">99</span> + basicNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名。其实 ES6 还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号。这也更趋近于 ADM 的引用写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export default</span></span><br><span class=\"line\"><span class=\"comment\">// 定义输出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123; basicNum, add &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> math <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">  ele.textContent = math.add(<span class=\"number\">99</span> + math.basicNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6 的模块不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>\n<h2 id=\"五、ES6-模块与-CommonJS-模块的差异\"><a href=\"#五、ES6-模块与-CommonJS-模块的差异\" class=\"headerlink\" title=\"五、ES6 模块与 CommonJS 模块的差异\"></a>五、ES6 模块与 CommonJS 模块的差异</h2><ol>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>\n</ol>\n<ul>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n<ol start=\"2\">\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>\n</ol>\n<ul>\n<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n<p>CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>"},{"title":"现代 JavaScript 与 CSS 滚动实现简析","date":"2018-06-18T09:20:13.000Z","_content":"\n## 页面滚动条引发的抖动出发\n\n为了实现简单的水平居中布局，我们没少使用 margin: 0 auto； 来实现。\n\n然而，这种布局一直存在一个影响用户体验的隐患。我们都知道，现代浏览器滚动条默认是 overflow: auto 类型的，也就是如果尺寸不足一屏，没有滚动条；超出，出现滚动条...\n\n那么，问题来了 -\\_- !\n\n首先是简单的信息流页面，是从上往下 push 渲染的，如果信息没有超出一屏，都很好说，但是如果超出，那么滚动条就会出现，自然\nmargin: 0 auto; 主体元素就会做偏移，用户就会很明显感受到屏幕的抖动\n\n其他场景，比如，点击加载更多，或者 Tab 切换到有滚动条的区块，都会感觉到抖动。\n\n公司的 Web 产品一直存在这个问题，我个人觉得这个很影响体验，所以找了不少资料，也找了不少方案，在这里做一次总结。\n\n- 高度确认的，可以用 CSS 把页面尺寸布局骨架搭好，再往里面渲染数据。这样子的话，要么没有滚动条，要么数据直接出现，不会出现跳动，但是这样方式还是存在局限性\n- 还有一种简单粗暴的方式，直接设置 overflow: scroll，这就意味着，即使是在高度较小的时候，也会出现一个滚动条，而且貌似也不好看，存在的意义不明。\n\n经过查找，有一种方式，算是比较匹配我的需求\n\n使用 CSS3 计算 calc 和 vw 单位巧妙实现\n\n可以简单为容器设置样式：\n\n```css\n.wrap-outer {\n  margin-left: calc(100vw - 100%);\n}\n\n// 或者\n\n.wrap-outer {\n  padding-left: calc(100vw - 100%);\n}\n```\n\n100vw 相对于 \b 浏览器的 window.innerWidth ，是浏览器的内部宽度，这里包括了滚动条的宽度，而我们所使用的 100% 是不包含滚动条宽度的\n\n于是我们就可以愉快的实现不抖动的需求了\n\n兼容性方面的话，支持 IE9+ 以及其他现代浏览器\n\n## 消逝的滚动条\n\n既然讲到了滚动条，后面自己也查阅的不少资料，\b 可以 \b 了解一些相关历史。\n\n![](https://static.skynian.cn/scroll-bar-2018618175358.png)\n\n（windows 上面的滚动条变化历程）\n\n![](https://static.skynian.cn/scroll-bar-2018618175513.png)\n\n（Mac 上面的滚动条）\n\n在这里大赞 Mac，从 2011 年开始，所有的滚动条均从 Mac 电脑消失，不再占据任何页面空间，只有用户触发滚动时才会重新出现，当然用户可以设置默认显示。\n\n对于开发者和设计师来说，这真的是一个好消息，毕竟计算滚动条的宽度总是不够优雅。\n\n可是！\b 划重点！\n\n我们平时可能要使用各种各样的操作系统和浏览器，并且对滚动条的实现方式又各不同，所以我们还是不能避免这个问题......( 手动微笑脸 )\n\n## 滚动条宽度\n\n![](https://static.skynian.cn/scroll-bar-201861818333.png)\n\n（\b“百花齐放”的宽度）\n\n这里，笔者也是转载 \b 其他资料的数据，可能有些误差。\n\n但是只要记得一点，这是一个深坑......\n\n我们可以通过 JavaScript 来计算宽度（以下代码仅能测出原始的宽度，通过 CSS \b 改变后，便不准了）\n\n```js\nconst outer = document.createElement(\"div\");\nconst inner = document.createElement(\"div\");\n\nouter.style.overflow = \"scroll\";\ndocument.body.appendChild(outer);\nouter.appendChild(inner);\n\nconst scrollbarWidth = outer.offsetWidth - inner.offsetWidth;\n\ndocument.body.removeChild(outer);\n```\n\n因为 \b\b 涉及到了操作 DOM，为了性能起见，应该避免这类操作\n","source":"_posts/scroll-bar.md","raw":"---\ntitle: 现代 JavaScript 与 CSS 滚动实现简析\ndate: 2018-06-18 17:20:13\ntags:\n  - JavaScript\n  - CSS\ncategories: 优化\n---\n\n## 页面滚动条引发的抖动出发\n\n为了实现简单的水平居中布局，我们没少使用 margin: 0 auto； 来实现。\n\n然而，这种布局一直存在一个影响用户体验的隐患。我们都知道，现代浏览器滚动条默认是 overflow: auto 类型的，也就是如果尺寸不足一屏，没有滚动条；超出，出现滚动条...\n\n那么，问题来了 -\\_- !\n\n首先是简单的信息流页面，是从上往下 push 渲染的，如果信息没有超出一屏，都很好说，但是如果超出，那么滚动条就会出现，自然\nmargin: 0 auto; 主体元素就会做偏移，用户就会很明显感受到屏幕的抖动\n\n其他场景，比如，点击加载更多，或者 Tab 切换到有滚动条的区块，都会感觉到抖动。\n\n公司的 Web 产品一直存在这个问题，我个人觉得这个很影响体验，所以找了不少资料，也找了不少方案，在这里做一次总结。\n\n- 高度确认的，可以用 CSS 把页面尺寸布局骨架搭好，再往里面渲染数据。这样子的话，要么没有滚动条，要么数据直接出现，不会出现跳动，但是这样方式还是存在局限性\n- 还有一种简单粗暴的方式，直接设置 overflow: scroll，这就意味着，即使是在高度较小的时候，也会出现一个滚动条，而且貌似也不好看，存在的意义不明。\n\n经过查找，有一种方式，算是比较匹配我的需求\n\n使用 CSS3 计算 calc 和 vw 单位巧妙实现\n\n可以简单为容器设置样式：\n\n```css\n.wrap-outer {\n  margin-left: calc(100vw - 100%);\n}\n\n// 或者\n\n.wrap-outer {\n  padding-left: calc(100vw - 100%);\n}\n```\n\n100vw 相对于 \b 浏览器的 window.innerWidth ，是浏览器的内部宽度，这里包括了滚动条的宽度，而我们所使用的 100% 是不包含滚动条宽度的\n\n于是我们就可以愉快的实现不抖动的需求了\n\n兼容性方面的话，支持 IE9+ 以及其他现代浏览器\n\n## 消逝的滚动条\n\n既然讲到了滚动条，后面自己也查阅的不少资料，\b 可以 \b 了解一些相关历史。\n\n![](https://static.skynian.cn/scroll-bar-2018618175358.png)\n\n（windows 上面的滚动条变化历程）\n\n![](https://static.skynian.cn/scroll-bar-2018618175513.png)\n\n（Mac 上面的滚动条）\n\n在这里大赞 Mac，从 2011 年开始，所有的滚动条均从 Mac 电脑消失，不再占据任何页面空间，只有用户触发滚动时才会重新出现，当然用户可以设置默认显示。\n\n对于开发者和设计师来说，这真的是一个好消息，毕竟计算滚动条的宽度总是不够优雅。\n\n可是！\b 划重点！\n\n我们平时可能要使用各种各样的操作系统和浏览器，并且对滚动条的实现方式又各不同，所以我们还是不能避免这个问题......( 手动微笑脸 )\n\n## 滚动条宽度\n\n![](https://static.skynian.cn/scroll-bar-201861818333.png)\n\n（\b“百花齐放”的宽度）\n\n这里，笔者也是转载 \b 其他资料的数据，可能有些误差。\n\n但是只要记得一点，这是一个深坑......\n\n我们可以通过 JavaScript 来计算宽度（以下代码仅能测出原始的宽度，通过 CSS \b 改变后，便不准了）\n\n```js\nconst outer = document.createElement(\"div\");\nconst inner = document.createElement(\"div\");\n\nouter.style.overflow = \"scroll\";\ndocument.body.appendChild(outer);\nouter.appendChild(inner);\n\nconst scrollbarWidth = outer.offsetWidth - inner.offsetWidth;\n\ndocument.body.removeChild(outer);\n```\n\n因为 \b\b 涉及到了操作 DOM，为了性能起见，应该避免这类操作\n","slug":"scroll-bar","published":1,"updated":"2018-12-25T07:25:43.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2iep000egzq21kdc7kfn","content":"<h2 id=\"页面滚动条引发的抖动出发\"><a href=\"#页面滚动条引发的抖动出发\" class=\"headerlink\" title=\"页面滚动条引发的抖动出发\"></a>页面滚动条引发的抖动出发</h2><p>为了实现简单的水平居中布局，我们没少使用 margin: 0 auto； 来实现。</p>\n<p>然而，这种布局一直存在一个影响用户体验的隐患。我们都知道，现代浏览器滚动条默认是 overflow: auto 类型的，也就是如果尺寸不足一屏，没有滚动条；超出，出现滚动条…</p>\n<p>那么，问题来了 -_- !</p>\n<p>首先是简单的信息流页面，是从上往下 push 渲染的，如果信息没有超出一屏，都很好说，但是如果超出，那么滚动条就会出现，自然<br>margin: 0 auto; 主体元素就会做偏移，用户就会很明显感受到屏幕的抖动</p>\n<p>其他场景，比如，点击加载更多，或者 Tab 切换到有滚动条的区块，都会感觉到抖动。</p>\n<p>公司的 Web 产品一直存在这个问题，我个人觉得这个很影响体验，所以找了不少资料，也找了不少方案，在这里做一次总结。</p>\n<ul>\n<li>高度确认的，可以用 CSS 把页面尺寸布局骨架搭好，再往里面渲染数据。这样子的话，要么没有滚动条，要么数据直接出现，不会出现跳动，但是这样方式还是存在局限性</li>\n<li>还有一种简单粗暴的方式，直接设置 overflow: scroll，这就意味着，即使是在高度较小的时候，也会出现一个滚动条，而且貌似也不好看，存在的意义不明。</li>\n</ul>\n<p>经过查找，有一种方式，算是比较匹配我的需求</p>\n<p>使用 CSS3 计算 calc 和 vw 单位巧妙实现</p>\n<p>可以简单为容器设置样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap-outer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"built_in\">calc</span>(100vw - 100%);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.wrap-outer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-left</span>: <span class=\"built_in\">calc</span>(100vw - 100%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>100vw 相对于 \b 浏览器的 window.innerWidth ，是浏览器的内部宽度，这里包括了滚动条的宽度，而我们所使用的 100% 是不包含滚动条宽度的</p>\n<p>于是我们就可以愉快的实现不抖动的需求了</p>\n<p>兼容性方面的话，支持 IE9+ 以及其他现代浏览器</p>\n<h2 id=\"消逝的滚动条\"><a href=\"#消逝的滚动条\" class=\"headerlink\" title=\"消逝的滚动条\"></a>消逝的滚动条</h2><p>既然讲到了滚动条，后面自己也查阅的不少资料，\b 可以 \b 了解一些相关历史。</p>\n<p><img src=\"https://static.skynian.cn/scroll-bar-2018618175358.png\" alt=\"\"></p>\n<p>（windows 上面的滚动条变化历程）</p>\n<p><img src=\"https://static.skynian.cn/scroll-bar-2018618175513.png\" alt=\"\"></p>\n<p>（Mac 上面的滚动条）</p>\n<p>在这里大赞 Mac，从 2011 年开始，所有的滚动条均从 Mac 电脑消失，不再占据任何页面空间，只有用户触发滚动时才会重新出现，当然用户可以设置默认显示。</p>\n<p>对于开发者和设计师来说，这真的是一个好消息，毕竟计算滚动条的宽度总是不够优雅。</p>\n<p>可是！\b 划重点！</p>\n<p>我们平时可能要使用各种各样的操作系统和浏览器，并且对滚动条的实现方式又各不同，所以我们还是不能避免这个问题……( 手动微笑脸 )</p>\n<h2 id=\"滚动条宽度\"><a href=\"#滚动条宽度\" class=\"headerlink\" title=\"滚动条宽度\"></a>滚动条宽度</h2><p><img src=\"https://static.skynian.cn/scroll-bar-201861818333.png\" alt=\"\"></p>\n<p>（\b“百花齐放”的宽度）</p>\n<p>这里，笔者也是转载 \b 其他资料的数据，可能有些误差。</p>\n<p>但是只要记得一点，这是一个深坑……</p>\n<p>我们可以通过 JavaScript 来计算宽度（以下代码仅能测出原始的宽度，通过 CSS \b 改变后，便不准了）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> outer = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> inner = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">outer.style.overflow = <span class=\"string\">\"scroll\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(outer);</span><br><span class=\"line\">outer.appendChild(inner);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> scrollbarWidth = outer.offsetWidth - inner.offsetWidth;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.removeChild(outer);</span><br></pre></td></tr></table></figure>\n<p>因为 \b\b 涉及到了操作 DOM，为了性能起见，应该避免这类操作</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h2 id=\"页面滚动条引发的抖动出发\"><a href=\"#页面滚动条引发的抖动出发\" class=\"headerlink\" title=\"页面滚动条引发的抖动出发\"></a>页面滚动条引发的抖动出发</h2><p>为了实现简单的水平居中布局，我们没少使用 margin: 0 auto； 来实现。</p>\n<p>然而，这种布局一直存在一个影响用户体验的隐患。我们都知道，现代浏览器滚动条默认是 overflow: auto 类型的，也就是如果尺寸不足一屏，没有滚动条；超出，出现滚动条…</p>\n<p>那么，问题来了 -_- !</p>\n<p>首先是简单的信息流页面，是从上往下 push 渲染的，如果信息没有超出一屏，都很好说，但是如果超出，那么滚动条就会出现，自然<br>margin: 0 auto; 主体元素就会做偏移，用户就会很明显感受到屏幕的抖动</p>\n<p>其他场景，比如，点击加载更多，或者 Tab 切换到有滚动条的区块，都会感觉到抖动。</p>\n<p>公司的 Web 产品一直存在这个问题，我个人觉得这个很影响体验，所以找了不少资料，也找了不少方案，在这里做一次总结。</p>\n<ul>\n<li>高度确认的，可以用 CSS 把页面尺寸布局骨架搭好，再往里面渲染数据。这样子的话，要么没有滚动条，要么数据直接出现，不会出现跳动，但是这样方式还是存在局限性</li>\n<li>还有一种简单粗暴的方式，直接设置 overflow: scroll，这就意味着，即使是在高度较小的时候，也会出现一个滚动条，而且貌似也不好看，存在的意义不明。</li>\n</ul>\n<p>经过查找，有一种方式，算是比较匹配我的需求</p>\n<p>使用 CSS3 计算 calc 和 vw 单位巧妙实现</p>\n<p>可以简单为容器设置样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap-outer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"built_in\">calc</span>(100vw - 100%);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.wrap-outer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-left</span>: <span class=\"built_in\">calc</span>(100vw - 100%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>100vw 相对于 \b 浏览器的 window.innerWidth ，是浏览器的内部宽度，这里包括了滚动条的宽度，而我们所使用的 100% 是不包含滚动条宽度的</p>\n<p>于是我们就可以愉快的实现不抖动的需求了</p>\n<p>兼容性方面的话，支持 IE9+ 以及其他现代浏览器</p>\n<h2 id=\"消逝的滚动条\"><a href=\"#消逝的滚动条\" class=\"headerlink\" title=\"消逝的滚动条\"></a>消逝的滚动条</h2><p>既然讲到了滚动条，后面自己也查阅的不少资料，\b 可以 \b 了解一些相关历史。</p>\n<p><img src=\"https://static.skynian.cn/scroll-bar-2018618175358.png\" alt=\"\"></p>\n<p>（windows 上面的滚动条变化历程）</p>\n<p><img src=\"https://static.skynian.cn/scroll-bar-2018618175513.png\" alt=\"\"></p>\n<p>（Mac 上面的滚动条）</p>\n<p>在这里大赞 Mac，从 2011 年开始，所有的滚动条均从 Mac 电脑消失，不再占据任何页面空间，只有用户触发滚动时才会重新出现，当然用户可以设置默认显示。</p>\n<p>对于开发者和设计师来说，这真的是一个好消息，毕竟计算滚动条的宽度总是不够优雅。</p>\n<p>可是！\b 划重点！</p>\n<p>我们平时可能要使用各种各样的操作系统和浏览器，并且对滚动条的实现方式又各不同，所以我们还是不能避免这个问题……( 手动微笑脸 )</p>\n<h2 id=\"滚动条宽度\"><a href=\"#滚动条宽度\" class=\"headerlink\" title=\"滚动条宽度\"></a>滚动条宽度</h2><p><img src=\"https://static.skynian.cn/scroll-bar-201861818333.png\" alt=\"\"></p>\n<p>（\b“百花齐放”的宽度）</p>\n<p>这里，笔者也是转载 \b 其他资料的数据，可能有些误差。</p>\n<p>但是只要记得一点，这是一个深坑……</p>\n<p>我们可以通过 JavaScript 来计算宽度（以下代码仅能测出原始的宽度，通过 CSS \b 改变后，便不准了）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> outer = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> inner = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">outer.style.overflow = <span class=\"string\">\"scroll\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(outer);</span><br><span class=\"line\">outer.appendChild(inner);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> scrollbarWidth = outer.offsetWidth - inner.offsetWidth;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.removeChild(outer);</span><br></pre></td></tr></table></figure>\n<p>因为 \b\b 涉及到了操作 DOM，为了性能起见，应该避免这类操作</p>\n"},{"title":"深入理解this","date":"2018-06-11T12:53:06.000Z","_content":"\n![](https://static.skynian.cn/深入理解this-201861122106.jpg)\n\nJavaScript 中 this 的指向一直是困扰我很久的问题，在使用中出错的机率也非常大。在面向对象语言中，它代表了当前对象的一个引用，而在 JS 中却经常让我觉得混乱，它不是固定不变的，而是随着它的执行环境的改变而改变。\n\n<!--more-->\n\n如果没有 \b 彻底理解 \b 和掌握这个特性，可能真的会一次又一次 \b\b 踩坑，不要问我是怎么知道的 o(╯□╰)o\n\n可能 this 不是 JS 中最复杂的内容，但是它的细节也是蔚为大观。涉及到了函数、函数调用、eval、call/apply/bind、基本包装类型、构造函数实例化、严格模式等等。\n\n\b 与此同时 ES6 引入的箭头函数和 \bclass 更是把 this 复杂化了。\n\n其实网上关于 this 的介绍和总结很多，但是不乏会有很多错漏的地方，笔者 \b 写这篇博客也是为了做一次总结，同时巩固，更重要的是希望能出坑......\n\n\b\b 一个最基本的认知是，this 的值会发生变化，但是有一个总的原则，那就是 this 指向的是调用函数的那个对象。\n\n## 情况 \b 一：纯粹的函数调用\n\n这是函数的最通常用法，属于全局性调用，因此 this 就代表着全局对象 Global\n\n```js\nfunction func1() {\n  console.log(this === window); // true\n}\nfunc1();\n\nconst func2 = function() {\n  console.log(this === window); // true\n};\nfunc2();\n\nfunction func3() {\n  \"use strict\";\n  console.log(this); // undefined\n}\n```\n\n从上述代码中，我们可以看出，如果不是处于严格模式下，函数的上下文是 window 对象，严格模式下，函数上下文为 undefined。\n\n## 情况二：作为对象方法的调用\n\n函数还可以作为某个对象方法调用，这时 this 就指这个上级对象\n\n```js\nfunction test() {\n  alert(this.x)\n}\n\nle o = {}\no.x = 1\no.m = test\no.m() // 1\n```\n\n其实，我们这时返回看情况一，实际上可以看出”func1()“，可以理解为“window.func1()”，所以例子中的函数上下文便是 this。\n\n## 情况三： 作为构造函数调用\n\n所谓构造函数，\b 也就是通过这个函数生成一个新对象（object）。这个时候，this 就是指这个新对象。\n\n```js\nfunction test() {\n  this.x = 1;\n}\n\nlet o = new test();\nlaert(o.x); // 1\n```\n\n运行结果为 1，为了表明这时 this 对象不是全局对象，我对代码做一点改变：\n\n```js\nlet x = 2;\n\nfunction test() {\n  this.x = 1;\n}\n\nlet o = new test();\n\nalert(x); // 2\n```\n\n## 情况四： 使用 apply()和 call()方法进行调用\n\n\bapply()和 call()是函数对象中的方法，它的作用是改变函数的调用对象，可以利用任何一个函数都可以显式指定任何一个对象作为其函数上下文。\n\n通过 apply() 方法来调用函数，我们要给 apply() 传入两个参数：一个作为函数上下文对象，另一个作为函数参数所组成的数组。call() 方法的使用方式类似，唯一不同的是给函数传入的参数是一个参数列表，而不是单个数组。\n\n```js\nfunction func() {\n  let result = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    result += arguments[i];\n  }\n  this.result = result;\n}\nconst obj1 = {};\nconst obj2 = {};\nfunc.apply(obj1, [1, 2, 3]);\nfunc.call(obj2, 4, 5, 6);\n\nconsole.log(obj1.result === 6); // true\nconsole.log(obj2.result === 15); // true\n```\n\n在上面的代码中，`func.apply(obj1, [1, 2, 3]);` 将函数的上下文定义为 obj1，并且传入 1、2、3 三个参数，`func.call(obj2, 4, 5, 6);` 将函数的上下文定义为 obj2，并且传入 4、5、6 三个参数。\n\n那 apply 和 call 基本相同，那么我们该用哪一个呢？其实 apply 和 call 的区别仅仅在于调用时传入的参数不同，其他完全一样。所以，在选择时，主要看传入的参数。如果已知参数已经在数组里了则用 apply 即可，或者参数是动态生成的，可以把参数 push 进一个数组，然后再用 apply 调用。当参数数量已知，或者在参数里有很多无关的值则用 call 方法调用。\n\n## ES6 与 this\n\nES6 中引入了一个很棒的特性：箭头函数。说其棒，主要源于其书写简单，更重要的是其使得 this 更易于理解。\n\nES6 中，箭头函数中始终会捕捉其所在上下文的 this 值，作为自己的 this。这一点非常重要，省去了我们很多的麻烦。但对于那些习惯了每个 function 中都有自己 this 的人来说，可能还有些不习惯。举个例子吧，就拿调用方式 2 中的例子。\n\n```js\nconst obj = {\n  func: () => {\n    console.log(this === window); // true，非箭头函数时指向 obj\n  }\n};\nobj.func();\n```\n\n在上面的例子中，func 所在上下文的 this 值指向 window，而 func 是一个箭头函数，所以其里面的 this 会捕捉其所在上下文的 this 作为自己的 this， 所以 func 内的 this 也指向 window 对象。\n\n## 其他补充\n\n> 利用 bind() 改变函数上下文\n\n```js\nconst obj1 = {\n  a: 1\n};\nconst obj2 = {\n  a: 2,\n  func: function() {\n    console.log(this.a);\n  }.bind(obj1)\n};\nobj2.func(); // 1\n```\n\nECMAScript 5 引入了 `Function.prototype.bind`，其会创建一个绑定函数，当调用这个绑定函数时，函数上下文将会是 bind() 方法的第一个参数。上面的例子中，将 obj1 设置为函数上下文，所以利用 func 来调用函数时，函数的上下文为 obj1，而不是它的调用者 obj2。\n\n利用 Array 的 5 个方法改变函数上下文\n\n5 个方法分别是：\n\n`Array.prototype.every(callbackfn [, thisArg ])`\n`Array.prototype.some(callbackfn [, thisArg ])`\n`Array.prototype.forEach(callbackfn [, thisArg ])`\n`Array.prototype.map(callbackfn [, thisArg ])`\n`Array.prototype.filter(callbackfn [, thisArg ])`\n\n当调用以上 5 个方法时，传入的参数除了回调函数以外，还可以传入另外一个可选地参数，即函数上下文，代表回调函数中的函数上下文。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。看下面的例子：\n\n```js\nconst arr = [\"segmentfault\"];\nconst obj = {};\narr.forEach(function(ele, ind) {\n  console.log(this === window); // true\n});\narr.forEach(function(ele, ind) {\n  console.log(this === obj); // true\n}, obj);\n```\n\n## 测试\n\n```js\nif (true) {\n  // this\n}\n```\n\n```js\nconst obj = {\n  someData: \"a string\"\n};\nfunction myFun() {\n  // this\n}\nobj.staticFunction = myFun;\nobj.staticFunction();\n```\n\n```js\nconst obj = {\n  myMethod: function() {\n    // this\n  }\n};\nconst myFun = obj.myMethod;\nmyFun();\n```\n\n```js\nfunction myFun() {\n  // this\n}\nconst obj = {\n  someData: \"a string\"\n};\nmyFun.call(obj);\n```\n\n答案：\n\nwindow\n\nobj\n\nwindow\n\nobj\n","source":"_posts/this.md","raw":"---\ntitle: 深入理解this\ndate: 2018-06-11 20:53:06\ntags:\n  - JavaScript\ncategories: JavaScript\n---\n\n![](https://static.skynian.cn/深入理解this-201861122106.jpg)\n\nJavaScript 中 this 的指向一直是困扰我很久的问题，在使用中出错的机率也非常大。在面向对象语言中，它代表了当前对象的一个引用，而在 JS 中却经常让我觉得混乱，它不是固定不变的，而是随着它的执行环境的改变而改变。\n\n<!--more-->\n\n如果没有 \b 彻底理解 \b 和掌握这个特性，可能真的会一次又一次 \b\b 踩坑，不要问我是怎么知道的 o(╯□╰)o\n\n可能 this 不是 JS 中最复杂的内容，但是它的细节也是蔚为大观。涉及到了函数、函数调用、eval、call/apply/bind、基本包装类型、构造函数实例化、严格模式等等。\n\n\b 与此同时 ES6 引入的箭头函数和 \bclass 更是把 this 复杂化了。\n\n其实网上关于 this 的介绍和总结很多，但是不乏会有很多错漏的地方，笔者 \b 写这篇博客也是为了做一次总结，同时巩固，更重要的是希望能出坑......\n\n\b\b 一个最基本的认知是，this 的值会发生变化，但是有一个总的原则，那就是 this 指向的是调用函数的那个对象。\n\n## 情况 \b 一：纯粹的函数调用\n\n这是函数的最通常用法，属于全局性调用，因此 this 就代表着全局对象 Global\n\n```js\nfunction func1() {\n  console.log(this === window); // true\n}\nfunc1();\n\nconst func2 = function() {\n  console.log(this === window); // true\n};\nfunc2();\n\nfunction func3() {\n  \"use strict\";\n  console.log(this); // undefined\n}\n```\n\n从上述代码中，我们可以看出，如果不是处于严格模式下，函数的上下文是 window 对象，严格模式下，函数上下文为 undefined。\n\n## 情况二：作为对象方法的调用\n\n函数还可以作为某个对象方法调用，这时 this 就指这个上级对象\n\n```js\nfunction test() {\n  alert(this.x)\n}\n\nle o = {}\no.x = 1\no.m = test\no.m() // 1\n```\n\n其实，我们这时返回看情况一，实际上可以看出”func1()“，可以理解为“window.func1()”，所以例子中的函数上下文便是 this。\n\n## 情况三： 作为构造函数调用\n\n所谓构造函数，\b 也就是通过这个函数生成一个新对象（object）。这个时候，this 就是指这个新对象。\n\n```js\nfunction test() {\n  this.x = 1;\n}\n\nlet o = new test();\nlaert(o.x); // 1\n```\n\n运行结果为 1，为了表明这时 this 对象不是全局对象，我对代码做一点改变：\n\n```js\nlet x = 2;\n\nfunction test() {\n  this.x = 1;\n}\n\nlet o = new test();\n\nalert(x); // 2\n```\n\n## 情况四： 使用 apply()和 call()方法进行调用\n\n\bapply()和 call()是函数对象中的方法，它的作用是改变函数的调用对象，可以利用任何一个函数都可以显式指定任何一个对象作为其函数上下文。\n\n通过 apply() 方法来调用函数，我们要给 apply() 传入两个参数：一个作为函数上下文对象，另一个作为函数参数所组成的数组。call() 方法的使用方式类似，唯一不同的是给函数传入的参数是一个参数列表，而不是单个数组。\n\n```js\nfunction func() {\n  let result = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    result += arguments[i];\n  }\n  this.result = result;\n}\nconst obj1 = {};\nconst obj2 = {};\nfunc.apply(obj1, [1, 2, 3]);\nfunc.call(obj2, 4, 5, 6);\n\nconsole.log(obj1.result === 6); // true\nconsole.log(obj2.result === 15); // true\n```\n\n在上面的代码中，`func.apply(obj1, [1, 2, 3]);` 将函数的上下文定义为 obj1，并且传入 1、2、3 三个参数，`func.call(obj2, 4, 5, 6);` 将函数的上下文定义为 obj2，并且传入 4、5、6 三个参数。\n\n那 apply 和 call 基本相同，那么我们该用哪一个呢？其实 apply 和 call 的区别仅仅在于调用时传入的参数不同，其他完全一样。所以，在选择时，主要看传入的参数。如果已知参数已经在数组里了则用 apply 即可，或者参数是动态生成的，可以把参数 push 进一个数组，然后再用 apply 调用。当参数数量已知，或者在参数里有很多无关的值则用 call 方法调用。\n\n## ES6 与 this\n\nES6 中引入了一个很棒的特性：箭头函数。说其棒，主要源于其书写简单，更重要的是其使得 this 更易于理解。\n\nES6 中，箭头函数中始终会捕捉其所在上下文的 this 值，作为自己的 this。这一点非常重要，省去了我们很多的麻烦。但对于那些习惯了每个 function 中都有自己 this 的人来说，可能还有些不习惯。举个例子吧，就拿调用方式 2 中的例子。\n\n```js\nconst obj = {\n  func: () => {\n    console.log(this === window); // true，非箭头函数时指向 obj\n  }\n};\nobj.func();\n```\n\n在上面的例子中，func 所在上下文的 this 值指向 window，而 func 是一个箭头函数，所以其里面的 this 会捕捉其所在上下文的 this 作为自己的 this， 所以 func 内的 this 也指向 window 对象。\n\n## 其他补充\n\n> 利用 bind() 改变函数上下文\n\n```js\nconst obj1 = {\n  a: 1\n};\nconst obj2 = {\n  a: 2,\n  func: function() {\n    console.log(this.a);\n  }.bind(obj1)\n};\nobj2.func(); // 1\n```\n\nECMAScript 5 引入了 `Function.prototype.bind`，其会创建一个绑定函数，当调用这个绑定函数时，函数上下文将会是 bind() 方法的第一个参数。上面的例子中，将 obj1 设置为函数上下文，所以利用 func 来调用函数时，函数的上下文为 obj1，而不是它的调用者 obj2。\n\n利用 Array 的 5 个方法改变函数上下文\n\n5 个方法分别是：\n\n`Array.prototype.every(callbackfn [, thisArg ])`\n`Array.prototype.some(callbackfn [, thisArg ])`\n`Array.prototype.forEach(callbackfn [, thisArg ])`\n`Array.prototype.map(callbackfn [, thisArg ])`\n`Array.prototype.filter(callbackfn [, thisArg ])`\n\n当调用以上 5 个方法时，传入的参数除了回调函数以外，还可以传入另外一个可选地参数，即函数上下文，代表回调函数中的函数上下文。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。看下面的例子：\n\n```js\nconst arr = [\"segmentfault\"];\nconst obj = {};\narr.forEach(function(ele, ind) {\n  console.log(this === window); // true\n});\narr.forEach(function(ele, ind) {\n  console.log(this === obj); // true\n}, obj);\n```\n\n## 测试\n\n```js\nif (true) {\n  // this\n}\n```\n\n```js\nconst obj = {\n  someData: \"a string\"\n};\nfunction myFun() {\n  // this\n}\nobj.staticFunction = myFun;\nobj.staticFunction();\n```\n\n```js\nconst obj = {\n  myMethod: function() {\n    // this\n  }\n};\nconst myFun = obj.myMethod;\nmyFun();\n```\n\n```js\nfunction myFun() {\n  // this\n}\nconst obj = {\n  someData: \"a string\"\n};\nmyFun.call(obj);\n```\n\n答案：\n\nwindow\n\nobj\n\nwindow\n\nobj\n","slug":"this","published":1,"updated":"2018-12-25T07:25:46.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2ier000ggzq2kyonvdpp","content":"<p><img src=\"https://static.skynian.cn/深入理解this-201861122106.jpg\" alt=\"\"></p>\n<p>JavaScript 中 this 的指向一直是困扰我很久的问题，在使用中出错的机率也非常大。在面向对象语言中，它代表了当前对象的一个引用，而在 JS 中却经常让我觉得混乱，它不是固定不变的，而是随着它的执行环境的改变而改变。</p>\n<a id=\"more\"></a>\n<p>如果没有 \b 彻底理解 \b 和掌握这个特性，可能真的会一次又一次 \b\b 踩坑，不要问我是怎么知道的 o(╯□╰)o</p>\n<p>可能 this 不是 JS 中最复杂的内容，但是它的细节也是蔚为大观。涉及到了函数、函数调用、eval、call/apply/bind、基本包装类型、构造函数实例化、严格模式等等。</p>\n<p>\b 与此同时 ES6 引入的箭头函数和 \bclass 更是把 this 复杂化了。</p>\n<p>其实网上关于 this 的介绍和总结很多，但是不乏会有很多错漏的地方，笔者 \b 写这篇博客也是为了做一次总结，同时巩固，更重要的是希望能出坑……</p>\n<p>\b\b 一个最基本的认知是，this 的值会发生变化，但是有一个总的原则，那就是 this 指向的是调用函数的那个对象。</p>\n<h2 id=\"情况-一：纯粹的函数调用\"><a href=\"#情况-一：纯粹的函数调用\" class=\"headerlink\" title=\"情况 \b 一：纯粹的函数调用\"></a>情况 \b 一：纯粹的函数调用</h2><p>这是函数的最通常用法，属于全局性调用，因此 this 就代表着全局对象 Global</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> func2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func2();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码中，我们可以看出，如果不是处于严格模式下，函数的上下文是 window 对象，严格模式下，函数上下文为 undefined。</p>\n<h2 id=\"情况二：作为对象方法的调用\"><a href=\"#情况二：作为对象方法的调用\" class=\"headerlink\" title=\"情况二：作为对象方法的调用\"></a>情况二：作为对象方法的调用</h2><p>函数还可以作为某个对象方法调用，这时 this 就指这个上级对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">le o = &#123;&#125;</span><br><span class=\"line\">o.x = <span class=\"number\">1</span></span><br><span class=\"line\">o.m = test</span><br><span class=\"line\">o.m() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>其实，我们这时返回看情况一，实际上可以看出”func1()“，可以理解为“window.func1()”，所以例子中的函数上下文便是 this。</p>\n<h2 id=\"情况三：-作为构造函数调用\"><a href=\"#情况三：-作为构造函数调用\" class=\"headerlink\" title=\"情况三： 作为构造函数调用\"></a>情况三： 作为构造函数调用</h2><p>所谓构造函数，\b 也就是通过这个函数生成一个新对象（object）。这个时候，this 就是指这个新对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\">laert(o.x); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>运行结果为 1，为了表明这时 this 对象不是全局对象，我对代码做一点改变：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(x); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"情况四：-使用-apply-和-call-方法进行调用\"><a href=\"#情况四：-使用-apply-和-call-方法进行调用\" class=\"headerlink\" title=\"情况四： 使用 apply()和 call()方法进行调用\"></a>情况四： 使用 apply()和 call()方法进行调用</h2><p>\bapply()和 call()是函数对象中的方法，它的作用是改变函数的调用对象，可以利用任何一个函数都可以显式指定任何一个对象作为其函数上下文。</p>\n<p>通过 apply() 方法来调用函数，我们要给 apply() 传入两个参数：一个作为函数上下文对象，另一个作为函数参数所组成的数组。call() 方法的使用方式类似，唯一不同的是给函数传入的参数是一个参数列表，而不是单个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">    result += <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;;</span><br><span class=\"line\">func.apply(obj1, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">func.call(obj2, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.result === <span class=\"number\">6</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.result === <span class=\"number\">15</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，<code>func.apply(obj1, [1, 2, 3]);</code> 将函数的上下文定义为 obj1，并且传入 1、2、3 三个参数，<code>func.call(obj2, 4, 5, 6);</code> 将函数的上下文定义为 obj2，并且传入 4、5、6 三个参数。</p>\n<p>那 apply 和 call 基本相同，那么我们该用哪一个呢？其实 apply 和 call 的区别仅仅在于调用时传入的参数不同，其他完全一样。所以，在选择时，主要看传入的参数。如果已知参数已经在数组里了则用 apply 即可，或者参数是动态生成的，可以把参数 push 进一个数组，然后再用 apply 调用。当参数数量已知，或者在参数里有很多无关的值则用 call 方法调用。</p>\n<h2 id=\"ES6-与-this\"><a href=\"#ES6-与-this\" class=\"headerlink\" title=\"ES6 与 this\"></a>ES6 与 this</h2><p>ES6 中引入了一个很棒的特性：箭头函数。说其棒，主要源于其书写简单，更重要的是其使得 this 更易于理解。</p>\n<p>ES6 中，箭头函数中始终会捕捉其所在上下文的 this 值，作为自己的 this。这一点非常重要，省去了我们很多的麻烦。但对于那些习惯了每个 function 中都有自己 this 的人来说，可能还有些不习惯。举个例子吧，就拿调用方式 2 中的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  func: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true，非箭头函数时指向 obj</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.func();</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，func 所在上下文的 this 值指向 window，而 func 是一个箭头函数，所以其里面的 this 会捕捉其所在上下文的 this 作为自己的 this， 所以 func 内的 this 也指向 window 对象。</p>\n<h2 id=\"其他补充\"><a href=\"#其他补充\" class=\"headerlink\" title=\"其他补充\"></a>其他补充</h2><blockquote>\n<p>利用 bind() 改变函数上下文</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">  &#125;.bind(obj1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj2.func(); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>，其会创建一个绑定函数，当调用这个绑定函数时，函数上下文将会是 bind() 方法的第一个参数。上面的例子中，将 obj1 设置为函数上下文，所以利用 func 来调用函数时，函数的上下文为 obj1，而不是它的调用者 obj2。</p>\n<p>利用 Array 的 5 个方法改变函数上下文</p>\n<p>5 个方法分别是：</p>\n<p><code>Array.prototype.every(callbackfn [, thisArg ])</code><br><code>Array.prototype.some(callbackfn [, thisArg ])</code><br><code>Array.prototype.forEach(callbackfn [, thisArg ])</code><br><code>Array.prototype.map(callbackfn [, thisArg ])</code><br><code>Array.prototype.filter(callbackfn [, thisArg ])</code></p>\n<p>当调用以上 5 个方法时，传入的参数除了回调函数以外，还可以传入另外一个可选地参数，即函数上下文，代表回调函数中的函数上下文。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">\"segmentfault\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, ind</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, ind</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;, obj);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  someData: <span class=\"string\">\"a string\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.staticFunction = myFun;</span><br><span class=\"line\">obj.staticFunction();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  myMethod: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myFun = obj.myMethod;</span><br><span class=\"line\">myFun();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  someData: <span class=\"string\">\"a string\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myFun.call(obj);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<p>window</p>\n<p>obj</p>\n<p>window</p>\n<p>obj</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p><img src=\"https://static.skynian.cn/深入理解this-201861122106.jpg\" alt=\"\"></p>\n<p>JavaScript 中 this 的指向一直是困扰我很久的问题，在使用中出错的机率也非常大。在面向对象语言中，它代表了当前对象的一个引用，而在 JS 中却经常让我觉得混乱，它不是固定不变的，而是随着它的执行环境的改变而改变。</p>","more":"<p>如果没有 \b 彻底理解 \b 和掌握这个特性，可能真的会一次又一次 \b\b 踩坑，不要问我是怎么知道的 o(╯□╰)o</p>\n<p>可能 this 不是 JS 中最复杂的内容，但是它的细节也是蔚为大观。涉及到了函数、函数调用、eval、call/apply/bind、基本包装类型、构造函数实例化、严格模式等等。</p>\n<p>\b 与此同时 ES6 引入的箭头函数和 \bclass 更是把 this 复杂化了。</p>\n<p>其实网上关于 this 的介绍和总结很多，但是不乏会有很多错漏的地方，笔者 \b 写这篇博客也是为了做一次总结，同时巩固，更重要的是希望能出坑……</p>\n<p>\b\b 一个最基本的认知是，this 的值会发生变化，但是有一个总的原则，那就是 this 指向的是调用函数的那个对象。</p>\n<h2 id=\"情况-一：纯粹的函数调用\"><a href=\"#情况-一：纯粹的函数调用\" class=\"headerlink\" title=\"情况 \b 一：纯粹的函数调用\"></a>情况 \b 一：纯粹的函数调用</h2><p>这是函数的最通常用法，属于全局性调用，因此 this 就代表着全局对象 Global</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> func2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func2();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码中，我们可以看出，如果不是处于严格模式下，函数的上下文是 window 对象，严格模式下，函数上下文为 undefined。</p>\n<h2 id=\"情况二：作为对象方法的调用\"><a href=\"#情况二：作为对象方法的调用\" class=\"headerlink\" title=\"情况二：作为对象方法的调用\"></a>情况二：作为对象方法的调用</h2><p>函数还可以作为某个对象方法调用，这时 this 就指这个上级对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">le o = &#123;&#125;</span><br><span class=\"line\">o.x = <span class=\"number\">1</span></span><br><span class=\"line\">o.m = test</span><br><span class=\"line\">o.m() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>其实，我们这时返回看情况一，实际上可以看出”func1()“，可以理解为“window.func1()”，所以例子中的函数上下文便是 this。</p>\n<h2 id=\"情况三：-作为构造函数调用\"><a href=\"#情况三：-作为构造函数调用\" class=\"headerlink\" title=\"情况三： 作为构造函数调用\"></a>情况三： 作为构造函数调用</h2><p>所谓构造函数，\b 也就是通过这个函数生成一个新对象（object）。这个时候，this 就是指这个新对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\">laert(o.x); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>运行结果为 1，为了表明这时 this 对象不是全局对象，我对代码做一点改变：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(x); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"情况四：-使用-apply-和-call-方法进行调用\"><a href=\"#情况四：-使用-apply-和-call-方法进行调用\" class=\"headerlink\" title=\"情况四： 使用 apply()和 call()方法进行调用\"></a>情况四： 使用 apply()和 call()方法进行调用</h2><p>\bapply()和 call()是函数对象中的方法，它的作用是改变函数的调用对象，可以利用任何一个函数都可以显式指定任何一个对象作为其函数上下文。</p>\n<p>通过 apply() 方法来调用函数，我们要给 apply() 传入两个参数：一个作为函数上下文对象，另一个作为函数参数所组成的数组。call() 方法的使用方式类似，唯一不同的是给函数传入的参数是一个参数列表，而不是单个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">    result += <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;;</span><br><span class=\"line\">func.apply(obj1, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">func.call(obj2, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.result === <span class=\"number\">6</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.result === <span class=\"number\">15</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，<code>func.apply(obj1, [1, 2, 3]);</code> 将函数的上下文定义为 obj1，并且传入 1、2、3 三个参数，<code>func.call(obj2, 4, 5, 6);</code> 将函数的上下文定义为 obj2，并且传入 4、5、6 三个参数。</p>\n<p>那 apply 和 call 基本相同，那么我们该用哪一个呢？其实 apply 和 call 的区别仅仅在于调用时传入的参数不同，其他完全一样。所以，在选择时，主要看传入的参数。如果已知参数已经在数组里了则用 apply 即可，或者参数是动态生成的，可以把参数 push 进一个数组，然后再用 apply 调用。当参数数量已知，或者在参数里有很多无关的值则用 call 方法调用。</p>\n<h2 id=\"ES6-与-this\"><a href=\"#ES6-与-this\" class=\"headerlink\" title=\"ES6 与 this\"></a>ES6 与 this</h2><p>ES6 中引入了一个很棒的特性：箭头函数。说其棒，主要源于其书写简单，更重要的是其使得 this 更易于理解。</p>\n<p>ES6 中，箭头函数中始终会捕捉其所在上下文的 this 值，作为自己的 this。这一点非常重要，省去了我们很多的麻烦。但对于那些习惯了每个 function 中都有自己 this 的人来说，可能还有些不习惯。举个例子吧，就拿调用方式 2 中的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  func: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true，非箭头函数时指向 obj</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.func();</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，func 所在上下文的 this 值指向 window，而 func 是一个箭头函数，所以其里面的 this 会捕捉其所在上下文的 this 作为自己的 this， 所以 func 内的 this 也指向 window 对象。</p>\n<h2 id=\"其他补充\"><a href=\"#其他补充\" class=\"headerlink\" title=\"其他补充\"></a>其他补充</h2><blockquote>\n<p>利用 bind() 改变函数上下文</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">  &#125;.bind(obj1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj2.func(); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>，其会创建一个绑定函数，当调用这个绑定函数时，函数上下文将会是 bind() 方法的第一个参数。上面的例子中，将 obj1 设置为函数上下文，所以利用 func 来调用函数时，函数的上下文为 obj1，而不是它的调用者 obj2。</p>\n<p>利用 Array 的 5 个方法改变函数上下文</p>\n<p>5 个方法分别是：</p>\n<p><code>Array.prototype.every(callbackfn [, thisArg ])</code><br><code>Array.prototype.some(callbackfn [, thisArg ])</code><br><code>Array.prototype.forEach(callbackfn [, thisArg ])</code><br><code>Array.prototype.map(callbackfn [, thisArg ])</code><br><code>Array.prototype.filter(callbackfn [, thisArg ])</code></p>\n<p>当调用以上 5 个方法时，传入的参数除了回调函数以外，还可以传入另外一个可选地参数，即函数上下文，代表回调函数中的函数上下文。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">\"segmentfault\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, ind</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, ind</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;, obj);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  someData: <span class=\"string\">\"a string\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.staticFunction = myFun;</span><br><span class=\"line\">obj.staticFunction();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  myMethod: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myFun = obj.myMethod;</span><br><span class=\"line\">myFun();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  someData: <span class=\"string\">\"a string\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myFun.call(obj);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<p>window</p>\n<p>obj</p>\n<p>window</p>\n<p>obj</p>"},{"title":"浅析浏览器缓存","date":"2018-07-07T09:35:44.000Z","_content":"\n浏览器缓存是优化性能的一种方式，下面看看常见的 HTTP 缓存头，工作流程。\n\n当我们打开一个网站时，打开开发者工具 Network 面板，我们通常可以看到 from disk cache 缓存到硬盘，from memory cache 缓存到内存（chrome）这些字样，这个就是浏览器缓存。\n\n这个通常是怎么设置的呢，就是我们这里要介绍的 HTTP 缓存头。\n\n## Expires\n\n```\nExpires: Fri, 11 Jun 2021 11:33:01 GMT\n```\n\nExpires 的值是绝对时间，格林尼治时间，显示的也是服务器的时间\n\n不推荐 Expires，主要原因是：\n\n它设置的是绝对时间，如果系统时钟错了，或者不同时区之类的原因，缓存也会出错\n优先级较低，会被覆盖，当然可用作兼容考虑\n\n## Cache-Control\n\n```\nCache-Control: public, max-age=6400\n```\n\nCache-Control 是相对时间，优先级高于 Expires，没有上面 Expires 的问题。但是，文件修改后，如果我是希望不要缓存的，不要等待 Cache-Control 设定的值，这种情况下：\n\n一方面，可以通过给资源每次修改加版本号或随机数\n\n```\n<link rel=\"stylesheet\" href=\"styles.css?version=1.0\">\n```\n\n另一方面可以使用 Last-Modified 和 Etag 协商缓存来解决。接下来就讲讲这两个。\n\n## Last-Modified 和 If-Modified-Since\n\n```\nLast-Modified: Fri, 22 Jul 2016 01:47:00 GMT\n```\n\nLast-Modified 文件最后修改的时间，浏览器会缓存这个时间。\n\n与 Last-Modified 配合的请求头是 If-Modified-Since，就是缓存的 Last-Modified 的时间，那么是如何配合的呢？\n\n举个例子，每次当浏览器刷新的时候，当 Cache-Control 的时间已过的时候，询问下服务器 Last-Modified 是什么，然后和上次缓存到浏览器的 Last-Modified，也就是放在了请求头的 If-Modified-Since 作比较\n\n如果相同，服务器会返回 304，即请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，不用更新文件，使用浏览器缓存。\n如果不同，服务器会返回 200，即会重新请求更新过的资源\n\n## Etag 和 If-None-Match\n\n```\nEtag: xxxx\n```\n\n在上面的例子中，只考虑了服务器文件修改时间，但是有时候，打开文件可能没有修改任何内容，而修改时间发生了变化，这个就造成了本应该继续缓存的文件，需要重新请求，这是不合理的，这时候就出现了 Etag。\n\nEtag 的值是文件的 Hash 值，文件内容是否变化可以通过文件的 Hash 值准确地判断。\n\n对应 Last-Modified 和 If-Modified-Since 的配合机制，Etag 和 If-None-Match 是同样的协商。\n\n## 总结\n\n最常用的浏览器缓存就是这样做的，当然还有更多内容，不同的设定的值等等，如果想了解浏览器缓存更详细的信息，可以参考文章：\n\n[HTTP 缓存控制小结](http://www.imweb.io/topic/5795dcb6fb312541492eda8c)\n\n[Google 开发者文档：HTTP 缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)\n","source":"_posts/浅析浏览器缓存.md","raw":"---\ntitle: 浅析浏览器缓存\ndate: 2018-07-07 17:35:44\ntags:\n  - HTTP\ncategories:\n  - WEB\n---\n\n浏览器缓存是优化性能的一种方式，下面看看常见的 HTTP 缓存头，工作流程。\n\n当我们打开一个网站时，打开开发者工具 Network 面板，我们通常可以看到 from disk cache 缓存到硬盘，from memory cache 缓存到内存（chrome）这些字样，这个就是浏览器缓存。\n\n这个通常是怎么设置的呢，就是我们这里要介绍的 HTTP 缓存头。\n\n## Expires\n\n```\nExpires: Fri, 11 Jun 2021 11:33:01 GMT\n```\n\nExpires 的值是绝对时间，格林尼治时间，显示的也是服务器的时间\n\n不推荐 Expires，主要原因是：\n\n它设置的是绝对时间，如果系统时钟错了，或者不同时区之类的原因，缓存也会出错\n优先级较低，会被覆盖，当然可用作兼容考虑\n\n## Cache-Control\n\n```\nCache-Control: public, max-age=6400\n```\n\nCache-Control 是相对时间，优先级高于 Expires，没有上面 Expires 的问题。但是，文件修改后，如果我是希望不要缓存的，不要等待 Cache-Control 设定的值，这种情况下：\n\n一方面，可以通过给资源每次修改加版本号或随机数\n\n```\n<link rel=\"stylesheet\" href=\"styles.css?version=1.0\">\n```\n\n另一方面可以使用 Last-Modified 和 Etag 协商缓存来解决。接下来就讲讲这两个。\n\n## Last-Modified 和 If-Modified-Since\n\n```\nLast-Modified: Fri, 22 Jul 2016 01:47:00 GMT\n```\n\nLast-Modified 文件最后修改的时间，浏览器会缓存这个时间。\n\n与 Last-Modified 配合的请求头是 If-Modified-Since，就是缓存的 Last-Modified 的时间，那么是如何配合的呢？\n\n举个例子，每次当浏览器刷新的时候，当 Cache-Control 的时间已过的时候，询问下服务器 Last-Modified 是什么，然后和上次缓存到浏览器的 Last-Modified，也就是放在了请求头的 If-Modified-Since 作比较\n\n如果相同，服务器会返回 304，即请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，不用更新文件，使用浏览器缓存。\n如果不同，服务器会返回 200，即会重新请求更新过的资源\n\n## Etag 和 If-None-Match\n\n```\nEtag: xxxx\n```\n\n在上面的例子中，只考虑了服务器文件修改时间，但是有时候，打开文件可能没有修改任何内容，而修改时间发生了变化，这个就造成了本应该继续缓存的文件，需要重新请求，这是不合理的，这时候就出现了 Etag。\n\nEtag 的值是文件的 Hash 值，文件内容是否变化可以通过文件的 Hash 值准确地判断。\n\n对应 Last-Modified 和 If-Modified-Since 的配合机制，Etag 和 If-None-Match 是同样的协商。\n\n## 总结\n\n最常用的浏览器缓存就是这样做的，当然还有更多内容，不同的设定的值等等，如果想了解浏览器缓存更详细的信息，可以参考文章：\n\n[HTTP 缓存控制小结](http://www.imweb.io/topic/5795dcb6fb312541492eda8c)\n\n[Google 开发者文档：HTTP 缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)\n","slug":"浅析浏览器缓存","published":1,"updated":"2018-12-25T07:25:53.513Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2ieu000lgzq20d0psg90","content":"<p>浏览器缓存是优化性能的一种方式，下面看看常见的 HTTP 缓存头，工作流程。</p>\n<p>当我们打开一个网站时，打开开发者工具 Network 面板，我们通常可以看到 from disk cache 缓存到硬盘，from memory cache 缓存到内存（chrome）这些字样，这个就是浏览器缓存。</p>\n<p>这个通常是怎么设置的呢，就是我们这里要介绍的 HTTP 缓存头。</p>\n<h2 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: Fri, 11 Jun 2021 11:33:01 GMT</span><br></pre></td></tr></table></figure>\n<p>Expires 的值是绝对时间，格林尼治时间，显示的也是服务器的时间</p>\n<p>不推荐 Expires，主要原因是：</p>\n<p>它设置的是绝对时间，如果系统时钟错了，或者不同时区之类的原因，缓存也会出错<br>优先级较低，会被覆盖，当然可用作兼容考虑</p>\n<h2 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: public, max-age=6400</span><br></pre></td></tr></table></figure>\n<p>Cache-Control 是相对时间，优先级高于 Expires，没有上面 Expires 的问题。但是，文件修改后，如果我是希望不要缓存的，不要等待 Cache-Control 设定的值，这种情况下：</p>\n<p>一方面，可以通过给资源每次修改加版本号或随机数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css?version=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>另一方面可以使用 Last-Modified 和 Etag 协商缓存来解决。接下来就讲讲这两个。</p>\n<h2 id=\"Last-Modified-和-If-Modified-Since\"><a href=\"#Last-Modified-和-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified 和 If-Modified-Since\"></a>Last-Modified 和 If-Modified-Since</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</span><br></pre></td></tr></table></figure>\n<p>Last-Modified 文件最后修改的时间，浏览器会缓存这个时间。</p>\n<p>与 Last-Modified 配合的请求头是 If-Modified-Since，就是缓存的 Last-Modified 的时间，那么是如何配合的呢？</p>\n<p>举个例子，每次当浏览器刷新的时候，当 Cache-Control 的时间已过的时候，询问下服务器 Last-Modified 是什么，然后和上次缓存到浏览器的 Last-Modified，也就是放在了请求头的 If-Modified-Since 作比较</p>\n<p>如果相同，服务器会返回 304，即请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，不用更新文件，使用浏览器缓存。<br>如果不同，服务器会返回 200，即会重新请求更新过的资源</p>\n<h2 id=\"Etag-和-If-None-Match\"><a href=\"#Etag-和-If-None-Match\" class=\"headerlink\" title=\"Etag 和 If-None-Match\"></a>Etag 和 If-None-Match</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Etag: xxxx</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，只考虑了服务器文件修改时间，但是有时候，打开文件可能没有修改任何内容，而修改时间发生了变化，这个就造成了本应该继续缓存的文件，需要重新请求，这是不合理的，这时候就出现了 Etag。</p>\n<p>Etag 的值是文件的 Hash 值，文件内容是否变化可以通过文件的 Hash 值准确地判断。</p>\n<p>对应 Last-Modified 和 If-Modified-Since 的配合机制，Etag 和 If-None-Match 是同样的协商。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最常用的浏览器缓存就是这样做的，当然还有更多内容，不同的设定的值等等，如果想了解浏览器缓存更详细的信息，可以参考文章：</p>\n<p><a href=\"http://www.imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">HTTP 缓存控制小结</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching\" target=\"_blank\" rel=\"noopener\">Google 开发者文档：HTTP 缓存</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>浏览器缓存是优化性能的一种方式，下面看看常见的 HTTP 缓存头，工作流程。</p>\n<p>当我们打开一个网站时，打开开发者工具 Network 面板，我们通常可以看到 from disk cache 缓存到硬盘，from memory cache 缓存到内存（chrome）这些字样，这个就是浏览器缓存。</p>\n<p>这个通常是怎么设置的呢，就是我们这里要介绍的 HTTP 缓存头。</p>\n<h2 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: Fri, 11 Jun 2021 11:33:01 GMT</span><br></pre></td></tr></table></figure>\n<p>Expires 的值是绝对时间，格林尼治时间，显示的也是服务器的时间</p>\n<p>不推荐 Expires，主要原因是：</p>\n<p>它设置的是绝对时间，如果系统时钟错了，或者不同时区之类的原因，缓存也会出错<br>优先级较低，会被覆盖，当然可用作兼容考虑</p>\n<h2 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: public, max-age=6400</span><br></pre></td></tr></table></figure>\n<p>Cache-Control 是相对时间，优先级高于 Expires，没有上面 Expires 的问题。但是，文件修改后，如果我是希望不要缓存的，不要等待 Cache-Control 设定的值，这种情况下：</p>\n<p>一方面，可以通过给资源每次修改加版本号或随机数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css?version=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>另一方面可以使用 Last-Modified 和 Etag 协商缓存来解决。接下来就讲讲这两个。</p>\n<h2 id=\"Last-Modified-和-If-Modified-Since\"><a href=\"#Last-Modified-和-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified 和 If-Modified-Since\"></a>Last-Modified 和 If-Modified-Since</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</span><br></pre></td></tr></table></figure>\n<p>Last-Modified 文件最后修改的时间，浏览器会缓存这个时间。</p>\n<p>与 Last-Modified 配合的请求头是 If-Modified-Since，就是缓存的 Last-Modified 的时间，那么是如何配合的呢？</p>\n<p>举个例子，每次当浏览器刷新的时候，当 Cache-Control 的时间已过的时候，询问下服务器 Last-Modified 是什么，然后和上次缓存到浏览器的 Last-Modified，也就是放在了请求头的 If-Modified-Since 作比较</p>\n<p>如果相同，服务器会返回 304，即请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，不用更新文件，使用浏览器缓存。<br>如果不同，服务器会返回 200，即会重新请求更新过的资源</p>\n<h2 id=\"Etag-和-If-None-Match\"><a href=\"#Etag-和-If-None-Match\" class=\"headerlink\" title=\"Etag 和 If-None-Match\"></a>Etag 和 If-None-Match</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Etag: xxxx</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，只考虑了服务器文件修改时间，但是有时候，打开文件可能没有修改任何内容，而修改时间发生了变化，这个就造成了本应该继续缓存的文件，需要重新请求，这是不合理的，这时候就出现了 Etag。</p>\n<p>Etag 的值是文件的 Hash 值，文件内容是否变化可以通过文件的 Hash 值准确地判断。</p>\n<p>对应 Last-Modified 和 If-Modified-Since 的配合机制，Etag 和 If-None-Match 是同样的协商。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最常用的浏览器缓存就是这样做的，当然还有更多内容，不同的设定的值等等，如果想了解浏览器缓存更详细的信息，可以参考文章：</p>\n<p><a href=\"http://www.imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">HTTP 缓存控制小结</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching\" target=\"_blank\" rel=\"noopener\">Google 开发者文档：HTTP 缓存</a></p>\n"},{"title":"JS 简写技术","date":"2018-07-22T14:21:25.000Z","_content":"\n> 转载 [19 个 JS 常用的简写技术](https://juejin.im/post/5948db9661ff4b006c061b2b)\n\n## 三元操作符\n\n当想写 if...else 语句时，使用三元操作符来代替\n\n```js\nconst x = 20;\nlet answer;\nif (x > 10) {\n  answer = \"is greater\";\n} else {\n  answer = \"is lesser\";\n}\n```\n\n简写：\n\n```js\nconst answer = x => (10 ? \"is greater\" : \"is lesser\");\n```\n\n也可以嵌套 if 语句\n\n```js\nconst big = x > 10 ? \"greater 10\" : x;\n```\n\n## 短路求值简写方式\n\n当给一个变量分配另一个值的时候，想确定源值是不是 null,undefined 或空值。可以撰写一个多重条件的 if 语句\n\n测试 ing\n\n```js\nif (temp !== null || temp !== undefined || temp !== \"\") {\n  let temp2 = temp;\n}\n```\n\n或者可以使用短路求值方法：\n\n```js\nconst temp2 = temp || \"new\";\n```\n\n## 声明变量简写方法\n\n```js\nlet x;\nlet y;\nlet z = 3;\n```\n\n简写方法:\n\n```js\nlet x,\n  y,\n  z = 3;\n```\n\n## if 存在条件简写方法\n\n    if(likeJavaScript===true)\n\n简写：\n\n    if(likeJavaScript)\n\n只有 likeJavaScript 是真值的时候，二者语句才相等\n\n如果判断值不是真值，则可以这样\n\n```js\nlet a;\nif (a !== true) {\n  //do something...\n}\n```\n\n简写：\n\n```js\nlet a;\nif (!a) {\n  //do something\n}\n```\n\n## JS 循环简写方法\n\n    for (let i=0;i<allImgs.length;i++)\n\n简写：\n\n    for(let index in allImgs)\n\n也可以使用 Array.forEach\n\n```js\nfunction logArrayElements(element,index,array){\n    console.log('a['+index+']='+element);\n}\n[2.5.9].forEach(logArrayElements);\n```\n\n## 短路评价\n\n给一个变量分配的值是通过判断其值是否为 null 或者 undefined，则可以：\n\n```js\nlet dbhost;\nif (process.env.DB_HOST) {\n  dbHost = process.env.DB_HOST;\n} else {\n  dbHost = \"localhost\";\n}\n```\n\n简写:\n\n    const dbHost=process.env.DB_HOST||'localhost'\n\n## 十进制指数\n\n当需要写数字带有很多零时(如 10000000)，可以采用指数(1e7)来代替这个数字：\n\n    for(let i=0;i<10000;i++){}\n\n简写：\n\n    for(let i=0;i<1e7;i++){}\n\n## 对象属性简写\n\n如果属性名与 key 名相同，则可以采用 es6 的方法：\n\n    const obj={x:x,y:y}\n\n简写：\n\n    const obj={x,y};\n\n## 箭头函数简写\n\n传统函数编写方法很容易让人理解和编写，但是当嵌套在另一个函数中，则这些优势就荡然无存\n\n```js\nfunction sayHello(name) {\n  console.log(\"hello\", name);\n}\nsetTimeout(function() {\n  console.log(\"Loaden\");\n}, 2000);\nlist.forEach(function(item) {\n  console.log(item);\n});\n```\n\n简写：\n\n```js\nsayHello = nae => console.log(\"Hello\", name);\n\nsetTimeout(() => console.log(\"Loaden\"), 2000);\n\nlist.forEach(item => console.log(item));\n```\n\n## 隐式返回值简写\n\n经常使用 return 语句来返回最终结果，一个单独语句的箭头函数能隐试返回其值（函数必须省略{}为了省略 return 关键字）\n\n为返回多行语句（例如对象字面表达式)，则需要使用()包围函数体\n\n```js\nfunction calcCircumference(diameter) {\n  return Math.PI * diameter;\n}\nvar func = function func() {\n  return { foo: 1 };\n};\n```\n\n简写：\n\n```js\ncalcCircumference = diameter => {\n  Math.PI * diameter;\n};\nvar func = () => ({ foo: 1 });\n```\n\n## 默认参数值\n\n为了给函数中参数传递默认值，通常使用 if 语句来编写，但是使用 es6 定义默认值，则会很简洁：\n\n```js\nfunction valume(l, w, h) {\n  if (w === undefined) w = 3;\n  if (h === undefined) h = 4;\n  return l * w * h;\n}\n```\n\n简写：\n\n```js\nvolume = (l, w = 3, h = 4) => l * w * h;\nvolume(2);\n```\n\n## 模板字符串\n\n传统的 JS 语言，输出模板通常是这样写的\n\n```js\nconst welcome = \"you have logged in as\" + first + \"  \" + last + \".\";\nconst db = \"http://\" + host + \":\" + port + \"/\" + database;\n```\n\nes6 可以使用反引号和\\${}简写：\n\n```js\nconst welcome = `you have logged in as ${first} ${last}`;\nconst db = `http://${host}/${database}`;\n```\n\n## 结构赋值简写方法\n\n在 web 框架中，经常需要从组件和 API 之间来回传递数组或对象字面形式的数据，然后需要解构它\n\n```js\nconst observable = require(\"mobx/observable\");\nconst action = require(\"mobx/action\");\nconst runInAction = require(\"mobx/runInAction\");\n\nconst store = this.props.store;\nconst form = this.props.form;\nconst loading = this.props.loading;\nconst errors = this.props.errors;\nconst entity = this.props.entity;\n```\n\n简写：\n\n```js\nimport { observable, action, runInAction } from \"mobx\";\nconst { store, form, loading, errors, entity } = this.props;\n```\n\n也可以分配变量名：\n\n```js\nconst { store, form, loading, errors, entity: contact } = this.props;\n```\n\n## 多行字符串简写\n\n需要输出多行字符串，需要使用+来拼接：\n\n```js\nconst lorem =\n  \"Lorem ipsum dolor sit amet, consectetur\\n\\t\" +\n  \"adipisicing elit, sed do eiusmod tempor incididunt\\n\\t\" +\n  \"ut labore et dolore magna aliqua. Ut enim ad minim\\n\\t\" +\n  \"veniam, quis nostrud exercitation ullamco laboris\\n\\t\" +\n  \"nisi ut aliquip ex ea commodo consequat. Duis aute\\n\\t\" +\n  \"irure dolor in reprehenderit in voluptate velit esse.\\n\\t\";\n```\n\n使用反引号，则可以达到简写作用：\n\n```js\nconst lorem = `Lorem ipsum dolor sit amet, consectetur\n    adipisicing elit, sed do eiusmod tempor incididunt\n    ut labore et dolore magna aliqua. Ut enim ad minim\n    veniam, quis nostrud exercitation ullamco laboris\n    nisi ut aliquip ex ea commodo consequat. Duis aute\n    irure dolor in reprehenderit in voluptate velit esse.`;\n```\n\n## 扩展运算符简写\n\n扩展运算符有几种用例让 JS 代码更加有效使用，可以用来代替某个数组函数\n\n```js\n//joining arrays\nconst odd = [1, 3, 5];\nconst nums = [2, 4, 6].concat(odd);\n//cloning arrays\nconst arr = [1, 2, 3, 4];\nconst arr2 = arr.slice();\n```\n\n简写:\n\n```js\n// joining arrays\nconst odd = [1, 3, 5];\nconst nums = [2, 4, 6, ...odd];\nconsole.log(nums); // [ 2, 4, 6, 1, 3, 5 ]\n\n// cloning arrays\nconst arr = [1, 2, 3, 4];\nconst arr2 = [...arr];\n```\n\n不像 concat()函数，可以使用扩展运算符在一个数组中任意处插入另一个数组\n\n```js\nconst odd = [1, 3, 5];\nconst nums = [2, ...odd, 4, 6];\n```\n\n也可以使用扩展运算符解构\n\n```js\nconst { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };\nconsole.log(a); // 1\nconsole.log(b); // 2\nconsole.log(z); // { c: 3, d: 4 }\n```\n\n## 强制参数简写\n\nJS 中如果没有向函数参数传递值，则参数为 undefined。为了增强参数赋值，可以使用 if 语句来抛出异常，或使用强制参数简写方法\n\n```js\nfunction foo(bar) {\n  if (bar === undefined) {\n    throw new Error(\"Missing parameter!\");\n  }\n  return bar;\n}\n```\n\n简写：\n\n```js\nmandatory = () => {\n  throw new Error(\"Missing parameter!\");\n};\nfoo = (bar = mandatory()) => {\n  return bar;\n};\n```\n\n## Array.find 简写\n\n想从数组中查找某个值，则需要循环在 ES6 中，find()函数能实现同样效果\n\n```js\nconst pets = [\n  { type: \"Dog\", name: \"Max\" },\n  { type: \"Cat\", name: \"Karl\" },\n  { type: \"Dog\", name: \"Tommy\" }\n];\n\nfunction findDog(name) {\n  for (let i = 0; i < pets.length; ++i) {\n    if (pets[i].type === \"Dog\" && pets[i].name === name) {\n      return pets[i];\n    }\n  }\n}\n```\n\n简写：\n\n```js\npet = pets.find(pet => pet.type === \"Dog\" && pet.name === \"Tommy\");\nconsole.log(pet);\n```\n\n## Object[key]简写\n\n考虑一个验证函数\n\n```js\nfunction validate(values) {\n  if (!values.first) return false;\n  if (!values.last) return false;\n  return true;\n}\nconsole.log(validate({ first: \"Bruce\", last: \"Wayne\" }));\n```\n\n假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认\n\n```js\n// 对象验证规则\nconst schema = {\n  first: {\n    required: true\n  },\n  last: {\n    required: true\n  }\n};\n\n// 通用验证函数\nconst validate = (schema, values) => {\n  for (field in schema) {\n    if (schema[field].required) {\n      if (!values[field]) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconsole.log(validate(schema, { first: \"Bruce\" })); // false\nconsole.log(validate(schema, { first: \"Bruce\", last: \"Wayne\" })); // true\n```\n\n## 双重非位运算简写\n\n有一个有效用于双重非运算操作符。可以用来代替 Math.floor()，其优势在于运行更快\n\n    Math.floor(4.9)===4\n\n简写\n\n    ~~4.9===4\n","source":"_posts/JS-简写技术.md","raw":"---\ntitle: JS 简写技术\ndate: 2018-07-22 22:21:25\ntags:\n  - JavaScript\n---\n\n> 转载 [19 个 JS 常用的简写技术](https://juejin.im/post/5948db9661ff4b006c061b2b)\n\n## 三元操作符\n\n当想写 if...else 语句时，使用三元操作符来代替\n\n```js\nconst x = 20;\nlet answer;\nif (x > 10) {\n  answer = \"is greater\";\n} else {\n  answer = \"is lesser\";\n}\n```\n\n简写：\n\n```js\nconst answer = x => (10 ? \"is greater\" : \"is lesser\");\n```\n\n也可以嵌套 if 语句\n\n```js\nconst big = x > 10 ? \"greater 10\" : x;\n```\n\n## 短路求值简写方式\n\n当给一个变量分配另一个值的时候，想确定源值是不是 null,undefined 或空值。可以撰写一个多重条件的 if 语句\n\n测试 ing\n\n```js\nif (temp !== null || temp !== undefined || temp !== \"\") {\n  let temp2 = temp;\n}\n```\n\n或者可以使用短路求值方法：\n\n```js\nconst temp2 = temp || \"new\";\n```\n\n## 声明变量简写方法\n\n```js\nlet x;\nlet y;\nlet z = 3;\n```\n\n简写方法:\n\n```js\nlet x,\n  y,\n  z = 3;\n```\n\n## if 存在条件简写方法\n\n    if(likeJavaScript===true)\n\n简写：\n\n    if(likeJavaScript)\n\n只有 likeJavaScript 是真值的时候，二者语句才相等\n\n如果判断值不是真值，则可以这样\n\n```js\nlet a;\nif (a !== true) {\n  //do something...\n}\n```\n\n简写：\n\n```js\nlet a;\nif (!a) {\n  //do something\n}\n```\n\n## JS 循环简写方法\n\n    for (let i=0;i<allImgs.length;i++)\n\n简写：\n\n    for(let index in allImgs)\n\n也可以使用 Array.forEach\n\n```js\nfunction logArrayElements(element,index,array){\n    console.log('a['+index+']='+element);\n}\n[2.5.9].forEach(logArrayElements);\n```\n\n## 短路评价\n\n给一个变量分配的值是通过判断其值是否为 null 或者 undefined，则可以：\n\n```js\nlet dbhost;\nif (process.env.DB_HOST) {\n  dbHost = process.env.DB_HOST;\n} else {\n  dbHost = \"localhost\";\n}\n```\n\n简写:\n\n    const dbHost=process.env.DB_HOST||'localhost'\n\n## 十进制指数\n\n当需要写数字带有很多零时(如 10000000)，可以采用指数(1e7)来代替这个数字：\n\n    for(let i=0;i<10000;i++){}\n\n简写：\n\n    for(let i=0;i<1e7;i++){}\n\n## 对象属性简写\n\n如果属性名与 key 名相同，则可以采用 es6 的方法：\n\n    const obj={x:x,y:y}\n\n简写：\n\n    const obj={x,y};\n\n## 箭头函数简写\n\n传统函数编写方法很容易让人理解和编写，但是当嵌套在另一个函数中，则这些优势就荡然无存\n\n```js\nfunction sayHello(name) {\n  console.log(\"hello\", name);\n}\nsetTimeout(function() {\n  console.log(\"Loaden\");\n}, 2000);\nlist.forEach(function(item) {\n  console.log(item);\n});\n```\n\n简写：\n\n```js\nsayHello = nae => console.log(\"Hello\", name);\n\nsetTimeout(() => console.log(\"Loaden\"), 2000);\n\nlist.forEach(item => console.log(item));\n```\n\n## 隐式返回值简写\n\n经常使用 return 语句来返回最终结果，一个单独语句的箭头函数能隐试返回其值（函数必须省略{}为了省略 return 关键字）\n\n为返回多行语句（例如对象字面表达式)，则需要使用()包围函数体\n\n```js\nfunction calcCircumference(diameter) {\n  return Math.PI * diameter;\n}\nvar func = function func() {\n  return { foo: 1 };\n};\n```\n\n简写：\n\n```js\ncalcCircumference = diameter => {\n  Math.PI * diameter;\n};\nvar func = () => ({ foo: 1 });\n```\n\n## 默认参数值\n\n为了给函数中参数传递默认值，通常使用 if 语句来编写，但是使用 es6 定义默认值，则会很简洁：\n\n```js\nfunction valume(l, w, h) {\n  if (w === undefined) w = 3;\n  if (h === undefined) h = 4;\n  return l * w * h;\n}\n```\n\n简写：\n\n```js\nvolume = (l, w = 3, h = 4) => l * w * h;\nvolume(2);\n```\n\n## 模板字符串\n\n传统的 JS 语言，输出模板通常是这样写的\n\n```js\nconst welcome = \"you have logged in as\" + first + \"  \" + last + \".\";\nconst db = \"http://\" + host + \":\" + port + \"/\" + database;\n```\n\nes6 可以使用反引号和\\${}简写：\n\n```js\nconst welcome = `you have logged in as ${first} ${last}`;\nconst db = `http://${host}/${database}`;\n```\n\n## 结构赋值简写方法\n\n在 web 框架中，经常需要从组件和 API 之间来回传递数组或对象字面形式的数据，然后需要解构它\n\n```js\nconst observable = require(\"mobx/observable\");\nconst action = require(\"mobx/action\");\nconst runInAction = require(\"mobx/runInAction\");\n\nconst store = this.props.store;\nconst form = this.props.form;\nconst loading = this.props.loading;\nconst errors = this.props.errors;\nconst entity = this.props.entity;\n```\n\n简写：\n\n```js\nimport { observable, action, runInAction } from \"mobx\";\nconst { store, form, loading, errors, entity } = this.props;\n```\n\n也可以分配变量名：\n\n```js\nconst { store, form, loading, errors, entity: contact } = this.props;\n```\n\n## 多行字符串简写\n\n需要输出多行字符串，需要使用+来拼接：\n\n```js\nconst lorem =\n  \"Lorem ipsum dolor sit amet, consectetur\\n\\t\" +\n  \"adipisicing elit, sed do eiusmod tempor incididunt\\n\\t\" +\n  \"ut labore et dolore magna aliqua. Ut enim ad minim\\n\\t\" +\n  \"veniam, quis nostrud exercitation ullamco laboris\\n\\t\" +\n  \"nisi ut aliquip ex ea commodo consequat. Duis aute\\n\\t\" +\n  \"irure dolor in reprehenderit in voluptate velit esse.\\n\\t\";\n```\n\n使用反引号，则可以达到简写作用：\n\n```js\nconst lorem = `Lorem ipsum dolor sit amet, consectetur\n    adipisicing elit, sed do eiusmod tempor incididunt\n    ut labore et dolore magna aliqua. Ut enim ad minim\n    veniam, quis nostrud exercitation ullamco laboris\n    nisi ut aliquip ex ea commodo consequat. Duis aute\n    irure dolor in reprehenderit in voluptate velit esse.`;\n```\n\n## 扩展运算符简写\n\n扩展运算符有几种用例让 JS 代码更加有效使用，可以用来代替某个数组函数\n\n```js\n//joining arrays\nconst odd = [1, 3, 5];\nconst nums = [2, 4, 6].concat(odd);\n//cloning arrays\nconst arr = [1, 2, 3, 4];\nconst arr2 = arr.slice();\n```\n\n简写:\n\n```js\n// joining arrays\nconst odd = [1, 3, 5];\nconst nums = [2, 4, 6, ...odd];\nconsole.log(nums); // [ 2, 4, 6, 1, 3, 5 ]\n\n// cloning arrays\nconst arr = [1, 2, 3, 4];\nconst arr2 = [...arr];\n```\n\n不像 concat()函数，可以使用扩展运算符在一个数组中任意处插入另一个数组\n\n```js\nconst odd = [1, 3, 5];\nconst nums = [2, ...odd, 4, 6];\n```\n\n也可以使用扩展运算符解构\n\n```js\nconst { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };\nconsole.log(a); // 1\nconsole.log(b); // 2\nconsole.log(z); // { c: 3, d: 4 }\n```\n\n## 强制参数简写\n\nJS 中如果没有向函数参数传递值，则参数为 undefined。为了增强参数赋值，可以使用 if 语句来抛出异常，或使用强制参数简写方法\n\n```js\nfunction foo(bar) {\n  if (bar === undefined) {\n    throw new Error(\"Missing parameter!\");\n  }\n  return bar;\n}\n```\n\n简写：\n\n```js\nmandatory = () => {\n  throw new Error(\"Missing parameter!\");\n};\nfoo = (bar = mandatory()) => {\n  return bar;\n};\n```\n\n## Array.find 简写\n\n想从数组中查找某个值，则需要循环在 ES6 中，find()函数能实现同样效果\n\n```js\nconst pets = [\n  { type: \"Dog\", name: \"Max\" },\n  { type: \"Cat\", name: \"Karl\" },\n  { type: \"Dog\", name: \"Tommy\" }\n];\n\nfunction findDog(name) {\n  for (let i = 0; i < pets.length; ++i) {\n    if (pets[i].type === \"Dog\" && pets[i].name === name) {\n      return pets[i];\n    }\n  }\n}\n```\n\n简写：\n\n```js\npet = pets.find(pet => pet.type === \"Dog\" && pet.name === \"Tommy\");\nconsole.log(pet);\n```\n\n## Object[key]简写\n\n考虑一个验证函数\n\n```js\nfunction validate(values) {\n  if (!values.first) return false;\n  if (!values.last) return false;\n  return true;\n}\nconsole.log(validate({ first: \"Bruce\", last: \"Wayne\" }));\n```\n\n假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认\n\n```js\n// 对象验证规则\nconst schema = {\n  first: {\n    required: true\n  },\n  last: {\n    required: true\n  }\n};\n\n// 通用验证函数\nconst validate = (schema, values) => {\n  for (field in schema) {\n    if (schema[field].required) {\n      if (!values[field]) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconsole.log(validate(schema, { first: \"Bruce\" })); // false\nconsole.log(validate(schema, { first: \"Bruce\", last: \"Wayne\" })); // true\n```\n\n## 双重非位运算简写\n\n有一个有效用于双重非运算操作符。可以用来代替 Math.floor()，其优势在于运行更快\n\n    Math.floor(4.9)===4\n\n简写\n\n    ~~4.9===4\n","slug":"JS-简写技术","published":1,"updated":"2018-12-25T07:24:50.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2jb8001cgzq2zqleahom","content":"<blockquote>\n<p>转载 <a href=\"https://juejin.im/post/5948db9661ff4b006c061b2b\" target=\"_blank\" rel=\"noopener\">19 个 JS 常用的简写技术</a></p>\n</blockquote>\n<h2 id=\"三元操作符\"><a href=\"#三元操作符\" class=\"headerlink\" title=\"三元操作符\"></a>三元操作符</h2><p>当想写 if…else 语句时，使用三元操作符来代替</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> answer;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  answer = <span class=\"string\">\"is greater\"</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  answer = <span class=\"string\">\"is lesser\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> answer = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (<span class=\"number\">10</span> ? <span class=\"string\">\"is greater\"</span> : <span class=\"string\">\"is lesser\"</span>);</span><br></pre></td></tr></table></figure>\n<p>也可以嵌套 if 语句</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> big = x &gt; <span class=\"number\">10</span> ? <span class=\"string\">\"greater 10\"</span> : x;</span><br></pre></td></tr></table></figure>\n<h2 id=\"短路求值简写方式\"><a href=\"#短路求值简写方式\" class=\"headerlink\" title=\"短路求值简写方式\"></a>短路求值简写方式</h2><p>当给一个变量分配另一个值的时候，想确定源值是不是 null,undefined 或空值。可以撰写一个多重条件的 if 语句</p>\n<p>测试 ing</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (temp !== <span class=\"literal\">null</span> || temp !== <span class=\"literal\">undefined</span> || temp !== <span class=\"string\">\"\"</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp2 = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者可以使用短路求值方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> temp2 = temp || <span class=\"string\">\"new\"</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明变量简写方法\"><a href=\"#声明变量简写方法\" class=\"headerlink\" title=\"声明变量简写方法\"></a>声明变量简写方法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y;</span><br><span class=\"line\"><span class=\"keyword\">let</span> z = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>简写方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x,</span><br><span class=\"line\">  y,</span><br><span class=\"line\">  z = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-存在条件简写方法\"><a href=\"#if-存在条件简写方法\" class=\"headerlink\" title=\"if 存在条件简写方法\"></a>if 存在条件简写方法</h2><pre><code>if(likeJavaScript===true)\n</code></pre><p>简写：</p>\n<pre><code>if(likeJavaScript)\n</code></pre><p>只有 likeJavaScript 是真值的时候，二者语句才相等</p>\n<p>如果判断值不是真值，则可以这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a !== <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!a) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS-循环简写方法\"><a href=\"#JS-循环简写方法\" class=\"headerlink\" title=\"JS 循环简写方法\"></a>JS 循环简写方法</h2><pre><code>for (let i=0;i&lt;allImgs.length;i++)\n</code></pre><p>简写：</p>\n<pre><code>for(let index in allImgs)\n</code></pre><p>也可以使用 Array.forEach</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logArrayElements</span>(<span class=\"params\">element,index,array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a['</span>+index+<span class=\"string\">']='</span>+element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[<span class=\"number\">2.5</span><span class=\"number\">.9</span>].forEach(logArrayElements);</span><br></pre></td></tr></table></figure>\n<h2 id=\"短路评价\"><a href=\"#短路评价\" class=\"headerlink\" title=\"短路评价\"></a>短路评价</h2><p>给一个变量分配的值是通过判断其值是否为 null 或者 undefined，则可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dbhost;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.DB_HOST) &#123;</span><br><span class=\"line\">  dbHost = process.env.DB_HOST;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  dbHost = <span class=\"string\">\"localhost\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写:</p>\n<pre><code>const dbHost=process.env.DB_HOST||&apos;localhost&apos;\n</code></pre><h2 id=\"十进制指数\"><a href=\"#十进制指数\" class=\"headerlink\" title=\"十进制指数\"></a>十进制指数</h2><p>当需要写数字带有很多零时(如 10000000)，可以采用指数(1e7)来代替这个数字：</p>\n<pre><code>for(let i=0;i&lt;10000;i++){}\n</code></pre><p>简写：</p>\n<pre><code>for(let i=0;i&lt;1e7;i++){}\n</code></pre><h2 id=\"对象属性简写\"><a href=\"#对象属性简写\" class=\"headerlink\" title=\"对象属性简写\"></a>对象属性简写</h2><p>如果属性名与 key 名相同，则可以采用 es6 的方法：</p>\n<pre><code>const obj={x:x,y:y}\n</code></pre><p>简写：</p>\n<pre><code>const obj={x,y};\n</code></pre><h2 id=\"箭头函数简写\"><a href=\"#箭头函数简写\" class=\"headerlink\" title=\"箭头函数简写\"></a>箭头函数简写</h2><p>传统函数编写方法很容易让人理解和编写，但是当嵌套在另一个函数中，则这些优势就荡然无存</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Loaden\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">list.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sayHello = <span class=\"function\"><span class=\"params\">nae</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>, name);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Loaden\"</span>), <span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">list.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">console</span>.log(item));</span><br></pre></td></tr></table></figure>\n<h2 id=\"隐式返回值简写\"><a href=\"#隐式返回值简写\" class=\"headerlink\" title=\"隐式返回值简写\"></a>隐式返回值简写</h2><p>经常使用 return 语句来返回最终结果，一个单独语句的箭头函数能隐试返回其值（函数必须省略{}为了省略 return 关键字）</p>\n<p>为返回多行语句（例如对象字面表达式)，则需要使用()包围函数体</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calcCircumference</span>(<span class=\"params\">diameter</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * diameter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">foo</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calcCircumference = <span class=\"function\"><span class=\"params\">diameter</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Math</span>.PI * diameter;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123; <span class=\"attr\">foo</span>: <span class=\"number\">1</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"默认参数值\"><a href=\"#默认参数值\" class=\"headerlink\" title=\"默认参数值\"></a>默认参数值</h2><p>为了给函数中参数传递默认值，通常使用 if 语句来编写，但是使用 es6 定义默认值，则会很简洁：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">valume</span>(<span class=\"params\">l, w, h</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (w === <span class=\"literal\">undefined</span>) w = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (h === <span class=\"literal\">undefined</span>) h = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l * w * h;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">volume = <span class=\"function\">(<span class=\"params\">l, w = <span class=\"number\">3</span>, h = <span class=\"number\">4</span></span>) =&gt;</span> l * w * h;</span><br><span class=\"line\">volume(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>传统的 JS 语言，输出模板通常是这样写的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> welcome = <span class=\"string\">\"you have logged in as\"</span> + first + <span class=\"string\">\"  \"</span> + last + <span class=\"string\">\".\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"string\">\"http://\"</span> + host + <span class=\"string\">\":\"</span> + port + <span class=\"string\">\"/\"</span> + database;</span><br></pre></td></tr></table></figure>\n<p>es6 可以使用反引号和\\${}简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> welcome = <span class=\"string\">`you have logged in as <span class=\"subst\">$&#123;first&#125;</span> <span class=\"subst\">$&#123;last&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"string\">`http://<span class=\"subst\">$&#123;host&#125;</span>/<span class=\"subst\">$&#123;database&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结构赋值简写方法\"><a href=\"#结构赋值简写方法\" class=\"headerlink\" title=\"结构赋值简写方法\"></a>结构赋值简写方法</h2><p>在 web 框架中，经常需要从组件和 API 之间来回传递数组或对象字面形式的数据，然后需要解构它</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> observable = <span class=\"built_in\">require</span>(<span class=\"string\">\"mobx/observable\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> action = <span class=\"built_in\">require</span>(<span class=\"string\">\"mobx/action\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> runInAction = <span class=\"built_in\">require</span>(<span class=\"string\">\"mobx/runInAction\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span>.props.store;</span><br><span class=\"line\"><span class=\"keyword\">const</span> form = <span class=\"keyword\">this</span>.props.form;</span><br><span class=\"line\"><span class=\"keyword\">const</span> loading = <span class=\"keyword\">this</span>.props.loading;</span><br><span class=\"line\"><span class=\"keyword\">const</span> errors = <span class=\"keyword\">this</span>.props.errors;</span><br><span class=\"line\"><span class=\"keyword\">const</span> entity = <span class=\"keyword\">this</span>.props.entity;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; observable, action, runInAction &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"mobx\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; store, form, loading, errors, entity &#125; = <span class=\"keyword\">this</span>.props;</span><br></pre></td></tr></table></figure>\n<p>也可以分配变量名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; store, form, loading, errors, <span class=\"attr\">entity</span>: contact &#125; = <span class=\"keyword\">this</span>.props;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多行字符串简写\"><a href=\"#多行字符串简写\" class=\"headerlink\" title=\"多行字符串简写\"></a>多行字符串简写</h2><p>需要输出多行字符串，需要使用+来拼接：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lorem =</span><br><span class=\"line\">  <span class=\"string\">\"Lorem ipsum dolor sit amet, consectetur\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"adipisicing elit, sed do eiusmod tempor incididunt\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"ut labore et dolore magna aliqua. Ut enim ad minim\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"veniam, quis nostrud exercitation ullamco laboris\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"nisi ut aliquip ex ea commodo consequat. Duis aute\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"irure dolor in reprehenderit in voluptate velit esse.\\n\\t\"</span>;</span><br></pre></td></tr></table></figure>\n<p>使用反引号，则可以达到简写作用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lorem = <span class=\"string\">`Lorem ipsum dolor sit amet, consectetur</span></span><br><span class=\"line\"><span class=\"string\">    adipisicing elit, sed do eiusmod tempor incididunt</span></span><br><span class=\"line\"><span class=\"string\">    ut labore et dolore magna aliqua. Ut enim ad minim</span></span><br><span class=\"line\"><span class=\"string\">    veniam, quis nostrud exercitation ullamco laboris</span></span><br><span class=\"line\"><span class=\"string\">    nisi ut aliquip ex ea commodo consequat. Duis aute</span></span><br><span class=\"line\"><span class=\"string\">    irure dolor in reprehenderit in voluptate velit esse.`</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"扩展运算符简写\"><a href=\"#扩展运算符简写\" class=\"headerlink\" title=\"扩展运算符简写\"></a>扩展运算符简写</h2><p>扩展运算符有几种用例让 JS 代码更加有效使用，可以用来代替某个数组函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//joining arrays</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> odd = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> nums = [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].concat(odd);</span><br><span class=\"line\"><span class=\"comment\">//cloning arrays</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = arr.slice();</span><br></pre></td></tr></table></figure>\n<p>简写:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// joining arrays</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> odd = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> nums = [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, ...odd];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nums); <span class=\"comment\">// [ 2, 4, 6, 1, 3, 5 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cloning arrays</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = [...arr];</span><br></pre></td></tr></table></figure>\n<p>不像 concat()函数，可以使用扩展运算符在一个数组中任意处插入另一个数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> odd = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> nums = [<span class=\"number\">2</span>, ...odd, <span class=\"number\">4</span>, <span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n<p>也可以使用扩展运算符解构</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; a, b, ...z &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">3</span>, <span class=\"attr\">d</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z); <span class=\"comment\">// &#123; c: 3, d: 4 &#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"强制参数简写\"><a href=\"#强制参数简写\" class=\"headerlink\" title=\"强制参数简写\"></a>强制参数简写</h2><p>JS 中如果没有向函数参数传递值，则参数为 undefined。为了增强参数赋值，可以使用 if 语句来抛出异常，或使用强制参数简写方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">bar</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bar === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Missing parameter!\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mandatory = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Missing parameter!\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo = <span class=\"function\">(<span class=\"params\">bar = mandatory(</span>)) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Array-find-简写\"><a href=\"#Array-find-简写\" class=\"headerlink\" title=\"Array.find 简写\"></a>Array.find 简写</h2><p>想从数组中查找某个值，则需要循环在 ES6 中，find()函数能实现同样效果</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pets = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"Dog\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"Max\"</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"Cat\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"Karl\"</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"Dog\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"Tommy\"</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findDog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; pets.length; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pets[i].type === <span class=\"string\">\"Dog\"</span> &amp;&amp; pets[i].name === name) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> pets[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = pets.find(<span class=\"function\"><span class=\"params\">pet</span> =&gt;</span> pet.type === <span class=\"string\">\"Dog\"</span> &amp;&amp; pet.name === <span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-key-简写\"><a href=\"#Object-key-简写\" class=\"headerlink\" title=\"Object[key]简写\"></a>Object[key]简写</h2><p>考虑一个验证函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">validate</span>(<span class=\"params\">values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!values.first) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!values.last) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(validate(&#123; <span class=\"attr\">first</span>: <span class=\"string\">\"Bruce\"</span>, <span class=\"attr\">last</span>: <span class=\"string\">\"Wayne\"</span> &#125;));</span><br></pre></td></tr></table></figure>\n<p>假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对象验证规则</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> schema = &#123;</span><br><span class=\"line\">  first: &#123;</span><br><span class=\"line\">    required: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  last: &#123;</span><br><span class=\"line\">    required: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通用验证函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> validate = <span class=\"function\">(<span class=\"params\">schema, values</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (field <span class=\"keyword\">in</span> schema) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (schema[field].required) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!values[field]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(validate(schema, &#123; <span class=\"attr\">first</span>: <span class=\"string\">\"Bruce\"</span> &#125;)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(validate(schema, &#123; <span class=\"attr\">first</span>: <span class=\"string\">\"Bruce\"</span>, <span class=\"attr\">last</span>: <span class=\"string\">\"Wayne\"</span> &#125;)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"双重非位运算简写\"><a href=\"#双重非位运算简写\" class=\"headerlink\" title=\"双重非位运算简写\"></a>双重非位运算简写</h2><p>有一个有效用于双重非运算操作符。可以用来代替 Math.floor()，其优势在于运行更快</p>\n<pre><code>Math.floor(4.9)===4\n</code></pre><p>简写</p>\n<pre><code>~~4.9===4\n</code></pre>","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<blockquote>\n<p>转载 <a href=\"https://juejin.im/post/5948db9661ff4b006c061b2b\" target=\"_blank\" rel=\"noopener\">19 个 JS 常用的简写技术</a></p>\n</blockquote>\n<h2 id=\"三元操作符\"><a href=\"#三元操作符\" class=\"headerlink\" title=\"三元操作符\"></a>三元操作符</h2><p>当想写 if…else 语句时，使用三元操作符来代替</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> answer;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  answer = <span class=\"string\">\"is greater\"</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  answer = <span class=\"string\">\"is lesser\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> answer = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (<span class=\"number\">10</span> ? <span class=\"string\">\"is greater\"</span> : <span class=\"string\">\"is lesser\"</span>);</span><br></pre></td></tr></table></figure>\n<p>也可以嵌套 if 语句</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> big = x &gt; <span class=\"number\">10</span> ? <span class=\"string\">\"greater 10\"</span> : x;</span><br></pre></td></tr></table></figure>\n<h2 id=\"短路求值简写方式\"><a href=\"#短路求值简写方式\" class=\"headerlink\" title=\"短路求值简写方式\"></a>短路求值简写方式</h2><p>当给一个变量分配另一个值的时候，想确定源值是不是 null,undefined 或空值。可以撰写一个多重条件的 if 语句</p>\n<p>测试 ing</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (temp !== <span class=\"literal\">null</span> || temp !== <span class=\"literal\">undefined</span> || temp !== <span class=\"string\">\"\"</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp2 = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者可以使用短路求值方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> temp2 = temp || <span class=\"string\">\"new\"</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明变量简写方法\"><a href=\"#声明变量简写方法\" class=\"headerlink\" title=\"声明变量简写方法\"></a>声明变量简写方法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y;</span><br><span class=\"line\"><span class=\"keyword\">let</span> z = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>简写方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x,</span><br><span class=\"line\">  y,</span><br><span class=\"line\">  z = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-存在条件简写方法\"><a href=\"#if-存在条件简写方法\" class=\"headerlink\" title=\"if 存在条件简写方法\"></a>if 存在条件简写方法</h2><pre><code>if(likeJavaScript===true)\n</code></pre><p>简写：</p>\n<pre><code>if(likeJavaScript)\n</code></pre><p>只有 likeJavaScript 是真值的时候，二者语句才相等</p>\n<p>如果判断值不是真值，则可以这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a !== <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!a) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS-循环简写方法\"><a href=\"#JS-循环简写方法\" class=\"headerlink\" title=\"JS 循环简写方法\"></a>JS 循环简写方法</h2><pre><code>for (let i=0;i&lt;allImgs.length;i++)\n</code></pre><p>简写：</p>\n<pre><code>for(let index in allImgs)\n</code></pre><p>也可以使用 Array.forEach</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logArrayElements</span>(<span class=\"params\">element,index,array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a['</span>+index+<span class=\"string\">']='</span>+element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[<span class=\"number\">2.5</span><span class=\"number\">.9</span>].forEach(logArrayElements);</span><br></pre></td></tr></table></figure>\n<h2 id=\"短路评价\"><a href=\"#短路评价\" class=\"headerlink\" title=\"短路评价\"></a>短路评价</h2><p>给一个变量分配的值是通过判断其值是否为 null 或者 undefined，则可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dbhost;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.DB_HOST) &#123;</span><br><span class=\"line\">  dbHost = process.env.DB_HOST;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  dbHost = <span class=\"string\">\"localhost\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写:</p>\n<pre><code>const dbHost=process.env.DB_HOST||&apos;localhost&apos;\n</code></pre><h2 id=\"十进制指数\"><a href=\"#十进制指数\" class=\"headerlink\" title=\"十进制指数\"></a>十进制指数</h2><p>当需要写数字带有很多零时(如 10000000)，可以采用指数(1e7)来代替这个数字：</p>\n<pre><code>for(let i=0;i&lt;10000;i++){}\n</code></pre><p>简写：</p>\n<pre><code>for(let i=0;i&lt;1e7;i++){}\n</code></pre><h2 id=\"对象属性简写\"><a href=\"#对象属性简写\" class=\"headerlink\" title=\"对象属性简写\"></a>对象属性简写</h2><p>如果属性名与 key 名相同，则可以采用 es6 的方法：</p>\n<pre><code>const obj={x:x,y:y}\n</code></pre><p>简写：</p>\n<pre><code>const obj={x,y};\n</code></pre><h2 id=\"箭头函数简写\"><a href=\"#箭头函数简写\" class=\"headerlink\" title=\"箭头函数简写\"></a>箭头函数简写</h2><p>传统函数编写方法很容易让人理解和编写，但是当嵌套在另一个函数中，则这些优势就荡然无存</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Loaden\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">list.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sayHello = <span class=\"function\"><span class=\"params\">nae</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>, name);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Loaden\"</span>), <span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">list.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">console</span>.log(item));</span><br></pre></td></tr></table></figure>\n<h2 id=\"隐式返回值简写\"><a href=\"#隐式返回值简写\" class=\"headerlink\" title=\"隐式返回值简写\"></a>隐式返回值简写</h2><p>经常使用 return 语句来返回最终结果，一个单独语句的箭头函数能隐试返回其值（函数必须省略{}为了省略 return 关键字）</p>\n<p>为返回多行语句（例如对象字面表达式)，则需要使用()包围函数体</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calcCircumference</span>(<span class=\"params\">diameter</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * diameter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">foo</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calcCircumference = <span class=\"function\"><span class=\"params\">diameter</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Math</span>.PI * diameter;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123; <span class=\"attr\">foo</span>: <span class=\"number\">1</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"默认参数值\"><a href=\"#默认参数值\" class=\"headerlink\" title=\"默认参数值\"></a>默认参数值</h2><p>为了给函数中参数传递默认值，通常使用 if 语句来编写，但是使用 es6 定义默认值，则会很简洁：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">valume</span>(<span class=\"params\">l, w, h</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (w === <span class=\"literal\">undefined</span>) w = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (h === <span class=\"literal\">undefined</span>) h = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l * w * h;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">volume = <span class=\"function\">(<span class=\"params\">l, w = <span class=\"number\">3</span>, h = <span class=\"number\">4</span></span>) =&gt;</span> l * w * h;</span><br><span class=\"line\">volume(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>传统的 JS 语言，输出模板通常是这样写的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> welcome = <span class=\"string\">\"you have logged in as\"</span> + first + <span class=\"string\">\"  \"</span> + last + <span class=\"string\">\".\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"string\">\"http://\"</span> + host + <span class=\"string\">\":\"</span> + port + <span class=\"string\">\"/\"</span> + database;</span><br></pre></td></tr></table></figure>\n<p>es6 可以使用反引号和\\${}简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> welcome = <span class=\"string\">`you have logged in as <span class=\"subst\">$&#123;first&#125;</span> <span class=\"subst\">$&#123;last&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"string\">`http://<span class=\"subst\">$&#123;host&#125;</span>/<span class=\"subst\">$&#123;database&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结构赋值简写方法\"><a href=\"#结构赋值简写方法\" class=\"headerlink\" title=\"结构赋值简写方法\"></a>结构赋值简写方法</h2><p>在 web 框架中，经常需要从组件和 API 之间来回传递数组或对象字面形式的数据，然后需要解构它</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> observable = <span class=\"built_in\">require</span>(<span class=\"string\">\"mobx/observable\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> action = <span class=\"built_in\">require</span>(<span class=\"string\">\"mobx/action\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> runInAction = <span class=\"built_in\">require</span>(<span class=\"string\">\"mobx/runInAction\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span>.props.store;</span><br><span class=\"line\"><span class=\"keyword\">const</span> form = <span class=\"keyword\">this</span>.props.form;</span><br><span class=\"line\"><span class=\"keyword\">const</span> loading = <span class=\"keyword\">this</span>.props.loading;</span><br><span class=\"line\"><span class=\"keyword\">const</span> errors = <span class=\"keyword\">this</span>.props.errors;</span><br><span class=\"line\"><span class=\"keyword\">const</span> entity = <span class=\"keyword\">this</span>.props.entity;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; observable, action, runInAction &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"mobx\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; store, form, loading, errors, entity &#125; = <span class=\"keyword\">this</span>.props;</span><br></pre></td></tr></table></figure>\n<p>也可以分配变量名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; store, form, loading, errors, <span class=\"attr\">entity</span>: contact &#125; = <span class=\"keyword\">this</span>.props;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多行字符串简写\"><a href=\"#多行字符串简写\" class=\"headerlink\" title=\"多行字符串简写\"></a>多行字符串简写</h2><p>需要输出多行字符串，需要使用+来拼接：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lorem =</span><br><span class=\"line\">  <span class=\"string\">\"Lorem ipsum dolor sit amet, consectetur\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"adipisicing elit, sed do eiusmod tempor incididunt\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"ut labore et dolore magna aliqua. Ut enim ad minim\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"veniam, quis nostrud exercitation ullamco laboris\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"nisi ut aliquip ex ea commodo consequat. Duis aute\\n\\t\"</span> +</span><br><span class=\"line\">  <span class=\"string\">\"irure dolor in reprehenderit in voluptate velit esse.\\n\\t\"</span>;</span><br></pre></td></tr></table></figure>\n<p>使用反引号，则可以达到简写作用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lorem = <span class=\"string\">`Lorem ipsum dolor sit amet, consectetur</span></span><br><span class=\"line\"><span class=\"string\">    adipisicing elit, sed do eiusmod tempor incididunt</span></span><br><span class=\"line\"><span class=\"string\">    ut labore et dolore magna aliqua. Ut enim ad minim</span></span><br><span class=\"line\"><span class=\"string\">    veniam, quis nostrud exercitation ullamco laboris</span></span><br><span class=\"line\"><span class=\"string\">    nisi ut aliquip ex ea commodo consequat. Duis aute</span></span><br><span class=\"line\"><span class=\"string\">    irure dolor in reprehenderit in voluptate velit esse.`</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"扩展运算符简写\"><a href=\"#扩展运算符简写\" class=\"headerlink\" title=\"扩展运算符简写\"></a>扩展运算符简写</h2><p>扩展运算符有几种用例让 JS 代码更加有效使用，可以用来代替某个数组函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//joining arrays</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> odd = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> nums = [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].concat(odd);</span><br><span class=\"line\"><span class=\"comment\">//cloning arrays</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = arr.slice();</span><br></pre></td></tr></table></figure>\n<p>简写:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// joining arrays</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> odd = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> nums = [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, ...odd];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nums); <span class=\"comment\">// [ 2, 4, 6, 1, 3, 5 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cloning arrays</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = [...arr];</span><br></pre></td></tr></table></figure>\n<p>不像 concat()函数，可以使用扩展运算符在一个数组中任意处插入另一个数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> odd = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> nums = [<span class=\"number\">2</span>, ...odd, <span class=\"number\">4</span>, <span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n<p>也可以使用扩展运算符解构</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; a, b, ...z &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">3</span>, <span class=\"attr\">d</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z); <span class=\"comment\">// &#123; c: 3, d: 4 &#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"强制参数简写\"><a href=\"#强制参数简写\" class=\"headerlink\" title=\"强制参数简写\"></a>强制参数简写</h2><p>JS 中如果没有向函数参数传递值，则参数为 undefined。为了增强参数赋值，可以使用 if 语句来抛出异常，或使用强制参数简写方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">bar</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bar === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Missing parameter!\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mandatory = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Missing parameter!\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo = <span class=\"function\">(<span class=\"params\">bar = mandatory(</span>)) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Array-find-简写\"><a href=\"#Array-find-简写\" class=\"headerlink\" title=\"Array.find 简写\"></a>Array.find 简写</h2><p>想从数组中查找某个值，则需要循环在 ES6 中，find()函数能实现同样效果</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pets = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"Dog\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"Max\"</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"Cat\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"Karl\"</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"Dog\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"Tommy\"</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findDog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; pets.length; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pets[i].type === <span class=\"string\">\"Dog\"</span> &amp;&amp; pets[i].name === name) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> pets[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = pets.find(<span class=\"function\"><span class=\"params\">pet</span> =&gt;</span> pet.type === <span class=\"string\">\"Dog\"</span> &amp;&amp; pet.name === <span class=\"string\">\"Tommy\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-key-简写\"><a href=\"#Object-key-简写\" class=\"headerlink\" title=\"Object[key]简写\"></a>Object[key]简写</h2><p>考虑一个验证函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">validate</span>(<span class=\"params\">values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!values.first) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!values.last) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(validate(&#123; <span class=\"attr\">first</span>: <span class=\"string\">\"Bruce\"</span>, <span class=\"attr\">last</span>: <span class=\"string\">\"Wayne\"</span> &#125;));</span><br></pre></td></tr></table></figure>\n<p>假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对象验证规则</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> schema = &#123;</span><br><span class=\"line\">  first: &#123;</span><br><span class=\"line\">    required: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  last: &#123;</span><br><span class=\"line\">    required: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通用验证函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> validate = <span class=\"function\">(<span class=\"params\">schema, values</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (field <span class=\"keyword\">in</span> schema) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (schema[field].required) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!values[field]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(validate(schema, &#123; <span class=\"attr\">first</span>: <span class=\"string\">\"Bruce\"</span> &#125;)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(validate(schema, &#123; <span class=\"attr\">first</span>: <span class=\"string\">\"Bruce\"</span>, <span class=\"attr\">last</span>: <span class=\"string\">\"Wayne\"</span> &#125;)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"双重非位运算简写\"><a href=\"#双重非位运算简写\" class=\"headerlink\" title=\"双重非位运算简写\"></a>双重非位运算简写</h2><p>有一个有效用于双重非运算操作符。可以用来代替 Math.floor()，其优势在于运行更快</p>\n<pre><code>Math.floor(4.9)===4\n</code></pre><p>简写</p>\n<pre><code>~~4.9===4\n</code></pre>"},{"title":"JavaScript 内存管理浅谈","date":"2018-06-22T03:24:57.000Z","_content":"\n最近一直在回溯自己的的前端知识体系，发现，工作一段时间后，再去回顾之前的知识，体会真的不一样。\n\n这次就简单了解一下 JavaScript 中的内存管理，涉及到了闭包，内存泄漏等前端常见问题。\n\n## 写在前面\n\nJavaScript 中的内存管理，给我的感觉可能一种偏科。我们平时可能不太重视，但是一旦出了问题，又会很棘手。其次，项目优化的时候也避免不了要踩坑。\n\n可以通过多了解一些内存管理问题，写代码的时候通过一些习惯，避免内存泄漏的问题。在项目 pr 流程中，也可以根据此给同事提供一些意见。\n\n## 内存生命周期\n\n![内存生命周期](https://static.skynian.cn/javascript-memory-management-201862211342.jpg)\n\n上图的流程是：\n\n1. 分配所需的内存\n2. 使用分配到的内存（读、写）\n3. 不需要时候释放/归还\n\n在 C 语言中，有专门的内存管理接口，像 malloc() 和 free()，而在 JS 中有着一个自动的垃圾回收机制。\n\n## JavaScript 中的内存回收 (GC:Garbage Collecation)\n\n### \b 引用计数垃圾收集\n\n引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 。相反，如果包含 \b 对这个值的变量又取得了另外一个值，则这个值的引用册数就减 1 。\n\n当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。\n\n但是这个是存在问题的：\n\neg：\n\n```js\nfunction problem() {\n  let objA = new Object();\n  let objB = new Object();\n\n  objA.someOtherObject = objB;\n  objb.anotherObject = objA;\n}\n```\n\n在这个例子中，objA 和 objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。\n\n我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以 COM（Component Object\nModel，组件对象）对象的形式实现的，而 COM 对象的垃圾回收器就是采用的引用计数的策略。因此，即使 IE 的 Javascript 引擎使用标记清除的策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数的策略的。说白了，只要 IE 中涉及 COM 对象，就会存在循环引用的问题。看看下面的这个简单的例子：\n\n```js\nlet element = document.getElementById(\"some_element\");\nlet myObj = new Object();\n\nmyObj.element = element;\nelement.someObject = myObj;\n```\n\n上面这个例子中，在一个 DOM 元素 (element) 与一个原生 JavaScript 对象(myObj)之间建立了循环引用。其中，变量 myObj 有一个名为 element 的属性指向 element ；而变量 element 有一个名为 someObject 的属性回指到 myObj。由于循环引用，即使将例子中的 DOM 从页面中移除，内存也永远不会回收。\n\n不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。\n\n```js\nmyObj.element = null;\nelement.someObject = null;\n```\n\nIE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收. 该方式常常造成对象被循环引用时内存发生泄漏. 现代浏览器通过使用标记-清除内存回收算法, 来解决这一问题。\n\n### 标记-清除算法\n\n这个算法把\"对象是否不再需要\"简化定义为\"对象是否可以获得\"。这个算法假定设置一个叫做根 root 的对象（在 Javascript 里，根是全局对象。定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。\n\n从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进。\n\n到目前为止，IE、Firefox、Opera、Chrome、Safari 的 js 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。\n\n![标记-清除算法](https://static.skynian.cn/javascript-memory-management-20186221499.jpg)\n\n## 自动 GC 的问题\n\n尽管自动 GC 很方便, 但是我们不知道 GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收。\n\n## 常见的内存泄露案例\n\n### 全局变量\n\n```js\nfunction foo(arg) {\n  bar = \"some text\";\n}\n```\n\n在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar , 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.\n\n所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕. 另外一种意外创建全局变量的情况。\n\n```js\nfunction foo() {\n  this.var1 = \"potential accidental global\";\n}\n\n// Foo 被调用时, this 指向全局变量(window)\nfoo();\n```\n\n在这种情况下调用 foo, this 被指向了全局变量 window, 意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量.\n\n如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.\n\n### 未销毁的定时器和回调函数\n\n在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval 的例子.\n\n```js\nlet serverData = loadData();\n\nsetInterval(function() {\n  let renderer = document.getElementById(\"renderer\");\n  if (renderer) {\n    renderer.innerHTML = JSON.stringify(serverData);\n  }\n}, 5000); // 每 5 秒调用一次\n```\n\n如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.\n\n## 闭包\n\n在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.\n\n```js\nlet theThing = null;\nlet replaceThing = function() {\n  let originalThing = theThing;\n  let unused = function() {\n    if (originalThing)\n      // 对于 'originalThing'的引用\n      console.log(\"hi\");\n  };\n  theThing = {\n    longStr: new Array(1000000).join(\"*\"),\n    someMethod: function() {\n      console.log(\"message\");\n    }\n  };\n};\n\nsetInterval(replaceThing, 1000);\n```\n\n这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象. 同时 unused 是一个引用了 originalThing 的闭包.\n\n这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是 someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长. 该问题的更多描述可见[Meteor 团队的这篇文章](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=a92ddcd69bbf)\b。\n\n### DOM 引用\n\n很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.\n\n```js\nlet elements = {\n  image: document.getElementById(\"image\")\n};\nfunction doStuff() {\n  elements.image.src = \"http://example.com/image_name.png\";\n}\nfunction removeImage() {\n  document.body.removeChild(document.getElementById(\"image\"));\n  // 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.\n}\n```\n\n上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.\n\n另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.\n\n### ES6\n\nES6 中引入 WeakSet 和 WeakMap 两个新的概念, 来解决引用造成的内存回收问题. WeakSet 和 WeakMap 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.\n\n## 总结\n\n在 Javascript 中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。\n\n但是，为了减少内存垃圾，我们还是可以对 Javascript 代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。\n\n我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的 Javascript 应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。\n\n## 参考\n\n[Barret Lee JavaScript 垃圾回收机制](http://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html)\n\n[阮一峰 JavaScript 内存泄漏教程](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)\n","source":"_posts/javascript-memory-management.md","raw":"---\ntitle: JavaScript 内存管理浅谈\ndate: 2018-06-22 11:24:57\ntags:\n  - JavaScript\n  - 优化\ncategories: JavaScript\n---\n\n最近一直在回溯自己的的前端知识体系，发现，工作一段时间后，再去回顾之前的知识，体会真的不一样。\n\n这次就简单了解一下 JavaScript 中的内存管理，涉及到了闭包，内存泄漏等前端常见问题。\n\n## 写在前面\n\nJavaScript 中的内存管理，给我的感觉可能一种偏科。我们平时可能不太重视，但是一旦出了问题，又会很棘手。其次，项目优化的时候也避免不了要踩坑。\n\n可以通过多了解一些内存管理问题，写代码的时候通过一些习惯，避免内存泄漏的问题。在项目 pr 流程中，也可以根据此给同事提供一些意见。\n\n## 内存生命周期\n\n![内存生命周期](https://static.skynian.cn/javascript-memory-management-201862211342.jpg)\n\n上图的流程是：\n\n1. 分配所需的内存\n2. 使用分配到的内存（读、写）\n3. 不需要时候释放/归还\n\n在 C 语言中，有专门的内存管理接口，像 malloc() 和 free()，而在 JS 中有着一个自动的垃圾回收机制。\n\n## JavaScript 中的内存回收 (GC:Garbage Collecation)\n\n### \b 引用计数垃圾收集\n\n引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 。相反，如果包含 \b 对这个值的变量又取得了另外一个值，则这个值的引用册数就减 1 。\n\n当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。\n\n但是这个是存在问题的：\n\neg：\n\n```js\nfunction problem() {\n  let objA = new Object();\n  let objB = new Object();\n\n  objA.someOtherObject = objB;\n  objb.anotherObject = objA;\n}\n```\n\n在这个例子中，objA 和 objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。\n\n我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以 COM（Component Object\nModel，组件对象）对象的形式实现的，而 COM 对象的垃圾回收器就是采用的引用计数的策略。因此，即使 IE 的 Javascript 引擎使用标记清除的策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数的策略的。说白了，只要 IE 中涉及 COM 对象，就会存在循环引用的问题。看看下面的这个简单的例子：\n\n```js\nlet element = document.getElementById(\"some_element\");\nlet myObj = new Object();\n\nmyObj.element = element;\nelement.someObject = myObj;\n```\n\n上面这个例子中，在一个 DOM 元素 (element) 与一个原生 JavaScript 对象(myObj)之间建立了循环引用。其中，变量 myObj 有一个名为 element 的属性指向 element ；而变量 element 有一个名为 someObject 的属性回指到 myObj。由于循环引用，即使将例子中的 DOM 从页面中移除，内存也永远不会回收。\n\n不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。\n\n```js\nmyObj.element = null;\nelement.someObject = null;\n```\n\nIE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收. 该方式常常造成对象被循环引用时内存发生泄漏. 现代浏览器通过使用标记-清除内存回收算法, 来解决这一问题。\n\n### 标记-清除算法\n\n这个算法把\"对象是否不再需要\"简化定义为\"对象是否可以获得\"。这个算法假定设置一个叫做根 root 的对象（在 Javascript 里，根是全局对象。定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。\n\n从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进。\n\n到目前为止，IE、Firefox、Opera、Chrome、Safari 的 js 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。\n\n![标记-清除算法](https://static.skynian.cn/javascript-memory-management-20186221499.jpg)\n\n## 自动 GC 的问题\n\n尽管自动 GC 很方便, 但是我们不知道 GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收。\n\n## 常见的内存泄露案例\n\n### 全局变量\n\n```js\nfunction foo(arg) {\n  bar = \"some text\";\n}\n```\n\n在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar , 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.\n\n所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕. 另外一种意外创建全局变量的情况。\n\n```js\nfunction foo() {\n  this.var1 = \"potential accidental global\";\n}\n\n// Foo 被调用时, this 指向全局变量(window)\nfoo();\n```\n\n在这种情况下调用 foo, this 被指向了全局变量 window, 意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量.\n\n如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.\n\n### 未销毁的定时器和回调函数\n\n在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval 的例子.\n\n```js\nlet serverData = loadData();\n\nsetInterval(function() {\n  let renderer = document.getElementById(\"renderer\");\n  if (renderer) {\n    renderer.innerHTML = JSON.stringify(serverData);\n  }\n}, 5000); // 每 5 秒调用一次\n```\n\n如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.\n\n## 闭包\n\n在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.\n\n```js\nlet theThing = null;\nlet replaceThing = function() {\n  let originalThing = theThing;\n  let unused = function() {\n    if (originalThing)\n      // 对于 'originalThing'的引用\n      console.log(\"hi\");\n  };\n  theThing = {\n    longStr: new Array(1000000).join(\"*\"),\n    someMethod: function() {\n      console.log(\"message\");\n    }\n  };\n};\n\nsetInterval(replaceThing, 1000);\n```\n\n这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象. 同时 unused 是一个引用了 originalThing 的闭包.\n\n这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是 someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长. 该问题的更多描述可见[Meteor 团队的这篇文章](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=a92ddcd69bbf)\b。\n\n### DOM 引用\n\n很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.\n\n```js\nlet elements = {\n  image: document.getElementById(\"image\")\n};\nfunction doStuff() {\n  elements.image.src = \"http://example.com/image_name.png\";\n}\nfunction removeImage() {\n  document.body.removeChild(document.getElementById(\"image\"));\n  // 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.\n}\n```\n\n上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.\n\n另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.\n\n### ES6\n\nES6 中引入 WeakSet 和 WeakMap 两个新的概念, 来解决引用造成的内存回收问题. WeakSet 和 WeakMap 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.\n\n## 总结\n\n在 Javascript 中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。\n\n但是，为了减少内存垃圾，我们还是可以对 Javascript 代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。\n\n我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的 Javascript 应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。\n\n## 参考\n\n[Barret Lee JavaScript 垃圾回收机制](http://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html)\n\n[阮一峰 JavaScript 内存泄漏教程](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)\n","slug":"javascript-memory-management","published":1,"updated":"2018-12-25T07:25:33.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2jba001egzq2q28zfobq","content":"<p>最近一直在回溯自己的的前端知识体系，发现，工作一段时间后，再去回顾之前的知识，体会真的不一样。</p>\n<p>这次就简单了解一下 JavaScript 中的内存管理，涉及到了闭包，内存泄漏等前端常见问题。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>JavaScript 中的内存管理，给我的感觉可能一种偏科。我们平时可能不太重视，但是一旦出了问题，又会很棘手。其次，项目优化的时候也避免不了要踩坑。</p>\n<p>可以通过多了解一些内存管理问题，写代码的时候通过一些习惯，避免内存泄漏的问题。在项目 pr 流程中，也可以根据此给同事提供一些意见。</p>\n<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h2><p><img src=\"https://static.skynian.cn/javascript-memory-management-201862211342.jpg\" alt=\"内存生命周期\"></p>\n<p>上图的流程是：</p>\n<ol>\n<li>分配所需的内存</li>\n<li>使用分配到的内存（读、写）</li>\n<li>不需要时候释放/归还</li>\n</ol>\n<p>在 C 语言中，有专门的内存管理接口，像 malloc() 和 free()，而在 JS 中有着一个自动的垃圾回收机制。</p>\n<h2 id=\"JavaScript-中的内存回收-GC-Garbage-Collecation\"><a href=\"#JavaScript-中的内存回收-GC-Garbage-Collecation\" class=\"headerlink\" title=\"JavaScript 中的内存回收 (GC:Garbage Collecation)\"></a>JavaScript 中的内存回收 (GC:Garbage Collecation)</h2><h3 id=\"引用计数垃圾收集\"><a href=\"#引用计数垃圾收集\" class=\"headerlink\" title=\"\b 引用计数垃圾收集\"></a>\b 引用计数垃圾收集</h3><p>引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 。相反，如果包含 \b 对这个值的变量又取得了另外一个值，则这个值的引用册数就减 1 。</p>\n<p>当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。</p>\n<p>但是这个是存在问题的：</p>\n<p>eg：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">problem</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objA = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objB = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  objA.someOtherObject = objB;</span><br><span class=\"line\">  objb.anotherObject = objA;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，objA 和 objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p>\n<p>我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以 COM（Component Object<br>Model，组件对象）对象的形式实现的，而 COM 对象的垃圾回收器就是采用的引用计数的策略。因此，即使 IE 的 Javascript 引擎使用标记清除的策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数的策略的。说白了，只要 IE 中涉及 COM 对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"some_element\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.element = element;</span><br><span class=\"line\">element.someObject = myObj;</span><br></pre></td></tr></table></figure>\n<p>上面这个例子中，在一个 DOM 元素 (element) 与一个原生 JavaScript 对象(myObj)之间建立了循环引用。其中，变量 myObj 有一个名为 element 的属性指向 element ；而变量 element 有一个名为 someObject 的属性回指到 myObj。由于循环引用，即使将例子中的 DOM 从页面中移除，内存也永远不会回收。</p>\n<p>不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObj.element = <span class=\"literal\">null</span>;</span><br><span class=\"line\">element.someObject = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收. 该方式常常造成对象被循环引用时内存发生泄漏. 现代浏览器通过使用标记-清除内存回收算法, 来解决这一问题。</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>这个算法把”对象是否不再需要”简化定义为”对象是否可以获得”。这个算法假定设置一个叫做根 root 的对象（在 Javascript 里，根是全局对象。定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>\n<p>从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进。</p>\n<p>到目前为止，IE、Firefox、Opera、Chrome、Safari 的 js 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>\n<p><img src=\"https://static.skynian.cn/javascript-memory-management-20186221499.jpg\" alt=\"标记-清除算法\"></p>\n<h2 id=\"自动-GC-的问题\"><a href=\"#自动-GC-的问题\" class=\"headerlink\" title=\"自动 GC 的问题\"></a>自动 GC 的问题</h2><p>尽管自动 GC 很方便, 但是我们不知道 GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收。</p>\n<h2 id=\"常见的内存泄露案例\"><a href=\"#常见的内存泄露案例\" class=\"headerlink\" title=\"常见的内存泄露案例\"></a>常见的内存泄露案例</h2><h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  bar = <span class=\"string\">\"some text\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar , 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.</p>\n<p>所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕. 另外一种意外创建全局变量的情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.var1 = <span class=\"string\">\"potential accidental global\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foo 被调用时, this 指向全局变量(window)</span></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>在这种情况下调用 foo, this 被指向了全局变量 window, 意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量.</p>\n<p>如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.</p>\n<h3 id=\"未销毁的定时器和回调函数\"><a href=\"#未销毁的定时器和回调函数\" class=\"headerlink\" title=\"未销毁的定时器和回调函数\"></a>未销毁的定时器和回调函数</h3><p>在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval 的例子.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> serverData = loadData();</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> renderer = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"renderer\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (renderer) &#123;</span><br><span class=\"line\">    renderer.innerHTML = <span class=\"built_in\">JSON</span>.stringify(serverData);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>); <span class=\"comment\">// 每 5 秒调用一次</span></span><br></pre></td></tr></table></figure>\n<p>如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> theThing = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> replaceThing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> originalThing = theThing;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> unused = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (originalThing)</span><br><span class=\"line\">      <span class=\"comment\">// 对于 'originalThing'的引用</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>).join(<span class=\"string\">\"*\"</span>),</span><br><span class=\"line\">    someMethod: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"message\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象. 同时 unused 是一个引用了 originalThing 的闭包.</p>\n<p>这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是 someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长. 该问题的更多描述可见<a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=a92ddcd69bbf\" target=\"_blank\" rel=\"noopener\">Meteor 团队的这篇文章</a>\b。</p>\n<h3 id=\"DOM-引用\"><a href=\"#DOM-引用\" class=\"headerlink\" title=\"DOM 引用\"></a>DOM 引用</h3><p>很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> elements = &#123;</span><br><span class=\"line\">  image: <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"image\"</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doStuff</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  elements.image.src = <span class=\"string\">\"http://example.com/image_name.png\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeImage</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.removeChild(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"image\"</span>));</span><br><span class=\"line\">  <span class=\"comment\">// 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.</p>\n<p>另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.</p>\n<h3 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h3><p>ES6 中引入 WeakSet 和 WeakMap 两个新的概念, 来解决引用造成的内存回收问题. WeakSet 和 WeakMap 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在 Javascript 中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。</p>\n<p>但是，为了减少内存垃圾，我们还是可以对 Javascript 代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。</p>\n<p>我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的 Javascript 应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html\" target=\"_blank\" rel=\"noopener\">Barret Lee JavaScript 垃圾回收机制</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\" target=\"_blank\" rel=\"noopener\">阮一峰 JavaScript 内存泄漏教程</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>最近一直在回溯自己的的前端知识体系，发现，工作一段时间后，再去回顾之前的知识，体会真的不一样。</p>\n<p>这次就简单了解一下 JavaScript 中的内存管理，涉及到了闭包，内存泄漏等前端常见问题。</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>JavaScript 中的内存管理，给我的感觉可能一种偏科。我们平时可能不太重视，但是一旦出了问题，又会很棘手。其次，项目优化的时候也避免不了要踩坑。</p>\n<p>可以通过多了解一些内存管理问题，写代码的时候通过一些习惯，避免内存泄漏的问题。在项目 pr 流程中，也可以根据此给同事提供一些意见。</p>\n<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h2><p><img src=\"https://static.skynian.cn/javascript-memory-management-201862211342.jpg\" alt=\"内存生命周期\"></p>\n<p>上图的流程是：</p>\n<ol>\n<li>分配所需的内存</li>\n<li>使用分配到的内存（读、写）</li>\n<li>不需要时候释放/归还</li>\n</ol>\n<p>在 C 语言中，有专门的内存管理接口，像 malloc() 和 free()，而在 JS 中有着一个自动的垃圾回收机制。</p>\n<h2 id=\"JavaScript-中的内存回收-GC-Garbage-Collecation\"><a href=\"#JavaScript-中的内存回收-GC-Garbage-Collecation\" class=\"headerlink\" title=\"JavaScript 中的内存回收 (GC:Garbage Collecation)\"></a>JavaScript 中的内存回收 (GC:Garbage Collecation)</h2><h3 id=\"引用计数垃圾收集\"><a href=\"#引用计数垃圾收集\" class=\"headerlink\" title=\"\b 引用计数垃圾收集\"></a>\b 引用计数垃圾收集</h3><p>引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1 。相反，如果包含 \b 对这个值的变量又取得了另外一个值，则这个值的引用册数就减 1 。</p>\n<p>当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。</p>\n<p>但是这个是存在问题的：</p>\n<p>eg：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">problem</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objA = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objB = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  objA.someOtherObject = objB;</span><br><span class=\"line\">  objb.anotherObject = objA;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，objA 和 objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p>\n<p>我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以 COM（Component Object<br>Model，组件对象）对象的形式实现的，而 COM 对象的垃圾回收器就是采用的引用计数的策略。因此，即使 IE 的 Javascript 引擎使用标记清除的策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数的策略的。说白了，只要 IE 中涉及 COM 对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"some_element\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.element = element;</span><br><span class=\"line\">element.someObject = myObj;</span><br></pre></td></tr></table></figure>\n<p>上面这个例子中，在一个 DOM 元素 (element) 与一个原生 JavaScript 对象(myObj)之间建立了循环引用。其中，变量 myObj 有一个名为 element 的属性指向 element ；而变量 element 有一个名为 someObject 的属性回指到 myObj。由于循环引用，即使将例子中的 DOM 从页面中移除，内存也永远不会回收。</p>\n<p>不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObj.element = <span class=\"literal\">null</span>;</span><br><span class=\"line\">element.someObject = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收. 该方式常常造成对象被循环引用时内存发生泄漏. 现代浏览器通过使用标记-清除内存回收算法, 来解决这一问题。</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>这个算法把”对象是否不再需要”简化定义为”对象是否可以获得”。这个算法假定设置一个叫做根 root 的对象（在 Javascript 里，根是全局对象。定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>\n<p>从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进。</p>\n<p>到目前为止，IE、Firefox、Opera、Chrome、Safari 的 js 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>\n<p><img src=\"https://static.skynian.cn/javascript-memory-management-20186221499.jpg\" alt=\"标记-清除算法\"></p>\n<h2 id=\"自动-GC-的问题\"><a href=\"#自动-GC-的问题\" class=\"headerlink\" title=\"自动 GC 的问题\"></a>自动 GC 的问题</h2><p>尽管自动 GC 很方便, 但是我们不知道 GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收。</p>\n<h2 id=\"常见的内存泄露案例\"><a href=\"#常见的内存泄露案例\" class=\"headerlink\" title=\"常见的内存泄露案例\"></a>常见的内存泄露案例</h2><h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  bar = <span class=\"string\">\"some text\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar , 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.</p>\n<p>所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕. 另外一种意外创建全局变量的情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.var1 = <span class=\"string\">\"potential accidental global\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foo 被调用时, this 指向全局变量(window)</span></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>在这种情况下调用 foo, this 被指向了全局变量 window, 意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量.</p>\n<p>如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.</p>\n<h3 id=\"未销毁的定时器和回调函数\"><a href=\"#未销毁的定时器和回调函数\" class=\"headerlink\" title=\"未销毁的定时器和回调函数\"></a>未销毁的定时器和回调函数</h3><p>在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval 的例子.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> serverData = loadData();</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> renderer = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"renderer\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (renderer) &#123;</span><br><span class=\"line\">    renderer.innerHTML = <span class=\"built_in\">JSON</span>.stringify(serverData);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>); <span class=\"comment\">// 每 5 秒调用一次</span></span><br></pre></td></tr></table></figure>\n<p>如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> theThing = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> replaceThing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> originalThing = theThing;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> unused = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (originalThing)</span><br><span class=\"line\">      <span class=\"comment\">// 对于 'originalThing'的引用</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>).join(<span class=\"string\">\"*\"</span>),</span><br><span class=\"line\">    someMethod: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"message\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象. 同时 unused 是一个引用了 originalThing 的闭包.</p>\n<p>这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是 someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长. 该问题的更多描述可见<a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=a92ddcd69bbf\" target=\"_blank\" rel=\"noopener\">Meteor 团队的这篇文章</a>\b。</p>\n<h3 id=\"DOM-引用\"><a href=\"#DOM-引用\" class=\"headerlink\" title=\"DOM 引用\"></a>DOM 引用</h3><p>很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> elements = &#123;</span><br><span class=\"line\">  image: <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"image\"</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doStuff</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  elements.image.src = <span class=\"string\">\"http://example.com/image_name.png\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeImage</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.removeChild(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"image\"</span>));</span><br><span class=\"line\">  <span class=\"comment\">// 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.</p>\n<p>另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.</p>\n<h3 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h3><p>ES6 中引入 WeakSet 和 WeakMap 两个新的概念, 来解决引用造成的内存回收问题. WeakSet 和 WeakMap 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在 Javascript 中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。</p>\n<p>但是，为了减少内存垃圾，我们还是可以对 Javascript 代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。</p>\n<p>我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的 Javascript 应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html\" target=\"_blank\" rel=\"noopener\">Barret Lee JavaScript 垃圾回收机制</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\" target=\"_blank\" rel=\"noopener\">阮一峰 JavaScript 内存泄漏教程</a></p>\n"},{"layout":"css3","title":"实现半像素边框","date":"2018-12-17T08:43:04.000Z","_content":"\n## 思路\n\n普通的 1px 黑色实线边框\n\n```css\n.border {\n  border: 1px solid #000;\n}\n```\n\n半像素边框当然不是简单地把 1px 改为 0.5px（没测试过，可能会被解析成 1 或者 0），border-width 的值只能是自然数\n\n类似的，outline, box-shadow 等等也没有办法画出 0.5px 的细线\n\n常规思路是不可行的，我们可以用伪元素 + 缩放巧妙地实现，具体步骤如下：\n\n- 设置目标元素作为定位参照\n\n```css\n.thinner-border {\n  position: relative;\n}\n```\n\n- 给目标元素添加一个伪元素 before 或者 after，并设置绝对定位\n\n```css\n.thinner-border:before {\n  content: \"\";\n  position: absolute;\n}\n```\n\n- 给伪元素添上 1px 的边框\n\n```css\n.thinner-border:before {\n  border: 1px solid red;\n}\n```\n\n- 设置伪元素的宽高为目标元素的 2 倍\n\n```css\n.thinner-border:before {\n  width: 200%;\n  height: 200%;\n}\n```\n\n- 缩小 0.5 倍（变回目标元素的大小）\n\n```css\n.thinner-border:before {\n  transform-origin: 0 0;\n  transform: scale(0.5, 0.5);\n}\n```\n\n- 把 border 包进来\n\n```css\n.thinner-border:before {\n  box-sizing: border-box;\n}\n```\n\n简言之就是先放大再缩回来，border-box 是关键，否则边框不会一起缩放\n","source":"_posts/实现半像素边框.md","raw":"---\nlayout: css3\ntitle: 实现半像素边框\ndate: 2018-12-17 16:43:04\ntags:\n  - 布局\n  - CSS\ncategories: 布局\n---\n\n## 思路\n\n普通的 1px 黑色实线边框\n\n```css\n.border {\n  border: 1px solid #000;\n}\n```\n\n半像素边框当然不是简单地把 1px 改为 0.5px（没测试过，可能会被解析成 1 或者 0），border-width 的值只能是自然数\n\n类似的，outline, box-shadow 等等也没有办法画出 0.5px 的细线\n\n常规思路是不可行的，我们可以用伪元素 + 缩放巧妙地实现，具体步骤如下：\n\n- 设置目标元素作为定位参照\n\n```css\n.thinner-border {\n  position: relative;\n}\n```\n\n- 给目标元素添加一个伪元素 before 或者 after，并设置绝对定位\n\n```css\n.thinner-border:before {\n  content: \"\";\n  position: absolute;\n}\n```\n\n- 给伪元素添上 1px 的边框\n\n```css\n.thinner-border:before {\n  border: 1px solid red;\n}\n```\n\n- 设置伪元素的宽高为目标元素的 2 倍\n\n```css\n.thinner-border:before {\n  width: 200%;\n  height: 200%;\n}\n```\n\n- 缩小 0.5 倍（变回目标元素的大小）\n\n```css\n.thinner-border:before {\n  transform-origin: 0 0;\n  transform: scale(0.5, 0.5);\n}\n```\n\n- 把 border 包进来\n\n```css\n.thinner-border:before {\n  box-sizing: border-box;\n}\n```\n\n简言之就是先放大再缩回来，border-box 是关键，否则边框不会一起缩放\n","slug":"实现半像素边框","published":1,"updated":"2018-12-17T08:51:42.985Z","comments":1,"photos":[],"link":"","_id":"cjq3g2jbc001hgzq2a5vaard0","content":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>普通的 1px 黑色实线边框</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>半像素边框当然不是简单地把 1px 改为 0.5px（没测试过，可能会被解析成 1 或者 0），border-width 的值只能是自然数</p>\n<p>类似的，outline, box-shadow 等等也没有办法画出 0.5px 的细线</p>\n<p>常规思路是不可行的，我们可以用伪元素 + 缩放巧妙地实现，具体步骤如下：</p>\n<ul>\n<li>设置目标元素作为定位参照</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>给目标元素添加一个伪元素 before 或者 after，并设置绝对定位</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>给伪元素添上 1px 的边框</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置伪元素的宽高为目标元素的 2 倍</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>缩小 0.5 倍（变回目标元素的大小）</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0.5, 0.5);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>把 border 包进来</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简言之就是先放大再缩回来，border-box 是关键，否则边框不会一起缩放</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>普通的 1px 黑色实线边框</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>半像素边框当然不是简单地把 1px 改为 0.5px（没测试过，可能会被解析成 1 或者 0），border-width 的值只能是自然数</p>\n<p>类似的，outline, box-shadow 等等也没有办法画出 0.5px 的细线</p>\n<p>常规思路是不可行的，我们可以用伪元素 + 缩放巧妙地实现，具体步骤如下：</p>\n<ul>\n<li>设置目标元素作为定位参照</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>给目标元素添加一个伪元素 before 或者 after，并设置绝对定位</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>给伪元素添上 1px 的边框</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置伪元素的宽高为目标元素的 2 倍</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>缩小 0.5 倍（变回目标元素的大小）</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0.5, 0.5);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>把 border 包进来</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.thinner-border</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简言之就是先放大再缩回来，border-box 是关键，否则边框不会一起缩放</p>\n"},{"title":"浅谈 Web Components","date":"2018-07-19T03:26:10.000Z","_content":"\n![](https://static.skynian.cn/18-7-21/31724707.jpg)\n\nWeb Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。\n\n<!--more-->\n\n## 一个有趣的 UI 库\n\n某天，逛逛论坛的时候，发现了一个很有趣手绘风格的 U 组件库。当然重点在于它是基于 Web Components 的实现。\n\n因为在此之前，对 Web Components 没有更多了解，这次趁着这次机会简单总结了一下这方面的知识。\n\n虽然说，目前没看到这套技术大规模使用，但随着越来越多的浏览器对 Web Components 的支持，是否会从底层改变诸如 Vue 和 React 组件化方案的实现方式呢？\n\n[https://github.com/wiredjs/wired-elements](https://github.com/wiredjs/wired-elements)\n\n![image](https://static.skynian.cn/18-7-19/73652975.jpg)\n\n## What ?\n\nWeb Components are a new browser feature that provides a standard component model for the Web, consisting of several pieces: Shadow DOM, Custom Elements, HTML Imports and HTML Templates.\n\n摘自 [https://github.com/w3c/webcomponents](https://github.com/w3c/webcomponents)\n\n也就是说，Web Components 是 Web 组件模型标准，由浏览器提供原生特性支持，包括 Shadow DOM，Custom Elements，HTML Imports 和 HTML Templates\n\n## 涉及规范\n\n- `Custom elements（自定义元素）`：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。\n  [https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements)\n- `Shadow DOM（影子DOM）`：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\n- `HTML templates（HTML模板）`：`<template>` 和 `<slot>` 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\n- `HTML Imports（HTML导入）`：一旦定义了自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。HTML 导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的。\n\n## 实现重点\n\n```html\n// 从 video 说起，效果类似于 //\n含有该片段的HTML页面将呈现一个功能完整的视频播放器，带播放按钮，进度条，音量调节按钮等等\n\n<video src=\"./video.mp4\" controls></video>\n\n<input type=\"text\" value=\"test\" placeholder=\"placeholder\" />\n```\n\n- 核心是 组件封装\n- video、input 相当于浏览器的内置组件，组件视图结构及默认样式藏在 Shadow DOM 里，组件逻辑被彻底藏了起来，仅暴露出 autoplay，oninput 等状态 / 行为 Hook 与外界通信\n\n![](https://static.skynian.cn/18-7-21/60213309.jpg)\n\n## Shadom DOM\n\n1. 利用浏览器提供的 Shadow DOM 特性，我们可以创建自己的 Shadow Root：\n\n```js\ndocument.body.innerHTML = '<div class=\"container\"></div>';\n\nlet host = document.querySelector(\".container\");\nlet root = host.createShadowRoot();\n\nroot.innerHTML = \"<p>How <em>you</em> doin?</p>\";\n```\n\n2. 此时的节点结构是：\n\n```html\n<div class=\"container\">\n  #shadow-root (open)\n  <p>How <em>you</em> doin?</p>\n</div>\n```\n\n3. 可以对 Fragment 做 DOM 操作，相当于一个独立的 HTML 解析环境，不受外界干扰\n\nShadow DOM 这款工具旨在构建基于组件的应用。因此，可为网络开发中的常见问题提供解决方案：\n\n- `隔离 DOM`：组件的 DOM 是独立的（例如，document.querySelector() 不会返回组件 shadow DOM 中的节点）。\n- `作用域 CSS`：shadow DOM 内部定义的 CSS 在其作用域内。样式规则不会泄漏，页面样式也不会渗入。\n- `组合`：为组件设计一个声明性、基于标记的 API。\n- `简化 CSS` - 作用域 DOM 意味着您可以使用简单的 CSS 选择器，更通用的 id/类名称，而无需担心命名冲突。\n- `效率` - 将应用看成是多个 DOM 块，而不是一个大的（全局性）页面。\n\n## 事件的封装\n\nShadow Dom 对于事件通过在冒泡阶段 target 的重定向来封装事件，然后一些可能对页面造成影响的事件，Shadow Dom 就会影藏掉这些事件，也就是在冒泡到主页面的过程中被挡住了。\n\n![](https://static.skynian.cn/18-7-21/1188753.jpg)\n\n## 创建流程\n\n1. 使用 `ECMAScript 2015` 类语法创建一个类，来指定 web 组件的功能使用\n2. `CustomElementRegistry.define()` 方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类以及可选的，其所继承自的元素。\n3. 使用 `Element.attachShadow()`方法将一个 shadow DOM 附加到自定义元素上。使用通常的 DOM 方法向 shadow DOM 中添加子元素、事件监听器等等。\n4. 使用 `<template>` 和 `<slot>` 方法定义一个 HTML 模板。再次使用常规 DOM 方法克隆模板并将其附加到您的 shadow DOM 中。\n\n例子：[https://github.com/mdn/web-components-examples](https://github.com/mdn/web-components-examples)\n\n## 兼容性\n\n![](https://static.skynian.cn/18-7-21/78737181.jpg)\n\n## 常见封装类库\n\n- `Polymer`: Google 推出的 web 组件库，支持数据的单向和双向绑定，兼容性较好，跨浏览器性能也较好；\n- `X-Tag`: 微软推出的开源库，支持 Web Components 规范，兼容 Web ComponentsAPI；\n- `Slim.js`: 轻量级的 web 组件库，专注于帮助开发者更好的编写原生 web 组件，而不依赖于其他框架，但是也提供了良好的拓展性，开发者可以自由拓展。\n\n## Polymer 3.0\n\nPolymer 能提供的特性\n\n- `自定义元素`。注册元素将类与自定义元素名称相关联。该元素提供回调以管理其生命周期。 Polymer 还可以让您声明属物，将元素的属物 API 与 Polymer 数据系统集成。\n- `阴影 DOM`。阴影 DOM 为您的元素提供了本地封装的 DOM 树。Polymer 可以自动用 DOM 模板为您的元素创建和填充阴影树。\n- `事件`。Polymer 提供了一个用于将事件监听器附加到阴影 DOM 子节点的声明性语法。它还提供了一个用于处理手势事件的可选库。\n- `数据系统`。Polymer 数据系统提供与属物和属性的数据绑定; 属物观察者，和被计算的属物。\n\n## What's new in 3.0\n\n- 在 Google I/O 2018 大会上，Google 推出了 Polymer 3.0\n\n- Web 组件的生态系统从 HTML Imports 转移到 ES Modules。\n\n- 包管理系统将支持 npm，更容易将基于 Polymer 的 web 组件和各种工具、框架协同使用。\n\n[https://www.polymer-project.org/3.0/start/quick-tour](使用例子)\n\n## Vue 与 Web Components\n\n- Vue 在实现上遵从了部分 Web Components 规范，比如 Shadow DOM 里的 slot：\n\n[https://cn.vuejs.org/v2/guide/components-slots.html](https://cn.vuejs.org/v2/guide/components-slots.html)\n\n- 因为 Web Components 规范尚不成熟，且支持性并不乐观，不用 polyfill 就无法投入生产，Vue 依靠构建工具跨过了环境兼容性问题，不依赖浏览器特性支持，但同时也就舍弃了 Shadow DOM 封装性等 Web Components 核心优势\n- 另外，Web Components 是相对底层的组件规范，Vue 除了定义组件规范，还提供了组件通信，数据绑定等上层方案\n\n## React 与 Web Components\n\nReact 和 web 组件 被用以解决不同问题。\n\nWeb 组件为可重用组件提供了强大的封装能力，而 React 则是提供了保持 DOM 和数据同步的声明式库。二者目标互补。\n\n可以在 Web 组件里使用 React，或者在 React 里使用 Web Components。\n\n[https://reactjs.org/docs/web-components.html](https://reactjs.org/docs/web-components.html)\n\n## Angular 与 Web Components\n\nAngular 默认情况下没有使用 Web Components 的任何基础设施\n\n不过这里有一个选项问题，就是 Angular 可以设置不同的 ViewEncapsulation，如果是 Native，那会使用到 Shadow DOM 的 API；如果是默认的 Emulated，就不会用到。\n\n[https://angular.io/api/core/ViewEncapsulation](https://angular.io/api/core/ViewEncapsulation)\n\n## 总结\n\nWeb 「相关」规范设计中一般有一些基本的共识：\n\n- 每一个 Web API 只做一件事\n- 同一个功能不会有两个类似的 API 来做\n- 保持 ECMAScript 的平台无关性\n\n根本的问题在于，框架的职责在于提供一整套的解决方案，而平台 API 的设计要求是绝不能提供一整套的解决方案，这是无法调和的基本矛盾所在。\n\n- Web Components 做为浏览器底层特性不应该拿出来和 React 这类应用层框架相比较。\n- 未来 Web Components 会做为浏览器非常重要的特性存在\n- API 偏低层操作，易用性不够，在很长时间内开发者依旧会使用 React / Vue / Angular / Polymer 这样的框架\n- Web Components 可能会做为这些框架的底层来做组件间的互相引用的方法\n\n## 参考\n\n[Web Component MDN](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)\n\n[https://www.webcomponents.org/](https://www.webcomponents.org/)\n\n[https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn](https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn)\n","source":"_posts/浅谈-Web-Components.md","raw":"---\ntitle: 浅谈 Web Components\ndate: 2018-07-19 11:26:10\ntags:\n  - JavaCcript\ncategories: JavaCcript\n---\n\n![](https://static.skynian.cn/18-7-21/31724707.jpg)\n\nWeb Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。\n\n<!--more-->\n\n## 一个有趣的 UI 库\n\n某天，逛逛论坛的时候，发现了一个很有趣手绘风格的 U 组件库。当然重点在于它是基于 Web Components 的实现。\n\n因为在此之前，对 Web Components 没有更多了解，这次趁着这次机会简单总结了一下这方面的知识。\n\n虽然说，目前没看到这套技术大规模使用，但随着越来越多的浏览器对 Web Components 的支持，是否会从底层改变诸如 Vue 和 React 组件化方案的实现方式呢？\n\n[https://github.com/wiredjs/wired-elements](https://github.com/wiredjs/wired-elements)\n\n![image](https://static.skynian.cn/18-7-19/73652975.jpg)\n\n## What ?\n\nWeb Components are a new browser feature that provides a standard component model for the Web, consisting of several pieces: Shadow DOM, Custom Elements, HTML Imports and HTML Templates.\n\n摘自 [https://github.com/w3c/webcomponents](https://github.com/w3c/webcomponents)\n\n也就是说，Web Components 是 Web 组件模型标准，由浏览器提供原生特性支持，包括 Shadow DOM，Custom Elements，HTML Imports 和 HTML Templates\n\n## 涉及规范\n\n- `Custom elements（自定义元素）`：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。\n  [https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements)\n- `Shadow DOM（影子DOM）`：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\n- `HTML templates（HTML模板）`：`<template>` 和 `<slot>` 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\n- `HTML Imports（HTML导入）`：一旦定义了自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。HTML 导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的。\n\n## 实现重点\n\n```html\n// 从 video 说起，效果类似于 //\n含有该片段的HTML页面将呈现一个功能完整的视频播放器，带播放按钮，进度条，音量调节按钮等等\n\n<video src=\"./video.mp4\" controls></video>\n\n<input type=\"text\" value=\"test\" placeholder=\"placeholder\" />\n```\n\n- 核心是 组件封装\n- video、input 相当于浏览器的内置组件，组件视图结构及默认样式藏在 Shadow DOM 里，组件逻辑被彻底藏了起来，仅暴露出 autoplay，oninput 等状态 / 行为 Hook 与外界通信\n\n![](https://static.skynian.cn/18-7-21/60213309.jpg)\n\n## Shadom DOM\n\n1. 利用浏览器提供的 Shadow DOM 特性，我们可以创建自己的 Shadow Root：\n\n```js\ndocument.body.innerHTML = '<div class=\"container\"></div>';\n\nlet host = document.querySelector(\".container\");\nlet root = host.createShadowRoot();\n\nroot.innerHTML = \"<p>How <em>you</em> doin?</p>\";\n```\n\n2. 此时的节点结构是：\n\n```html\n<div class=\"container\">\n  #shadow-root (open)\n  <p>How <em>you</em> doin?</p>\n</div>\n```\n\n3. 可以对 Fragment 做 DOM 操作，相当于一个独立的 HTML 解析环境，不受外界干扰\n\nShadow DOM 这款工具旨在构建基于组件的应用。因此，可为网络开发中的常见问题提供解决方案：\n\n- `隔离 DOM`：组件的 DOM 是独立的（例如，document.querySelector() 不会返回组件 shadow DOM 中的节点）。\n- `作用域 CSS`：shadow DOM 内部定义的 CSS 在其作用域内。样式规则不会泄漏，页面样式也不会渗入。\n- `组合`：为组件设计一个声明性、基于标记的 API。\n- `简化 CSS` - 作用域 DOM 意味着您可以使用简单的 CSS 选择器，更通用的 id/类名称，而无需担心命名冲突。\n- `效率` - 将应用看成是多个 DOM 块，而不是一个大的（全局性）页面。\n\n## 事件的封装\n\nShadow Dom 对于事件通过在冒泡阶段 target 的重定向来封装事件，然后一些可能对页面造成影响的事件，Shadow Dom 就会影藏掉这些事件，也就是在冒泡到主页面的过程中被挡住了。\n\n![](https://static.skynian.cn/18-7-21/1188753.jpg)\n\n## 创建流程\n\n1. 使用 `ECMAScript 2015` 类语法创建一个类，来指定 web 组件的功能使用\n2. `CustomElementRegistry.define()` 方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类以及可选的，其所继承自的元素。\n3. 使用 `Element.attachShadow()`方法将一个 shadow DOM 附加到自定义元素上。使用通常的 DOM 方法向 shadow DOM 中添加子元素、事件监听器等等。\n4. 使用 `<template>` 和 `<slot>` 方法定义一个 HTML 模板。再次使用常规 DOM 方法克隆模板并将其附加到您的 shadow DOM 中。\n\n例子：[https://github.com/mdn/web-components-examples](https://github.com/mdn/web-components-examples)\n\n## 兼容性\n\n![](https://static.skynian.cn/18-7-21/78737181.jpg)\n\n## 常见封装类库\n\n- `Polymer`: Google 推出的 web 组件库，支持数据的单向和双向绑定，兼容性较好，跨浏览器性能也较好；\n- `X-Tag`: 微软推出的开源库，支持 Web Components 规范，兼容 Web ComponentsAPI；\n- `Slim.js`: 轻量级的 web 组件库，专注于帮助开发者更好的编写原生 web 组件，而不依赖于其他框架，但是也提供了良好的拓展性，开发者可以自由拓展。\n\n## Polymer 3.0\n\nPolymer 能提供的特性\n\n- `自定义元素`。注册元素将类与自定义元素名称相关联。该元素提供回调以管理其生命周期。 Polymer 还可以让您声明属物，将元素的属物 API 与 Polymer 数据系统集成。\n- `阴影 DOM`。阴影 DOM 为您的元素提供了本地封装的 DOM 树。Polymer 可以自动用 DOM 模板为您的元素创建和填充阴影树。\n- `事件`。Polymer 提供了一个用于将事件监听器附加到阴影 DOM 子节点的声明性语法。它还提供了一个用于处理手势事件的可选库。\n- `数据系统`。Polymer 数据系统提供与属物和属性的数据绑定; 属物观察者，和被计算的属物。\n\n## What's new in 3.0\n\n- 在 Google I/O 2018 大会上，Google 推出了 Polymer 3.0\n\n- Web 组件的生态系统从 HTML Imports 转移到 ES Modules。\n\n- 包管理系统将支持 npm，更容易将基于 Polymer 的 web 组件和各种工具、框架协同使用。\n\n[https://www.polymer-project.org/3.0/start/quick-tour](使用例子)\n\n## Vue 与 Web Components\n\n- Vue 在实现上遵从了部分 Web Components 规范，比如 Shadow DOM 里的 slot：\n\n[https://cn.vuejs.org/v2/guide/components-slots.html](https://cn.vuejs.org/v2/guide/components-slots.html)\n\n- 因为 Web Components 规范尚不成熟，且支持性并不乐观，不用 polyfill 就无法投入生产，Vue 依靠构建工具跨过了环境兼容性问题，不依赖浏览器特性支持，但同时也就舍弃了 Shadow DOM 封装性等 Web Components 核心优势\n- 另外，Web Components 是相对底层的组件规范，Vue 除了定义组件规范，还提供了组件通信，数据绑定等上层方案\n\n## React 与 Web Components\n\nReact 和 web 组件 被用以解决不同问题。\n\nWeb 组件为可重用组件提供了强大的封装能力，而 React 则是提供了保持 DOM 和数据同步的声明式库。二者目标互补。\n\n可以在 Web 组件里使用 React，或者在 React 里使用 Web Components。\n\n[https://reactjs.org/docs/web-components.html](https://reactjs.org/docs/web-components.html)\n\n## Angular 与 Web Components\n\nAngular 默认情况下没有使用 Web Components 的任何基础设施\n\n不过这里有一个选项问题，就是 Angular 可以设置不同的 ViewEncapsulation，如果是 Native，那会使用到 Shadow DOM 的 API；如果是默认的 Emulated，就不会用到。\n\n[https://angular.io/api/core/ViewEncapsulation](https://angular.io/api/core/ViewEncapsulation)\n\n## 总结\n\nWeb 「相关」规范设计中一般有一些基本的共识：\n\n- 每一个 Web API 只做一件事\n- 同一个功能不会有两个类似的 API 来做\n- 保持 ECMAScript 的平台无关性\n\n根本的问题在于，框架的职责在于提供一整套的解决方案，而平台 API 的设计要求是绝不能提供一整套的解决方案，这是无法调和的基本矛盾所在。\n\n- Web Components 做为浏览器底层特性不应该拿出来和 React 这类应用层框架相比较。\n- 未来 Web Components 会做为浏览器非常重要的特性存在\n- API 偏低层操作，易用性不够，在很长时间内开发者依旧会使用 React / Vue / Angular / Polymer 这样的框架\n- Web Components 可能会做为这些框架的底层来做组件间的互相引用的方法\n\n## 参考\n\n[Web Component MDN](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)\n\n[https://www.webcomponents.org/](https://www.webcomponents.org/)\n\n[https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn](https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn)\n","slug":"浅谈-Web-Components","published":1,"updated":"2018-12-25T07:25:57.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq3g2jbk001pgzq20nsaocg3","content":"<p><img src=\"https://static.skynian.cn/18-7-21/31724707.jpg\" alt=\"\"></p>\n<p>Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。</p>\n<a id=\"more\"></a>\n<h2 id=\"一个有趣的-UI-库\"><a href=\"#一个有趣的-UI-库\" class=\"headerlink\" title=\"一个有趣的 UI 库\"></a>一个有趣的 UI 库</h2><p>某天，逛逛论坛的时候，发现了一个很有趣手绘风格的 U 组件库。当然重点在于它是基于 Web Components 的实现。</p>\n<p>因为在此之前，对 Web Components 没有更多了解，这次趁着这次机会简单总结了一下这方面的知识。</p>\n<p>虽然说，目前没看到这套技术大规模使用，但随着越来越多的浏览器对 Web Components 的支持，是否会从底层改变诸如 Vue 和 React 组件化方案的实现方式呢？</p>\n<p><a href=\"https://github.com/wiredjs/wired-elements\" target=\"_blank\" rel=\"noopener\">https://github.com/wiredjs/wired-elements</a></p>\n<p><img src=\"https://static.skynian.cn/18-7-19/73652975.jpg\" alt=\"image\"></p>\n<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What ?\"></a>What ?</h2><p>Web Components are a new browser feature that provides a standard component model for the Web, consisting of several pieces: Shadow DOM, Custom Elements, HTML Imports and HTML Templates.</p>\n<p>摘自 <a href=\"https://github.com/w3c/webcomponents\" target=\"_blank\" rel=\"noopener\">https://github.com/w3c/webcomponents</a></p>\n<p>也就是说，Web Components 是 Web 组件模型标准，由浏览器提供原生特性支持，包括 Shadow DOM，Custom Elements，HTML Imports 和 HTML Templates</p>\n<h2 id=\"涉及规范\"><a href=\"#涉及规范\" class=\"headerlink\" title=\"涉及规范\"></a>涉及规范</h2><ul>\n<li><code>Custom elements（自定义元素）</code>：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements</a></li>\n<li><code>Shadow DOM（影子DOM）</code>：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</li>\n<li><code>HTML templates（HTML模板）</code>：<code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</li>\n<li><code>HTML Imports（HTML导入）</code>：一旦定义了自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。HTML 导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的。</li>\n</ul>\n<h2 id=\"实现重点\"><a href=\"#实现重点\" class=\"headerlink\" title=\"实现重点\"></a>实现重点</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 从 video 说起，效果类似于 //</span><br><span class=\"line\">含有该片段的HTML页面将呈现一个功能完整的视频播放器，带播放按钮，进度条，音量调节按钮等等</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./video.mp4\"</span> <span class=\"attr\">controls</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"placeholder\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>核心是 组件封装</li>\n<li>video、input 相当于浏览器的内置组件，组件视图结构及默认样式藏在 Shadow DOM 里，组件逻辑被彻底藏了起来，仅暴露出 autoplay，oninput 等状态 / 行为 Hook 与外界通信</li>\n</ul>\n<p><img src=\"https://static.skynian.cn/18-7-21/60213309.jpg\" alt=\"\"></p>\n<h2 id=\"Shadom-DOM\"><a href=\"#Shadom-DOM\" class=\"headerlink\" title=\"Shadom DOM\"></a>Shadom DOM</h2><ol>\n<li>利用浏览器提供的 Shadow DOM 特性，我们可以创建自己的 Shadow Root：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">'&lt;div class=\"container\"&gt;&lt;/div&gt;'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> host = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".container\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> root = host.createShadowRoot();</span><br><span class=\"line\"></span><br><span class=\"line\">root.innerHTML = <span class=\"string\">\"&lt;p&gt;How &lt;em&gt;you&lt;/em&gt; doin?&lt;/p&gt;\"</span>;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>此时的节点结构是：</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">  #shadow-root (open)</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>How <span class=\"tag\">&lt;<span class=\"name\">em</span>&gt;</span>you<span class=\"tag\">&lt;/<span class=\"name\">em</span>&gt;</span> doin?<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>可以对 Fragment 做 DOM 操作，相当于一个独立的 HTML 解析环境，不受外界干扰</li>\n</ol>\n<p>Shadow DOM 这款工具旨在构建基于组件的应用。因此，可为网络开发中的常见问题提供解决方案：</p>\n<ul>\n<li><code>隔离 DOM</code>：组件的 DOM 是独立的（例如，document.querySelector() 不会返回组件 shadow DOM 中的节点）。</li>\n<li><code>作用域 CSS</code>：shadow DOM 内部定义的 CSS 在其作用域内。样式规则不会泄漏，页面样式也不会渗入。</li>\n<li><code>组合</code>：为组件设计一个声明性、基于标记的 API。</li>\n<li><code>简化 CSS</code> - 作用域 DOM 意味着您可以使用简单的 CSS 选择器，更通用的 id/类名称，而无需担心命名冲突。</li>\n<li><code>效率</code> - 将应用看成是多个 DOM 块，而不是一个大的（全局性）页面。</li>\n</ul>\n<h2 id=\"事件的封装\"><a href=\"#事件的封装\" class=\"headerlink\" title=\"事件的封装\"></a>事件的封装</h2><p>Shadow Dom 对于事件通过在冒泡阶段 target 的重定向来封装事件，然后一些可能对页面造成影响的事件，Shadow Dom 就会影藏掉这些事件，也就是在冒泡到主页面的过程中被挡住了。</p>\n<p><img src=\"https://static.skynian.cn/18-7-21/1188753.jpg\" alt=\"\"></p>\n<h2 id=\"创建流程\"><a href=\"#创建流程\" class=\"headerlink\" title=\"创建流程\"></a>创建流程</h2><ol>\n<li>使用 <code>ECMAScript 2015</code> 类语法创建一个类，来指定 web 组件的功能使用</li>\n<li><code>CustomElementRegistry.define()</code> 方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类以及可选的，其所继承自的元素。</li>\n<li>使用 <code>Element.attachShadow()</code>方法将一个 shadow DOM 附加到自定义元素上。使用通常的 DOM 方法向 shadow DOM 中添加子元素、事件监听器等等。</li>\n<li>使用 <code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 方法定义一个 HTML 模板。再次使用常规 DOM 方法克隆模板并将其附加到您的 shadow DOM 中。</li>\n</ol>\n<p>例子：<a href=\"https://github.com/mdn/web-components-examples\" target=\"_blank\" rel=\"noopener\">https://github.com/mdn/web-components-examples</a></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p><img src=\"https://static.skynian.cn/18-7-21/78737181.jpg\" alt=\"\"></p>\n<h2 id=\"常见封装类库\"><a href=\"#常见封装类库\" class=\"headerlink\" title=\"常见封装类库\"></a>常见封装类库</h2><ul>\n<li><code>Polymer</code>: Google 推出的 web 组件库，支持数据的单向和双向绑定，兼容性较好，跨浏览器性能也较好；</li>\n<li><code>X-Tag</code>: 微软推出的开源库，支持 Web Components 规范，兼容 Web ComponentsAPI；</li>\n<li><code>Slim.js</code>: 轻量级的 web 组件库，专注于帮助开发者更好的编写原生 web 组件，而不依赖于其他框架，但是也提供了良好的拓展性，开发者可以自由拓展。</li>\n</ul>\n<h2 id=\"Polymer-3-0\"><a href=\"#Polymer-3-0\" class=\"headerlink\" title=\"Polymer 3.0\"></a>Polymer 3.0</h2><p>Polymer 能提供的特性</p>\n<ul>\n<li><code>自定义元素</code>。注册元素将类与自定义元素名称相关联。该元素提供回调以管理其生命周期。 Polymer 还可以让您声明属物，将元素的属物 API 与 Polymer 数据系统集成。</li>\n<li><code>阴影 DOM</code>。阴影 DOM 为您的元素提供了本地封装的 DOM 树。Polymer 可以自动用 DOM 模板为您的元素创建和填充阴影树。</li>\n<li><code>事件</code>。Polymer 提供了一个用于将事件监听器附加到阴影 DOM 子节点的声明性语法。它还提供了一个用于处理手势事件的可选库。</li>\n<li><code>数据系统</code>。Polymer 数据系统提供与属物和属性的数据绑定; 属物观察者，和被计算的属物。</li>\n</ul>\n<h2 id=\"What’s-new-in-3-0\"><a href=\"#What’s-new-in-3-0\" class=\"headerlink\" title=\"What’s new in 3.0\"></a>What’s new in 3.0</h2><ul>\n<li><p>在 Google I/O 2018 大会上，Google 推出了 Polymer 3.0</p>\n</li>\n<li><p>Web 组件的生态系统从 HTML Imports 转移到 ES Modules。</p>\n</li>\n<li><p>包管理系统将支持 npm，更容易将基于 Polymer 的 web 组件和各种工具、框架协同使用。</p>\n</li>\n</ul>\n<p><a href=\"使用例子\">https://www.polymer-project.org/3.0/start/quick-tour</a></p>\n<h2 id=\"Vue-与-Web-Components\"><a href=\"#Vue-与-Web-Components\" class=\"headerlink\" title=\"Vue 与 Web Components\"></a>Vue 与 Web Components</h2><ul>\n<li>Vue 在实现上遵从了部分 Web Components 规范，比如 Shadow DOM 里的 slot：</li>\n</ul>\n<p><a href=\"https://cn.vuejs.org/v2/guide/components-slots.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/components-slots.html</a></p>\n<ul>\n<li>因为 Web Components 规范尚不成熟，且支持性并不乐观，不用 polyfill 就无法投入生产，Vue 依靠构建工具跨过了环境兼容性问题，不依赖浏览器特性支持，但同时也就舍弃了 Shadow DOM 封装性等 Web Components 核心优势</li>\n<li>另外，Web Components 是相对底层的组件规范，Vue 除了定义组件规范，还提供了组件通信，数据绑定等上层方案</li>\n</ul>\n<h2 id=\"React-与-Web-Components\"><a href=\"#React-与-Web-Components\" class=\"headerlink\" title=\"React 与 Web Components\"></a>React 与 Web Components</h2><p>React 和 web 组件 被用以解决不同问题。</p>\n<p>Web 组件为可重用组件提供了强大的封装能力，而 React 则是提供了保持 DOM 和数据同步的声明式库。二者目标互补。</p>\n<p>可以在 Web 组件里使用 React，或者在 React 里使用 Web Components。</p>\n<p><a href=\"https://reactjs.org/docs/web-components.html\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/web-components.html</a></p>\n<h2 id=\"Angular-与-Web-Components\"><a href=\"#Angular-与-Web-Components\" class=\"headerlink\" title=\"Angular 与 Web Components\"></a>Angular 与 Web Components</h2><p>Angular 默认情况下没有使用 Web Components 的任何基础设施</p>\n<p>不过这里有一个选项问题，就是 Angular 可以设置不同的 ViewEncapsulation，如果是 Native，那会使用到 Shadow DOM 的 API；如果是默认的 Emulated，就不会用到。</p>\n<p><a href=\"https://angular.io/api/core/ViewEncapsulation\" target=\"_blank\" rel=\"noopener\">https://angular.io/api/core/ViewEncapsulation</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Web 「相关」规范设计中一般有一些基本的共识：</p>\n<ul>\n<li>每一个 Web API 只做一件事</li>\n<li>同一个功能不会有两个类似的 API 来做</li>\n<li>保持 ECMAScript 的平台无关性</li>\n</ul>\n<p>根本的问题在于，框架的职责在于提供一整套的解决方案，而平台 API 的设计要求是绝不能提供一整套的解决方案，这是无法调和的基本矛盾所在。</p>\n<ul>\n<li>Web Components 做为浏览器底层特性不应该拿出来和 React 这类应用层框架相比较。</li>\n<li>未来 Web Components 会做为浏览器非常重要的特性存在</li>\n<li>API 偏低层操作，易用性不够，在很长时间内开发者依旧会使用 React / Vue / Angular / Polymer 这样的框架</li>\n<li>Web Components 可能会做为这些框架的底层来做组件间的互相引用的方法</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components\" target=\"_blank\" rel=\"noopener\">Web Component MDN</a></p>\n<p><a href=\"https://www.webcomponents.org/\" target=\"_blank\" rel=\"noopener\">https://www.webcomponents.org/</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"darker","social":{"github":"https://github.com/sijianian"},"algolia_search":{"enable":true,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"96aa37ccd951cae93b8933a2366c5470","google_analytics":"UA-110022311-1","stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://static.skynian.cn/README-2018611232116.jpg","top_img":"https://static.skynian.cn/18-12-25/2092366.jpg","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2017,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p><img src=\"https://static.skynian.cn/18-7-21/31724707.jpg\" alt=\"\"></p>\n<p>Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。</p>","more":"<h2 id=\"一个有趣的-UI-库\"><a href=\"#一个有趣的-UI-库\" class=\"headerlink\" title=\"一个有趣的 UI 库\"></a>一个有趣的 UI 库</h2><p>某天，逛逛论坛的时候，发现了一个很有趣手绘风格的 U 组件库。当然重点在于它是基于 Web Components 的实现。</p>\n<p>因为在此之前，对 Web Components 没有更多了解，这次趁着这次机会简单总结了一下这方面的知识。</p>\n<p>虽然说，目前没看到这套技术大规模使用，但随着越来越多的浏览器对 Web Components 的支持，是否会从底层改变诸如 Vue 和 React 组件化方案的实现方式呢？</p>\n<p><a href=\"https://github.com/wiredjs/wired-elements\" target=\"_blank\" rel=\"noopener\">https://github.com/wiredjs/wired-elements</a></p>\n<p><img src=\"https://static.skynian.cn/18-7-19/73652975.jpg\" alt=\"image\"></p>\n<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What ?\"></a>What ?</h2><p>Web Components are a new browser feature that provides a standard component model for the Web, consisting of several pieces: Shadow DOM, Custom Elements, HTML Imports and HTML Templates.</p>\n<p>摘自 <a href=\"https://github.com/w3c/webcomponents\" target=\"_blank\" rel=\"noopener\">https://github.com/w3c/webcomponents</a></p>\n<p>也就是说，Web Components 是 Web 组件模型标准，由浏览器提供原生特性支持，包括 Shadow DOM，Custom Elements，HTML Imports 和 HTML Templates</p>\n<h2 id=\"涉及规范\"><a href=\"#涉及规范\" class=\"headerlink\" title=\"涉及规范\"></a>涉及规范</h2><ul>\n<li><code>Custom elements（自定义元素）</code>：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements</a></li>\n<li><code>Shadow DOM（影子DOM）</code>：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</li>\n<li><code>HTML templates（HTML模板）</code>：<code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</li>\n<li><code>HTML Imports（HTML导入）</code>：一旦定义了自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。HTML 导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的。</li>\n</ul>\n<h2 id=\"实现重点\"><a href=\"#实现重点\" class=\"headerlink\" title=\"实现重点\"></a>实现重点</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 从 video 说起，效果类似于 //</span><br><span class=\"line\">含有该片段的HTML页面将呈现一个功能完整的视频播放器，带播放按钮，进度条，音量调节按钮等等</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./video.mp4\"</span> <span class=\"attr\">controls</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"placeholder\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>核心是 组件封装</li>\n<li>video、input 相当于浏览器的内置组件，组件视图结构及默认样式藏在 Shadow DOM 里，组件逻辑被彻底藏了起来，仅暴露出 autoplay，oninput 等状态 / 行为 Hook 与外界通信</li>\n</ul>\n<p><img src=\"https://static.skynian.cn/18-7-21/60213309.jpg\" alt=\"\"></p>\n<h2 id=\"Shadom-DOM\"><a href=\"#Shadom-DOM\" class=\"headerlink\" title=\"Shadom DOM\"></a>Shadom DOM</h2><ol>\n<li>利用浏览器提供的 Shadow DOM 特性，我们可以创建自己的 Shadow Root：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">'&lt;div class=\"container\"&gt;&lt;/div&gt;'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> host = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".container\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> root = host.createShadowRoot();</span><br><span class=\"line\"></span><br><span class=\"line\">root.innerHTML = <span class=\"string\">\"&lt;p&gt;How &lt;em&gt;you&lt;/em&gt; doin?&lt;/p&gt;\"</span>;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>此时的节点结构是：</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">  #shadow-root (open)</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>How <span class=\"tag\">&lt;<span class=\"name\">em</span>&gt;</span>you<span class=\"tag\">&lt;/<span class=\"name\">em</span>&gt;</span> doin?<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>可以对 Fragment 做 DOM 操作，相当于一个独立的 HTML 解析环境，不受外界干扰</li>\n</ol>\n<p>Shadow DOM 这款工具旨在构建基于组件的应用。因此，可为网络开发中的常见问题提供解决方案：</p>\n<ul>\n<li><code>隔离 DOM</code>：组件的 DOM 是独立的（例如，document.querySelector() 不会返回组件 shadow DOM 中的节点）。</li>\n<li><code>作用域 CSS</code>：shadow DOM 内部定义的 CSS 在其作用域内。样式规则不会泄漏，页面样式也不会渗入。</li>\n<li><code>组合</code>：为组件设计一个声明性、基于标记的 API。</li>\n<li><code>简化 CSS</code> - 作用域 DOM 意味着您可以使用简单的 CSS 选择器，更通用的 id/类名称，而无需担心命名冲突。</li>\n<li><code>效率</code> - 将应用看成是多个 DOM 块，而不是一个大的（全局性）页面。</li>\n</ul>\n<h2 id=\"事件的封装\"><a href=\"#事件的封装\" class=\"headerlink\" title=\"事件的封装\"></a>事件的封装</h2><p>Shadow Dom 对于事件通过在冒泡阶段 target 的重定向来封装事件，然后一些可能对页面造成影响的事件，Shadow Dom 就会影藏掉这些事件，也就是在冒泡到主页面的过程中被挡住了。</p>\n<p><img src=\"https://static.skynian.cn/18-7-21/1188753.jpg\" alt=\"\"></p>\n<h2 id=\"创建流程\"><a href=\"#创建流程\" class=\"headerlink\" title=\"创建流程\"></a>创建流程</h2><ol>\n<li>使用 <code>ECMAScript 2015</code> 类语法创建一个类，来指定 web 组件的功能使用</li>\n<li><code>CustomElementRegistry.define()</code> 方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类以及可选的，其所继承自的元素。</li>\n<li>使用 <code>Element.attachShadow()</code>方法将一个 shadow DOM 附加到自定义元素上。使用通常的 DOM 方法向 shadow DOM 中添加子元素、事件监听器等等。</li>\n<li>使用 <code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 方法定义一个 HTML 模板。再次使用常规 DOM 方法克隆模板并将其附加到您的 shadow DOM 中。</li>\n</ol>\n<p>例子：<a href=\"https://github.com/mdn/web-components-examples\" target=\"_blank\" rel=\"noopener\">https://github.com/mdn/web-components-examples</a></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p><img src=\"https://static.skynian.cn/18-7-21/78737181.jpg\" alt=\"\"></p>\n<h2 id=\"常见封装类库\"><a href=\"#常见封装类库\" class=\"headerlink\" title=\"常见封装类库\"></a>常见封装类库</h2><ul>\n<li><code>Polymer</code>: Google 推出的 web 组件库，支持数据的单向和双向绑定，兼容性较好，跨浏览器性能也较好；</li>\n<li><code>X-Tag</code>: 微软推出的开源库，支持 Web Components 规范，兼容 Web ComponentsAPI；</li>\n<li><code>Slim.js</code>: 轻量级的 web 组件库，专注于帮助开发者更好的编写原生 web 组件，而不依赖于其他框架，但是也提供了良好的拓展性，开发者可以自由拓展。</li>\n</ul>\n<h2 id=\"Polymer-3-0\"><a href=\"#Polymer-3-0\" class=\"headerlink\" title=\"Polymer 3.0\"></a>Polymer 3.0</h2><p>Polymer 能提供的特性</p>\n<ul>\n<li><code>自定义元素</code>。注册元素将类与自定义元素名称相关联。该元素提供回调以管理其生命周期。 Polymer 还可以让您声明属物，将元素的属物 API 与 Polymer 数据系统集成。</li>\n<li><code>阴影 DOM</code>。阴影 DOM 为您的元素提供了本地封装的 DOM 树。Polymer 可以自动用 DOM 模板为您的元素创建和填充阴影树。</li>\n<li><code>事件</code>。Polymer 提供了一个用于将事件监听器附加到阴影 DOM 子节点的声明性语法。它还提供了一个用于处理手势事件的可选库。</li>\n<li><code>数据系统</code>。Polymer 数据系统提供与属物和属性的数据绑定; 属物观察者，和被计算的属物。</li>\n</ul>\n<h2 id=\"What’s-new-in-3-0\"><a href=\"#What’s-new-in-3-0\" class=\"headerlink\" title=\"What’s new in 3.0\"></a>What’s new in 3.0</h2><ul>\n<li><p>在 Google I/O 2018 大会上，Google 推出了 Polymer 3.0</p>\n</li>\n<li><p>Web 组件的生态系统从 HTML Imports 转移到 ES Modules。</p>\n</li>\n<li><p>包管理系统将支持 npm，更容易将基于 Polymer 的 web 组件和各种工具、框架协同使用。</p>\n</li>\n</ul>\n<p><a href=\"使用例子\">https://www.polymer-project.org/3.0/start/quick-tour</a></p>\n<h2 id=\"Vue-与-Web-Components\"><a href=\"#Vue-与-Web-Components\" class=\"headerlink\" title=\"Vue 与 Web Components\"></a>Vue 与 Web Components</h2><ul>\n<li>Vue 在实现上遵从了部分 Web Components 规范，比如 Shadow DOM 里的 slot：</li>\n</ul>\n<p><a href=\"https://cn.vuejs.org/v2/guide/components-slots.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/components-slots.html</a></p>\n<ul>\n<li>因为 Web Components 规范尚不成熟，且支持性并不乐观，不用 polyfill 就无法投入生产，Vue 依靠构建工具跨过了环境兼容性问题，不依赖浏览器特性支持，但同时也就舍弃了 Shadow DOM 封装性等 Web Components 核心优势</li>\n<li>另外，Web Components 是相对底层的组件规范，Vue 除了定义组件规范，还提供了组件通信，数据绑定等上层方案</li>\n</ul>\n<h2 id=\"React-与-Web-Components\"><a href=\"#React-与-Web-Components\" class=\"headerlink\" title=\"React 与 Web Components\"></a>React 与 Web Components</h2><p>React 和 web 组件 被用以解决不同问题。</p>\n<p>Web 组件为可重用组件提供了强大的封装能力，而 React 则是提供了保持 DOM 和数据同步的声明式库。二者目标互补。</p>\n<p>可以在 Web 组件里使用 React，或者在 React 里使用 Web Components。</p>\n<p><a href=\"https://reactjs.org/docs/web-components.html\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/web-components.html</a></p>\n<h2 id=\"Angular-与-Web-Components\"><a href=\"#Angular-与-Web-Components\" class=\"headerlink\" title=\"Angular 与 Web Components\"></a>Angular 与 Web Components</h2><p>Angular 默认情况下没有使用 Web Components 的任何基础设施</p>\n<p>不过这里有一个选项问题，就是 Angular 可以设置不同的 ViewEncapsulation，如果是 Native，那会使用到 Shadow DOM 的 API；如果是默认的 Emulated，就不会用到。</p>\n<p><a href=\"https://angular.io/api/core/ViewEncapsulation\" target=\"_blank\" rel=\"noopener\">https://angular.io/api/core/ViewEncapsulation</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Web 「相关」规范设计中一般有一些基本的共识：</p>\n<ul>\n<li>每一个 Web API 只做一件事</li>\n<li>同一个功能不会有两个类似的 API 来做</li>\n<li>保持 ECMAScript 的平台无关性</li>\n</ul>\n<p>根本的问题在于，框架的职责在于提供一整套的解决方案，而平台 API 的设计要求是绝不能提供一整套的解决方案，这是无法调和的基本矛盾所在。</p>\n<ul>\n<li>Web Components 做为浏览器底层特性不应该拿出来和 React 这类应用层框架相比较。</li>\n<li>未来 Web Components 会做为浏览器非常重要的特性存在</li>\n<li>API 偏低层操作，易用性不够，在很长时间内开发者依旧会使用 React / Vue / Angular / Polymer 这样的框架</li>\n<li>Web Components 可能会做为这些框架的底层来做组件间的互相引用的方法</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components\" target=\"_blank\" rel=\"noopener\">Web Component MDN</a></p>\n<p><a href=\"https://www.webcomponents.org/\" target=\"_blank\" rel=\"noopener\">https://www.webcomponents.org/</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjq3g2iea0000gzq2gwelzt0x","category_id":"cjq3g2ieg0002gzq2z6bmahhg","_id":"cjq3g2iem000bgzq2gt75mrh1"},{"post_id":"cjq3g2iel0009gzq295qjvk5i","category_id":"cjq3g2iek0007gzq2r5ghrwfb","_id":"cjq3g2iet000hgzq29y8ztp8j"},{"post_id":"cjq3g2iee0001gzq26sorvefo","category_id":"cjq3g2iek0007gzq2r5ghrwfb","_id":"cjq3g2iev000mgzq2asyv2pek"},{"post_id":"cjq3g2iem000agzq24hxbj5zm","category_id":"cjq3g2iek0007gzq2r5ghrwfb","_id":"cjq3g2iew000ogzq2jidahcu2"},{"post_id":"cjq3g2iei0004gzq23p4v1wtt","category_id":"cjq3g2iek0007gzq2r5ghrwfb","_id":"cjq3g2iew000sgzq22kdjfacj"},{"post_id":"cjq3g2ier000ggzq2kyonvdpp","category_id":"cjq3g2iek0007gzq2r5ghrwfb","_id":"cjq3g2iex000ugzq280382t50"},{"post_id":"cjq3g2iei0005gzq27ntyzpau","category_id":"cjq3g2iek0007gzq2r5ghrwfb","_id":"cjq3g2iex000ygzq2kzai4vp8"},{"post_id":"cjq3g2iej0006gzq2izjmrwdb","category_id":"cjq3g2iew000qgzq2whf6t506","_id":"cjq3g2iey0011gzq203c6thnl"},{"post_id":"cjq3g2iep000egzq21kdc7kfn","category_id":"cjq3g2iex000wgzq2iysiqo5z","_id":"cjq3g2iez0015gzq2ogwzjjgi"},{"post_id":"cjq3g2ieu000lgzq20d0psg90","category_id":"cjq3g2iey0012gzq241n61log","_id":"cjq3g2if00019gzq2ooiygn4d"},{"post_id":"cjq3g2jba001egzq2q28zfobq","category_id":"cjq3g2iek0007gzq2r5ghrwfb","_id":"cjq3g2jbe001kgzq2v984hztv"},{"post_id":"cjq3g2jbc001hgzq2a5vaard0","category_id":"cjq3g2ieg0002gzq2z6bmahhg","_id":"cjq3g2jbe001mgzq2phjt4sss"},{"post_id":"cjq3g2jbk001pgzq20nsaocg3","category_id":"cjq3g2jbl001qgzq2x0kylbz4","_id":"cjq3g2jbl001tgzq2gviksc3c"}],"PostTag":[{"post_id":"cjq3g2iea0000gzq2gwelzt0x","tag_id":"cjq3g2ieh0003gzq2e7vszmzj","_id":"cjq3g2ier000fgzq2l7cci81v"},{"post_id":"cjq3g2iea0000gzq2gwelzt0x","tag_id":"cjq3g2iek0008gzq2d2mgvsuy","_id":"cjq3g2iet000igzq2flwqw0yx"},{"post_id":"cjq3g2iep000egzq21kdc7kfn","tag_id":"cjq3g2ien000dgzq27hf7ehh2","_id":"cjq3g2iev000ngzq2xwhd46wz"},{"post_id":"cjq3g2iep000egzq21kdc7kfn","tag_id":"cjq3g2iek0008gzq2d2mgvsuy","_id":"cjq3g2iew000pgzq2netugn4o"},{"post_id":"cjq3g2iee0001gzq26sorvefo","tag_id":"cjq3g2ien000dgzq27hf7ehh2","_id":"cjq3g2iex000tgzq22su5nypx"},{"post_id":"cjq3g2ier000ggzq2kyonvdpp","tag_id":"cjq3g2ien000dgzq27hf7ehh2","_id":"cjq3g2iex000vgzq2umhl8kwh"},{"post_id":"cjq3g2iei0004gzq23p4v1wtt","tag_id":"cjq3g2ieu000kgzq2f8oa3re9","_id":"cjq3g2iey000zgzq2dnwwgkxu"},{"post_id":"cjq3g2iei0005gzq27ntyzpau","tag_id":"cjq3g2ien000dgzq27hf7ehh2","_id":"cjq3g2iey0010gzq22v8h880d"},{"post_id":"cjq3g2iej0006gzq2izjmrwdb","tag_id":"cjq3g2iek0008gzq2d2mgvsuy","_id":"cjq3g2iez0014gzq2nyse3m37"},{"post_id":"cjq3g2iel0009gzq295qjvk5i","tag_id":"cjq3g2ien000dgzq27hf7ehh2","_id":"cjq3g2iez0017gzq2yujvsozj"},{"post_id":"cjq3g2iem000agzq24hxbj5zm","tag_id":"cjq3g2ien000dgzq27hf7ehh2","_id":"cjq3g2if0001agzq2a118uv81"},{"post_id":"cjq3g2ieu000lgzq20d0psg90","tag_id":"cjq3g2if00018gzq25dk0von0","_id":"cjq3g2if0001bgzq2b98lu4ud"},{"post_id":"cjq3g2jb8001cgzq2zqleahom","tag_id":"cjq3g2ien000dgzq27hf7ehh2","_id":"cjq3g2jbc001ggzq235ylu1fg"},{"post_id":"cjq3g2jbc001hgzq2a5vaard0","tag_id":"cjq3g2ieh0003gzq2e7vszmzj","_id":"cjq3g2jbe001jgzq2zpgjymgr"},{"post_id":"cjq3g2jbc001hgzq2a5vaard0","tag_id":"cjq3g2iek0008gzq2d2mgvsuy","_id":"cjq3g2jbe001lgzq245eymkgj"},{"post_id":"cjq3g2jba001egzq2q28zfobq","tag_id":"cjq3g2ien000dgzq27hf7ehh2","_id":"cjq3g2jbf001ngzq24anoyvfy"},{"post_id":"cjq3g2jba001egzq2q28zfobq","tag_id":"cjq3g2jbd001igzq2qeg686w8","_id":"cjq3g2jbf001ogzq2en0ppron"},{"post_id":"cjq3g2jbk001pgzq20nsaocg3","tag_id":"cjq3g2jbl001rgzq27tp2d3jo","_id":"cjq3g2jbl001sgzq2xnywe1qr"}],"Tag":[{"name":"布局","_id":"cjq3g2ieh0003gzq2e7vszmzj"},{"name":"CSS","_id":"cjq3g2iek0008gzq2d2mgvsuy"},{"name":"JavaScript","_id":"cjq3g2ien000dgzq27hf7ehh2"},{"name":"Vue","_id":"cjq3g2ieu000kgzq2f8oa3re9"},{"name":"HTTP","_id":"cjq3g2if00018gzq25dk0von0"},{"name":"优化","_id":"cjq3g2jbd001igzq2qeg686w8"},{"name":"JavaCcript","_id":"cjq3g2jbl001rgzq27tp2d3jo"}]}}